package gov.sir.forseti.dao.impl.jdogenie;

import gov.sir.core.negocio.modelo.Anotacion;
import gov.sir.core.negocio.modelo.AnotacionCiudadano;
import gov.sir.core.negocio.modelo.AnotacionPk;
import gov.sir.core.negocio.modelo.BloqueoFolio;
import gov.sir.core.negocio.modelo.Busqueda;
import gov.sir.core.negocio.modelo.BusquedaPk;
import gov.sir.core.negocio.modelo.Cancelacion;
import gov.sir.core.negocio.modelo.Ciudadano;
import gov.sir.core.negocio.modelo.CiudadanoPk;
import gov.sir.core.negocio.modelo.Complementacion;
import gov.sir.core.negocio.modelo.Direccion;
import gov.sir.core.negocio.modelo.DireccionPk;
import gov.sir.core.negocio.modelo.Documento;
import gov.sir.core.negocio.modelo.DocumentoPk;
import gov.sir.core.negocio.modelo.DominioNaturalezaJuridica;
import gov.sir.core.negocio.modelo.DominioNaturalezaJuridicaPk;
import gov.sir.core.negocio.modelo.EstadoAnotacion;
import gov.sir.core.negocio.modelo.EstadoAnotacionPk;
import gov.sir.core.negocio.modelo.EstadoFolio;
import gov.sir.core.negocio.modelo.EstadoFolioPk;
import gov.sir.core.negocio.modelo.EstadoHistoria;
import gov.sir.core.negocio.modelo.Folio;
import gov.sir.core.negocio.modelo.FolioDerivado;
import gov.sir.core.negocio.modelo.FolioPk;
import gov.sir.core.negocio.modelo.GrupoNaturalezaJuridica;
import gov.sir.core.negocio.modelo.GrupoNaturalezaJuridicaPk;
import gov.sir.core.negocio.modelo.Liquidacion;
import gov.sir.core.negocio.modelo.LlaveBloqueo;
import gov.sir.core.negocio.modelo.LlaveBloqueoPk;
import gov.sir.core.negocio.modelo.MunicipioPk;
import gov.sir.core.negocio.modelo.NaturalezaJuridica;
import gov.sir.core.negocio.modelo.NaturalezaJuridicaPk;
import gov.sir.core.negocio.modelo.OficinaOrigen;
import gov.sir.core.negocio.modelo.OficinaOrigenPk;
import gov.sir.core.negocio.modelo.PlantillaPertenencia;
import gov.sir.core.negocio.modelo.SalvedadAnotacion;
import gov.sir.core.negocio.modelo.SalvedadFolio;
import gov.sir.core.negocio.modelo.Solicitud;
import gov.sir.core.negocio.modelo.SolicitudFolio;
import gov.sir.core.negocio.modelo.SolicitudPk;
import gov.sir.core.negocio.modelo.TipoAnotacion;
import gov.sir.core.negocio.modelo.TipoAnotacionPk;
import gov.sir.core.negocio.modelo.TipoDocumento;
import gov.sir.core.negocio.modelo.TipoDocumentoPk;
import gov.sir.core.negocio.modelo.TipoOficina;
import gov.sir.core.negocio.modelo.TipoOficinaPk;
import gov.sir.core.negocio.modelo.TipoPredio;
import gov.sir.core.negocio.modelo.TipoPredioPk;
import gov.sir.core.negocio.modelo.Turno;
import gov.sir.core.negocio.modelo.TurnoFolio;
import gov.sir.core.negocio.modelo.TurnoHistoria;
import gov.sir.core.negocio.modelo.TurnoPk;
import gov.sir.core.negocio.modelo.Usuario;
import gov.sir.core.negocio.modelo.UsuarioPk;
import gov.sir.core.negocio.modelo.Vereda;
import gov.sir.core.negocio.modelo.VeredaPk;
import gov.sir.core.negocio.modelo.ZonaRegistral;
import gov.sir.core.negocio.modelo.constantes.CAnotacionCiudadano;
import gov.sir.core.negocio.modelo.constantes.CCiudadano;
import gov.sir.core.negocio.modelo.constantes.CComplementacion;
import gov.sir.core.negocio.modelo.constantes.CCriterio;
import gov.sir.core.negocio.modelo.constantes.CDocumento;
import gov.sir.core.negocio.modelo.constantes.CDominioNaturalezaJuridica;
import gov.sir.core.negocio.modelo.constantes.CEstadoAnotacion;
import gov.sir.core.negocio.modelo.constantes.CEstadoFolio;
import gov.sir.core.negocio.modelo.constantes.CFase;
import gov.sir.core.negocio.modelo.constantes.CModoBloqueo;
import gov.sir.core.negocio.modelo.constantes.CNaturalezaJuridica;
import gov.sir.core.negocio.modelo.constantes.CProceso;
import gov.sir.core.negocio.modelo.constantes.CProhibicion;
import gov.sir.core.negocio.modelo.constantes.CRespuesta;
import gov.sir.core.negocio.modelo.constantes.CSecuencias;
import gov.sir.core.negocio.modelo.constantes.CTipoAnotacion;
import gov.sir.core.negocio.modelo.constantes.CTipoRevisionCalificacion;
import gov.sir.core.negocio.modelo.constantes.CTurno;
import gov.sir.core.negocio.modelo.imprimibles.ImprimibleCertificado;
import gov.sir.core.negocio.modelo.util.IdTurnoHistoriaEnhancedComparator;
import gov.sir.core.negocio.modelo.util.IsToDeleteAnotacionCiudadanoTMPComparator;
import gov.sir.core.negocio.modelo.util.Log;
import gov.sir.core.negocio.modelo.util.ResultadoFolioComparator;
import gov.sir.forseti.ForsetiException;
import gov.sir.forseti.ForsetiProperties;
import gov.sir.forseti.dao.DAOException;
import gov.sir.forseti.dao.FolioDAO;
import gov.sir.hermod.HermodProperties;

import java.io.IOException;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Types;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.Set;
import java.util.StringTokenizer;

import javax.jdo.JDOException;
import javax.jdo.JDOObjectNotFoundException;
import javax.jdo.PersistenceManager;
import javax.jdo.Query;

import oracle.jdbc.OracleCallableStatement;
import oracle.jdbc.OracleTypes;
import oracle.sql.ARRAY;
import oracle.sql.STRUCT;

import com.versant.core.jdo.VersantPersistenceManager;
import com.versant.core.jdo.VersantQuery;
import gov.sir.core.negocio.modelo.constantes.CGrupoNaturalezaJuridica;
import gov.sir.core.negocio.modelo.jdogenie.AnotacionCiudadanoEnhanced;
import gov.sir.core.negocio.modelo.jdogenie.AnotacionCiudadanoEnhancedPk;
import gov.sir.core.negocio.modelo.jdogenie.AnotacionCiudadanoTMP;
import gov.sir.core.negocio.modelo.jdogenie.AnotacionCiudadanoTMPPk;
import gov.sir.core.negocio.modelo.jdogenie.AnotacionEnhanced;
import gov.sir.core.negocio.modelo.jdogenie.AnotacionEnhancedPk;
import gov.sir.core.negocio.modelo.jdogenie.AnotacionTMP;
import gov.sir.core.negocio.modelo.jdogenie.AnotacionTMPPk;
import gov.sir.core.negocio.modelo.jdogenie.BloqueoFolioEnhanced;
import gov.sir.core.negocio.modelo.jdogenie.BusquedaEnhanced;
import gov.sir.core.negocio.modelo.jdogenie.BusquedaEnhancedPk;
import gov.sir.core.negocio.modelo.jdogenie.CancelacionEnhanced;
import gov.sir.core.negocio.modelo.jdogenie.CancelacionTMP;
import gov.sir.core.negocio.modelo.jdogenie.CategoriaEnhanced;
import gov.sir.core.negocio.modelo.jdogenie.CategoriaEnhancedPk;
import gov.sir.core.negocio.modelo.jdogenie.CategoriaNotariaEnhanced;
import gov.sir.core.negocio.modelo.jdogenie.CategoriaNotariaEnhancedPk;
import gov.sir.core.negocio.modelo.jdogenie.CirculoEnhanced;
import gov.sir.core.negocio.modelo.jdogenie.CirculoEnhancedPk;
import gov.sir.core.negocio.modelo.jdogenie.CiudadanoEnhanced;
import gov.sir.core.negocio.modelo.jdogenie.CiudadanoEnhancedPk;
import gov.sir.core.negocio.modelo.jdogenie.CiudadanoTMP;
import gov.sir.core.negocio.modelo.jdogenie.CiudadanoTMPPk;
import gov.sir.core.negocio.modelo.jdogenie.ComplementacionConflictivaAuditoriaEnhanced;
import gov.sir.core.negocio.modelo.jdogenie.ComplementacionEnhanced;
import gov.sir.core.negocio.modelo.jdogenie.ComplementacionEnhancedPk;
import gov.sir.core.negocio.modelo.jdogenie.ComplementacionTMP;
import gov.sir.core.negocio.modelo.jdogenie.ComplementacionTMPPk;
import gov.sir.core.negocio.modelo.jdogenie.DatosAntiguoSistemaEnhanced;
import gov.sir.core.negocio.modelo.jdogenie.DatosAntiguoSistemaEnhancedPk;
import gov.sir.core.negocio.modelo.jdogenie.DepartamentoEnhancedPk;
import gov.sir.core.negocio.modelo.jdogenie.DireccionEnhanced;
import gov.sir.core.negocio.modelo.jdogenie.DireccionEnhancedPk;
import gov.sir.core.negocio.modelo.jdogenie.DireccionTMP;
import gov.sir.core.negocio.modelo.jdogenie.DireccionTMPPk;
import gov.sir.core.negocio.modelo.jdogenie.DocumentoEnhanced;
import gov.sir.core.negocio.modelo.jdogenie.DocumentoEnhancedPk;
import gov.sir.core.negocio.modelo.jdogenie.DocumentoTMP;
import gov.sir.core.negocio.modelo.jdogenie.DocumentoTMPPk;
import gov.sir.core.negocio.modelo.jdogenie.DominioNaturalezaJuridicaEnhanced;
import gov.sir.core.negocio.modelo.jdogenie.DominioNaturalezaJuridicaEnhancedPk;
import gov.sir.core.negocio.modelo.jdogenie.EjeEnhanced;
import gov.sir.core.negocio.modelo.jdogenie.EjeEnhancedPk;
import gov.sir.core.negocio.modelo.jdogenie.EstadoAnotacionEnhanced;
import gov.sir.core.negocio.modelo.jdogenie.EstadoAnotacionEnhancedPk;
import gov.sir.core.negocio.modelo.jdogenie.EstadoFolioEnhanced;
import gov.sir.core.negocio.modelo.jdogenie.EstadoFolioEnhancedPk;
import gov.sir.core.negocio.modelo.jdogenie.EstadoHistoriaEnhanced;
import gov.sir.core.negocio.modelo.jdogenie.FolioDatosTMP;
import gov.sir.core.negocio.modelo.jdogenie.FolioDatosTMPPk;
import gov.sir.core.negocio.modelo.jdogenie.FolioDerivadoEnhanced;
import gov.sir.core.negocio.modelo.jdogenie.FolioDerivadoEnhancedPk;
import gov.sir.core.negocio.modelo.jdogenie.FolioDerivadoTMP;
import gov.sir.core.negocio.modelo.jdogenie.FolioDerivadoTMPPk;
import gov.sir.core.negocio.modelo.jdogenie.FolioEnhanced;
import gov.sir.core.negocio.modelo.jdogenie.FolioEnhancedPk;
import gov.sir.core.negocio.modelo.jdogenie.GrupoNaturalezaJuridicaEnhanced;
import gov.sir.core.negocio.modelo.jdogenie.GrupoNaturalezaJuridicaEnhancedPk;
import gov.sir.core.negocio.modelo.jdogenie.LiquidacionEnhanced;
import gov.sir.core.negocio.modelo.jdogenie.LlaveBloqueoEnhanced;
import gov.sir.core.negocio.modelo.jdogenie.LlaveBloqueoEnhancedPk;
import gov.sir.core.negocio.modelo.jdogenie.MatriculaNoGrabadaEnhanced;
import gov.sir.core.negocio.modelo.jdogenie.MatriculaNoGrabadaEnhancedPk;
import gov.sir.core.negocio.modelo.jdogenie.MunicipioEnhanced;
import gov.sir.core.negocio.modelo.jdogenie.MunicipioEnhancedPk;
import gov.sir.core.negocio.modelo.jdogenie.NaturalezaJuridicaEnhanced;
import gov.sir.core.negocio.modelo.jdogenie.NaturalezaJuridicaEnhancedPk;
import gov.sir.core.negocio.modelo.jdogenie.OficinaCategoriaEnhanced;
import gov.sir.core.negocio.modelo.jdogenie.OficinaOrigenEnhanced;
import gov.sir.core.negocio.modelo.jdogenie.OficinaOrigenEnhancedPk;
import gov.sir.core.negocio.modelo.jdogenie.PagoEnhanced;
import gov.sir.core.negocio.modelo.jdogenie.PlantillaPertenenciaEnhanced;
import gov.sir.core.negocio.modelo.jdogenie.RecursoEnhanced;
import gov.sir.core.negocio.modelo.jdogenie.ResultadoAnotacionEnhanced;
import gov.sir.core.negocio.modelo.jdogenie.ResultadoFolioEnhanced;
import gov.sir.core.negocio.modelo.jdogenie.SalvedadAnotacionEnhanced;
import gov.sir.core.negocio.modelo.jdogenie.SalvedadAnotacionEnhancedPk;
import gov.sir.core.negocio.modelo.jdogenie.SalvedadAnotacionTMP;
import gov.sir.core.negocio.modelo.jdogenie.SalvedadAnotacionTMPPk;
import gov.sir.core.negocio.modelo.jdogenie.SalvedadFolioEnhanced;
import gov.sir.core.negocio.modelo.jdogenie.SalvedadFolioTMP;
import gov.sir.core.negocio.modelo.jdogenie.SalvedadFolioTMPPk;
import gov.sir.core.negocio.modelo.jdogenie.SecuenciasEnhanced;
import gov.sir.core.negocio.modelo.jdogenie.SecuenciasEnhancedPk;
import gov.sir.core.negocio.modelo.jdogenie.SolicitudEnhanced;
import gov.sir.core.negocio.modelo.jdogenie.SolicitudEnhancedPk;
import gov.sir.core.negocio.modelo.jdogenie.SolicitudFolioEnhanced;
import gov.sir.core.negocio.modelo.jdogenie.TipoAnotacionEnhanced;
import gov.sir.core.negocio.modelo.jdogenie.TipoAnotacionEnhancedPk;
import gov.sir.core.negocio.modelo.jdogenie.TipoDocumentoEnhanced;
import gov.sir.core.negocio.modelo.jdogenie.TipoDocumentoEnhancedPk;
import gov.sir.core.negocio.modelo.jdogenie.TipoOficinaEnhanced;
import gov.sir.core.negocio.modelo.jdogenie.TipoOficinaEnhancedPk;
import gov.sir.core.negocio.modelo.jdogenie.TipoPredioEnhanced;
import gov.sir.core.negocio.modelo.jdogenie.TipoPredioEnhancedPk;
import gov.sir.core.negocio.modelo.jdogenie.TransferUtils;
import gov.sir.core.negocio.modelo.jdogenie.TurnoAnotacionEnhanced;
import gov.sir.core.negocio.modelo.jdogenie.TurnoDerivadoEnhanced;
import gov.sir.core.negocio.modelo.jdogenie.TurnoEnhanced;
import gov.sir.core.negocio.modelo.jdogenie.TurnoEnhancedPk;
import gov.sir.core.negocio.modelo.jdogenie.TurnoFolioEnhanced;
import gov.sir.core.negocio.modelo.jdogenie.TurnoHistoriaEnhanced;
import gov.sir.core.negocio.modelo.jdogenie.TurnoSalvedadAnotacionEnhanced;
import gov.sir.core.negocio.modelo.jdogenie.TurnoSalvedadFolioEnhanced;
import gov.sir.core.negocio.modelo.jdogenie.UsuarioEnhanced;
import gov.sir.core.negocio.modelo.jdogenie.UsuarioEnhancedPk;
import gov.sir.core.negocio.modelo.jdogenie.VeredaEnhanced;
import gov.sir.core.negocio.modelo.jdogenie.VeredaEnhancedPk;
import gov.sir.core.negocio.modelo.jdogenie.ZonaRegistralEnhanced;
import gov.sir.core.negocio.modelo.jdogenie.ZonaRegistralEnhancedPk;
import java.io.Serializable;
import co.com.iridium.generalSIR.negocio.validaciones.TrasladoSIR;
import co.com.iridium.generalSIR.comun.GeneralSIRException;
/**
 * @Author Carlos Torres
 * @Mantis 13176
 * @Chaged
 */
import co.com.iridium.generalSIR.negocio.auditoria.AuditoriaSIR;
import gov.sir.core.negocio.modelo.HistorialAreas;
import gov.sir.core.negocio.modelo.OficinaCategoria;
import gov.sir.core.negocio.modelo.constantes.CError;
import gov.sir.core.negocio.modelo.constantes.CQueries;
import java.util.*;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * @autor:Edgar Lora
 * @mantis: 0011599
 * @requerimiento: 085_151
 */
import gov.sir.core.negocio.modelo.util.ComparadorAnotaciones;
import gov.sir.core.negocio.modelo.util.ComparadorAnotacionImprimible;
import gov.sir.forseti.ForsetiException;
import gov.sir.hermod.HermodService;
import gov.sir.hermod.dao.impl.jdogenie.JDOTurnosDAO;
/*
            *  @author Carlos Torres
            *  @chage   se habilita el uso de las clases en el paquete Map,Hashmap
            *  @mantis 12705: Acta - Requerimiento No 056_453_Modificiación_de_Naturaleza_Jurídica
 */
import java.util.Map;
import java.util.HashMap;

/**
 * Clase que implementa los servicios de folios y anotaciones de Forseti a
 * través de JDO GENIE
 *
 * @author fceballos
 *
 */
class JDOGenieFolioDAO implements FolioDAO, Serializable {

    private JDOGenieAuditoriaDAO auditoria = new JDOGenieAuditoriaDAO();
    private boolean tipoCambio;

    /**
     * Obtiene un objeto Folio dado su identificador
     *
     * @param oid identificador del Folio conformado por Nro matricula y
     * ZonaRegistral
     * @return Objeto Folio con sus objetos estado, complementacion, tipoPredio
     * y ZonaRegistral, y listas de salvedades folio, direcciones y anotaciones
     * con sus dependencias. El objeto ZonaRegistral contiene la jerarquía
     * circulo, vereda, municipio y departamento null si no encuentra un folio
     * que coincida con el identificador dado
     * @throws DAOException
     */
    public Folio loadFolioByID(FolioPk oid, Usuario usuario)
            throws DAOException {
        FolioEnhanced datos = null;
        Folio aux = null;
        PersistenceManager pm = AdministradorPM.getPM();

        try {
            datos = this.getFolioByID(new FolioEnhancedPk(oid), pm);

            if (datos == null) {
                throw new DAOException("El folio especificado no existe");
            }

            if (datos.isDefinitivo()) {
                throw new DAOException("El folio que está tratando de crear ya existe en el sistema.");
            }

            //Validar bloqueo del folio
            if (usuario != null) {
                this.validarBloqueoFolio(datos, usuario, pm);
            }

            //Una vez realizadas las validaciones se procede a obtener
            //la información del folio definitiva y temporal:
            this.makeTransientFolioTMP(datos, pm);
        } catch (DAOException e) {
            throw e;
        } catch (Exception e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e);
        } finally {
            pm.close();
        }

        aux = this.getMaskedFolio(datos);
        this.ordenarDirecciones(aux.getDirecciones());
        return aux;
    }

    /**
     * Constructor por defecto de JDOGenieDAO
     */
    public JDOGenieFolioDAO() {
    }

    /**
     * Retorna la validacion de la existencia de una matricula no grabada
     *
     * @param String circulo
     * @param long idMatricula
     * @return
     * @throws DAOException
     */
    public boolean matriculaNoGrabadaExistente(String circulo, long idMatricula)
            throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();

        try {
            MatriculaNoGrabadaEnhancedPk mid = new MatriculaNoGrabadaEnhancedPk();
            mid.idCirculo = circulo;
            mid.idMatNoGrabada = idMatricula;
            MatriculaNoGrabadaEnhanced mat = this.getMatriculaNoGrabada(mid, pm);
            if (mat == null) {
                return false;
            } else {
                return true;
            }
        } finally {
            pm.close();
        }
    }

    /**
     * Obtiene un objeto Folio dado su identificador
     *
     * @param oid identificador del Folio conformado por Nro matricula y
     * ZonaRegistral
     * @return Objeto Folio con sus objetos estado, complementacion, tipoPredio
     * y ZonaRegistral, y listas de salvedades folio, direcciones y anotaciones
     * con sus dependencias. El objeto ZonaRegistral contiene la jerarquía
     * circulo, vereda, municipio y departamento null si no encuentra un folio
     * que coincida con el identificador dado
     * @throws DAOException
     */
    public Folio getFolioByID(FolioPk oid) throws DAOException {
        FolioEnhanced rta = null;
        Folio aux = null;
        PersistenceManager pm = AdministradorPM.getPM();

        try {
            rta = this.getFolioByID(new FolioEnhancedPk(oid), pm);

            //Solo muestra la información del folio si éste
            //es definitivo
            if (rta != null) {
                if (rta.isDefinitivo()) {
                    this.makeTransientFolio(rta, pm);
                    //Revisar si el último estado tiene comentario para setearlo
                    if (!rta.getHistorialEstados().isEmpty()) {
                        EstadoHistoriaEnhanced ultimoEstado = (EstadoHistoriaEnhanced) rta.getHistorialEstados().get(rta.getHistorialEstados().size() - 1);
                        EstadoFolioEnhanced estado = rta.getEstado();
                        estado.setComentario(ultimoEstado.getComentario());
                    }
                } else {
                    rta = null;
                }
            }
        } catch (DAOException e) {
            throw e;
        } catch (Exception e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e);
        } finally {
            pm.close();
        }

        if (rta != null) {
            aux = (Folio) rta.toTransferObject();
            this.ordenarDirecciones(aux.getDirecciones());
        }

        return aux;
    }

    /**
     * Obtiene un objeto Folio dado su identificador (Devuelve folios temporales
     * y definitivos)
     *
     * @param oid identificador del Folio conformado por Nro matricula y
     * ZonaRegistral
     * @return Objeto Folio con sus objetos estado, complementacion, tipoPredio
     * y ZonaRegistral, y listas de salvedades folio, direcciones y anotaciones
     * con sus dependencias. El objeto ZonaRegistral contiene la jerarquía
     * circulo, vereda, municipio y departamento null si no encuentra un folio
     * que coincida con el identificador dado
     * @throws DAOException
     */
    public Folio getFolioByID(String matricula) throws DAOException {
        FolioEnhanced rta = null;
        Folio aux = null;
        PersistenceManager pm = AdministradorPM.getPM();

        try {
            FolioPk oid = new FolioPk();
            oid.idMatricula = matricula;
            rta = this.getFolioByID(new FolioEnhancedPk(oid), pm);
            if (rta != null) {
                this.makeTransientFolio(rta, pm);
            }
        } catch (DAOException e) {
            throw e;
        } catch (Exception e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e);
        } finally {
            pm.close();
        }

        if (rta != null) {
            aux = (Folio) rta.toTransferObject();
        }

        return aux;
    }

    /**
     * Obtiene un objeto Folio dado su identificador
     *
     * @param oid identificador del Folio conformado por Nro matricula y
     * ZonaRegistral
     * @return Objeto Folio con sus objetos estado, complementacion, tipoPredio
     * y ZonaRegistral, y listas de salvedades folio y direcciones. No se
     * incluyen las anotaciones El objeto ZonaRegistral contiene la jerarquía
     * circulo, vereda, municipio y departamento null si no encuentra un folio
     * que coincida con el identificador dado
     * @throws DAOException
     */
    public Folio getFolioByIDSinAnotaciones(FolioPk oid)
            throws DAOException {
        FolioEnhanced rta = null;
        Folio aux = null;
        PersistenceManager pm = AdministradorPM.getPM();

        try {
            rta = this.getFolioByID(new FolioEnhancedPk(oid), pm);

            if (rta != null) {
                //Solo muestra la información del folio si éste
                //es definitivo
                if (rta.isDefinitivo()) {
                    this.makeTransientFolioSinAnotaciones(rta, pm);
                    //Revisar si el último estado tiene comentario para setearlo
                    if (!rta.getHistorialEstados().isEmpty()) {
                        EstadoHistoriaEnhanced ultimoEstado = (EstadoHistoriaEnhanced) rta.getHistorialEstados().get(rta.getHistorialEstados().size() - 1);
                        EstadoFolioEnhanced estado = rta.getEstado();
                        estado.setComentario(ultimoEstado.getComentario());
                    }

                } else {
                    rta = null;
                }
            }
        } catch (DAOException e) {
            throw e;
        } catch (Exception e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e);
        } finally {
            pm.close();
        }

        if (rta != null) {
            aux = (Folio) rta.toTransferObject();
            this.ordenarDirecciones(aux.getDirecciones());
        }

        return aux;
    }

    /**
     * Obtiene un objeto Folio dado su identificador
     *
     * @param oid identificador del Folio conformado por Nro matricula y
     * ZonaRegistral
     * @return Objeto Folio con sus objetos estado, complementacion, tipoPredio
     * y ZonaRegistral, y listas de salvedades folio y direcciones. No se
     * incluyen las anotaciones El objeto ZonaRegistral contiene la jerarquía
     * circulo, vereda, municipio y departamento null si no encuentra un folio
     * que coincida con el identificador dado
     * @throws DAOException
     */
    public Folio getFolioEvenTempByIDSinAnotaciones(FolioPk oid)
            throws DAOException {
        FolioEnhanced rta = null;
        Folio aux = null;
        PersistenceManager pm = AdministradorPM.getPM();

        try {
            rta = this.getFolioByID(new FolioEnhancedPk(oid), pm);

            if (rta != null) {
                //Solo muestra la información del folio si éste
                //es definitivo

                this.makeTransientFolioSinAnotaciones(rta, pm);
                //Revisar si el último estado tiene comentario para setearlo
                if (!rta.getHistorialEstados().isEmpty()) {
                    EstadoHistoriaEnhanced ultimoEstado = (EstadoHistoriaEnhanced) rta.getHistorialEstados().get(rta.getHistorialEstados().size() - 1);
                    EstadoFolioEnhanced estado = rta.getEstado();
                    estado.setComentario(ultimoEstado.getComentario());
                }
            }
        } catch (DAOException e) {
            throw e;
        } catch (Exception e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e);
        } finally {
            pm.close();
        }

        if (rta != null) {
            aux = (Folio) rta.toTransferObject();
            this.ordenarDirecciones(aux.getDirecciones());
        }

        return aux;
    }

    /**
     * Obtiene un objeto Folio dado su identificador, el folio retornado es
     * transaccional, se debe dar el persistencemanager de la transacción activa
     *
     * @param oid identificador del Folio conformado por Nro matricula y
     * ZonaRegistral
     * @param pm PersistenceManager de la transaccion
     * @return Objeto Folio transaccional null si no encuentra un folio que
     * coincida con el identificador dado
     * @throws DAOException
     */
    protected FolioEnhanced getFolioByID(FolioEnhancedPk oid,
            PersistenceManager pm) throws DAOException {
        FolioEnhanced rta = null;

        if ((oid.idMatricula != null)) {
            try {
                rta = (FolioEnhanced) pm.getObjectById(oid, true);

                //Los folios en estado OBSOLETO no existen, están en la BD por auditoría
                if (rta.getEstado().getIdEstado().equals(CEstadoFolio.OBSOLETO)) {
                    rta = null;
                }
            } catch (JDOObjectNotFoundException e) {
                rta = null;
            } catch (JDOException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                throw new DAOException(e.getMessage(), e);
            }
        }

        return rta;
    }

    /**
     * Obtiene un objeto Folio dado el número de matrícula
     *
     * @param matricula número de matrícula del folio
     * @return Objeto Folio con sus objetos estado, complementacion, tipoPredio
     * y ZonaRegistral. El objeto ZonaRegistral contiene la jerarquía circulo,
     * vereda, municipio y departamento null si no encuentra un folio que
     * coincida con el identificador dado
     * @throws DAOException
     */
    public Folio getFolioByMatricula(String matricula)
            throws DAOException {
        FolioEnhanced rta = null;
        Folio aux = null;
        PersistenceManager pm = AdministradorPM.getPM();

        try {
            rta = this.getFolioByMatricula(matricula, pm);

            if (rta != null) {
                //Solo muestra la información del folio si éste
                //es definitivo
                if (rta.isDefinitivo()) {
                    this.makeTransientFolio(rta, pm);
                    //Revisar si el último estado tiene comentario para setearlo
                    if (!rta.getHistorialEstados().isEmpty()) {
                        EstadoHistoriaEnhanced ultimoEstado = (EstadoHistoriaEnhanced) rta.getHistorialEstados().get(rta.getHistorialEstados().size() - 1);
                        EstadoFolioEnhanced estado = rta.getEstado();
                        estado.setComentario(ultimoEstado.getComentario());
                    }

                } else {
                    rta = null;
                }
            }
        } catch (DAOException e) {
            throw e;
        } finally {
            pm.close();
        }

        if (rta != null) {
            aux = (Folio) rta.toTransferObject();
            this.ordenarDirecciones(aux.getDirecciones());
        }

        return aux;
    }

    /**
     * Obtiene un objeto Folio con toda su informacion, dado el número de
     * matrícula
     *
     * @param matricula número de matrícula del folio
     * @return Objeto Folio con sus objetos estado, complementacion, tipoPredio
     * y ZonaRegistral. El objeto ZonaRegistral contiene la jerarquía circulo,
     * vereda, municipio y departamento null si no encuentra un folio que
     * coincida con el identificador dado
     * @throws DAOException
     * @throws IOException
     */
    public ImprimibleCertificado getImprimibleCertificadoByMatricula(String idMatricula) throws DAOException, IOException {
        Folio folio = this.getFolioByMatricula(idMatricula);
        List anotacionesFolio = folio.getAnotaciones();

        if (anotacionesFolio == null || anotacionesFolio.isEmpty()) {
            FolioPk fpk = new FolioPk();
            fpk.idMatricula = idMatricula;
            anotacionesFolio = this.getAnotacionesFolio(fpk);
            folio.setAnotaciones(anotacionesFolio);
        }

        FolioPk fid = new FolioPk();
        fid.idMatricula = folio.getIdMatricula();

        // obtenemos los folios padres
        List padres = this.getFoliosPadre(fid);
        // obtenemos los folios hijos
        List hijos = this.getFolioHijosEnAnotacionesConDireccion(fid);
        /**
         * @author: David Panesso
         * @change: 1155.MODIFICAR.IMPRIMIBLE.CALIFICACION.CORRECCION Nuevo
         * listado de folios derivados
         *
         */
        List<FolioDerivado> foliosDerivadoHijos = this.getFoliosDerivadoHijos(fid);

        ImprimibleCertificado imprimible = new ImprimibleCertificado(folio, null, padres, hijos, foliosDerivadoHijos, null, null, null, null);

        return imprimible;
    }

    /**
     * Obtiene un objeto Folio dado su identificador
     *
     * @param matricula número de matrícula del folio
     * @return Objeto Folio con sus objetos estado, complementacion, tipoPredio
     * y ZonaRegistral, y listas de salvedades folio y direcciones. No se
     * incluyen las anotaciones El objeto ZonaRegistral contiene la jerarquía
     * circulo, vereda, municipio y departamento null si no encuentra un folio
     * que coincida con el identificador dado
     * @throws DAOException
     */
    public Folio getFolioByMatriculaSinAnotaciones(String matricula)
            throws DAOException {
        FolioEnhanced rta = null;
        Folio aux = null;
        PersistenceManager pm = AdministradorPM.getPM();

        try {
            rta = this.getFolioByMatricula(matricula, pm);

            if (rta != null) {
                //Solo muestra la información del folio si éste
                //es definitivo
                if (rta.isDefinitivo()) {
                    this.makeTransientFolioSinAnotaciones(rta, pm);
                    //Revisar si el último estado tiene comentario para setearlo
                    if (!rta.getHistorialEstados().isEmpty()) {
                        EstadoHistoriaEnhanced ultimoEstado = (EstadoHistoriaEnhanced) rta.getHistorialEstados().get(rta.getHistorialEstados().size() - 1);
                        EstadoFolioEnhanced estado = rta.getEstado();
                        estado.setComentario(ultimoEstado.getComentario());
                    }
                } else {
                    rta = null;
                }
            }
        } catch (DAOException e) {
            throw e;
        } finally {
            pm.close();
        }

        if (rta != null) {
            aux = (Folio) rta.toTransferObject();
            this.ordenarDirecciones(aux.getDirecciones());
        }

        return aux;
    }

    /**
     * Obtiene un objeto Folio dado el número de matrícula
     *
     * @param matricula número de matrícula del folio
     * @return Objeto Folio con sus objetos estado, complementacion, tipoPredio
     * y ZonaRegistral. El objeto ZonaRegistral contiene la jerarquía circulo,
     * vereda, municipio y departamento null si no encuentra un folio que
     * coincida con el identificador dado
     * @throws DAOException
     */
    protected FolioEnhanced getFolioByMatricula(String matricula,
            PersistenceManager pm) throws DAOException {
        FolioEnhanced rta = null;

        try {
            Query query = pm.newQuery(FolioEnhanced.class);
            query.declareParameters("String matricula");
            query.setFilter("idMatricula == matricula");

            Collection col = (Collection) query.execute(matricula);

            Iterator iter = col.iterator();

            if (!iter.hasNext()) {
                rta = null;
            } else {
                rta = (FolioEnhanced) iter.next();

                //Los folios en estado OBSOLETO no existen, están en la BD por auditoría
                if (rta.getEstado().getIdEstado().equals(CEstadoFolio.OBSOLETO)) {
                    rta = null;
                }

                query.closeAll();
            }
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }

        return rta;
    }

    /**
     * Obtiene un folios por su matrícula, incluyte en la búsqueda los folios
     * que se han trasladado, es decir, en estado obsoleto
     *
     * @param matricula
     * @param pm
     * @return
     * @throws DAOException
     */
    protected FolioEnhanced getFolioByMatriculaIncluyendoObsoletos(
            String matricula, PersistenceManager pm) throws DAOException {
        FolioEnhanced rta = null;

        try {
            Query query = pm.newQuery(FolioEnhanced.class);
            query.declareParameters("String matricula");
            query.setFilter("idMatricula == matricula");

            Collection col = (Collection) query.execute(matricula);

            Iterator iter = col.iterator();

            if (!iter.hasNext()) {
                rta = null;
            } else {
                rta = (FolioEnhanced) iter.next();
                query.closeAll();
            }
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }

        return rta;
    }

    /**
     * Obtiene una lista con las anotaciones del folio especificado por su ID
     *
     * @param oid identificador del Folio conformado por Nro matricula y
     * ZonaRegistral
     * @return lista con las anotaciones del folio, cada anotación contiene los
     * objetos tipoAnotacion, naturalezaJuridica y estado
     * @see gov.sir.core.negocio.modelo.Anotacion
     * @throws DAOException
     */
    public List getAnotacionesFolio(FolioPk oid) throws DAOException {
        FolioEnhanced fol = null;
        AnotacionEnhanced anota = null;
        PersistenceManager pm = AdministradorPM.getPM();
        List rta = new ArrayList();

        try {
            fol = this.getFolioByID(new FolioEnhancedPk(oid), pm);

            if (fol == null) {
                throw new DAOException("El folio no existe. IdMatricula: "
                        + oid.idMatricula);
            }

            if (!fol.isDefinitivo()) {
                throw new DAOException(
                        "El folio se encuentra en estado temporal");
            }
            /**
             * @autor: Carlos Torres
             * @mantis: 0011599
             * @cambio: se hace una copia del arreglo de las anotaciones
             */

            rta = this.getAnotacionesRealesFolio(fol, pm);

            //List rta2 = fol.getAnotaciones();
//            for (Iterator itr = rta2.iterator(); itr.hasNext();) {
//                anota = (AnotacionEnhanced) itr.next();
//                this.makeTransientAnotacion(anota, pm, new ArrayList());
//                rta.add(anota);
//            }
            //pm.makeTransientAll(rta);
        } catch (JDOObjectNotFoundException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        rta = TransferUtils.makeTransferAll(rta);

        return rta;
    }

    /**
     * Obtiene las anotaciones para un turno asi sea temporal
     *
     * @param oid
     * @return
     * @throws DAOException
     */
    public List getAnotacionesFolioTMP(FolioPk oid) throws DAOException {
        FolioEnhanced fol = null;
        AnotacionEnhanced anotacionEnh = null;
        PersistenceManager pm = AdministradorPM.getPM();
        List listaAnotaciones = new ArrayList();
        List listaTMPAnotaciones = new ArrayList();

        try {
            fol = this.getFolioByID(new FolioEnhancedPk(oid), pm);

            if (fol == null) {
                throw new DAOException("El folio no existe. IdMatricula: "
                        + oid.idMatricula);
            }
            /**
             * @autor: Carlos Torres
             * @mantis: 0011599
             * @cambio: se hace una copia del arreglo de las anotaciones
             */

            listaTMPAnotaciones = this.getAnotacionesRealesFolio(fol, pm);

            //List rta2 = fol.getAnotaciones();
//            for (Iterator itr = rta2.iterator(); itr.hasNext();) {
//            	anotacionEnh = (AnotacionEnhanced) itr.next();
//                this.makeTransientAnotacion(anotacionEnh, pm, new ArrayList());
//                listaTMPAnotaciones.add(anotacionEnh);
//            }
//
//        	for (Iterator itr = fol.getAnotacionesTMPs().iterator();
//	                itr.hasNext();) {
//	            this.makeTransientAnotacionTMP((AnotacionTMP) itr.next(),
//	                pm, new ArrayList());
//	        }
            pm.makeTransient(fol);
            /**
             *
             */
            //Se agregan las anotaciones temporales y definitivas a la lista
            // En caso de que sea una actualizacion de una anotacion definitiva
            // se modifica
            fol.setAnotaciones(listaTMPAnotaciones);
            List anotacionesTMP = fol.getAnotacionesTMPs();
            Folio rta = (Folio) fol.toTransferObject();

            if (anotacionesTMP != null) {
                AnotacionTMP anota;
                List cache;
                Anotacion anotaAux;

                for (Iterator it = anotacionesTMP.iterator(); it.hasNext();) {
                    anota = (AnotacionTMP) it.next();
                    cache = new ArrayList();
                    anotaAux = (Anotacion) anota.getDefinitivo(cache).toTransferObject();

                    int indice;
                    Anotacion anToUpdate;
                    indice = rta.getAnotaciones().indexOf(anotaAux);

                    if (indice != -1) {
                        //La anotacion temporal representa una actualización a la anotación
                        //definitiva
                        anToUpdate = (Anotacion) rta.getAnotaciones().get(indice);

                        anToUpdate.setTemporal(true);
                        // anToUpdate.setTemporalConContraparteDefinitiva( true );

                        if (anotaAux.getEstado() != null) {
                            anToUpdate.setEstado(anotaAux.getEstado());
                        }

                        if (anotaAux.getNaturalezaJuridica() != null) {
                            anToUpdate.setNaturalezaJuridica(anotaAux.getNaturalezaJuridica());
                        }

                        if (anotaAux.getTipoAnotacion() != null) {
                            anToUpdate.setTipoAnotacion(anotaAux.getTipoAnotacion());
                        }

                        if (anotaAux.getOrden() != null) {
                            anToUpdate.setOrden(anotaAux.getOrden());
                            anToUpdate.setOrdenLPAD(anotaAux.getOrdenLPAD());
                            reinsertarAnotacionEnOrden(rta, indice);
                        }

                        if (anotaAux.getEspecificacion() != null) {
                            anToUpdate.setEspecificacion(anotaAux.getEspecificacion());
                        }

                        if (anotaAux.getComentario() != null) {
                            anToUpdate.setComentario(anotaAux.getComentario());
                        }

                        if (anotaAux.getValor() != anToUpdate.getValor()) {
                            anToUpdate.setValor(anotaAux.getValor());
                        }

                        if (anotaAux.getFechaRadicacion() != null) {
                            anToUpdate.setFechaRadicacion(anotaAux.getFechaRadicacion());
                        }

                        if (anotaAux.getNumRadicacion() != null) {
                            anToUpdate.setNumRadicacion(anotaAux.getNumRadicacion());
                        }

                        //Se setea el documento si existe uno temporal
                        if (anota.getDocumentoTMP() != null) {
                            anToUpdate.setDocumento((Documento) anota.getDocumentoTMP().getDefinitivo()
                                    .toTransferObject());
                        }

                        //Miramos los ciudadanos de la anotacion que se deben,
                        //insertar o borrar
                        AnotacionCiudadano anCiudAux;

                        for (Iterator it2 = anotaAux.getAnotacionesCiudadanos()
                                .iterator(); it2.hasNext();) {
                            anCiudAux = (AnotacionCiudadano) it2.next();

                            if (anToUpdate.getAnotacionesCiudadanos().contains(anCiudAux)) {
                                //Se debe actualizar o borrar el ciudadano del objeto
                                if (anCiudAux.isToDelete()) {
                                    anToUpdate.removeAnotacionesCiudadano(anCiudAux);
                                }
                            } else {
                                //Se debe agregar el ciudadano
                                anToUpdate.addAnotacionesCiudadano(anCiudAux);
                            }
                        }

                        //Miramos las salvedades de la anotacion que se deben,
                        //insertar o borrar
                        SalvedadAnotacion salAux;

                        for (Iterator it3 = anotaAux.getSalvedades().iterator();
                                it3.hasNext();) {
                            salAux = (SalvedadAnotacion) it3.next();

                            if (anToUpdate.getSalvedades().contains(salAux)) {
                                //Se debe actualizar o borrar el ciudadano del objeto
                                if (salAux.isToDelete()) {
                                    anToUpdate.removeSalvedade(salAux);
                                } else {
                                    if (salAux.getDescripcion() != null) {
                                        int ind = anToUpdate.getSalvedades().indexOf(salAux);
                                        SalvedadAnotacion salToUpdate = (SalvedadAnotacion) anToUpdate.getSalvedades()
                                                .get(ind);
                                        salToUpdate.setDescripcion(salAux.getDescripcion());
                                    }
                                }
                            } else {
                                //Se debe agregar la salvedad
                                anToUpdate.addSalvedade(salAux);
                            }
                        }

                        //Miramos las cancelaciones de la anotacion que se deben,
                        //insertar o borrar
                        Cancelacion anCancelAux;

                        for (Iterator it2 = anotaAux.getAnotacionesCancelacions().iterator();
                                it2.hasNext();) {
                            anCancelAux = (Cancelacion) it2.next();

                            if (anToUpdate.getAnotacionesCancelacions().contains(anCancelAux)) {
                                //Se debe actualizar o borrar la cancelacion
                                if (anCancelAux.isToDelete()) {
                                    anToUpdate.removeAnotacionesCancelacion(anCancelAux);
                                }
                            } else {
                                //Se debe agregar el ciudadano
                                anToUpdate.addAnotacionesCancelacion(anCancelAux);
                            }
                        }

                    } else {
                        //*if (!anotaAux.getEstado().getIdEstadoAn().equals(CEstadoAnotacion.OBSOLETA)) {
                        anotaAux.setTemporal(true);
                        rta.addAnotacione(anotaAux);
                        //*}
                    }
                }
            }
            /**
             * Pasar las anotaciones a una lista
             */
            for (Iterator iter = rta.getAnotaciones().iterator(); iter.hasNext();) {
                Anotacion anotacion = (Anotacion) iter.next();
                listaAnotaciones.add(AnotacionEnhanced.enhance(anotacion));
            }
            /**
             *
             */

            //pm.makeTransientAll(rta);
        } catch (JDOObjectNotFoundException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        listaAnotaciones = TransferUtils.makeTransferAll(listaAnotaciones);

        return listaAnotaciones;
    }

    /**
     * Obtiene las anotaciones con los folios Derivados Padres e hijos para un
     * turno asi sea temporal
     *
     * @param oid
     * @return
     * @throws DAOException
     */
    @Override
    public List getAnotacionesFolioTMPFD(FolioPk oid) throws DAOException {
        FolioEnhanced fol = null;
        AnotacionEnhanced anotacionEnh = null;
        PersistenceManager pm = AdministradorPM.getPM();
        List listaAnotaciones = new ArrayList();
        List listaTMPAnotaciones = new ArrayList();

        try {
            fol = this.getFolioByID(new FolioEnhancedPk(oid), pm);

            if (fol == null) {
                throw new DAOException("El folio no existe. IdMatricula: "
                        + oid.idMatricula);
            }
            /**
             * @autor: Carlos Torres
             * @mantis: 0011599
             * @cambio: se hace una copia del arreglo de las anotaciones
             */
            listaTMPAnotaciones = this.getAnotacionesRealesFolio(fol, pm);

            //List rta2 = fol.getAnotaciones();
//            for (Iterator itr = rta2.iterator(); itr.hasNext();) {
//            	anotacionEnh = (AnotacionEnhanced) itr.next();
//                this.makeTransientAnotacion(anotacionEnh, pm, new ArrayList());
//                listaTMPAnotaciones.add(anotacionEnh);
//            }
//
//        	for (Iterator itr = fol.getAnotacionesTMPs().iterator();
//	                itr.hasNext();) {
//	            this.makeTransientAnotacionTMP((AnotacionTMP) itr.next(),
//	                pm, new ArrayList());
//	        }
            pm.makeTransient(fol);
            /**
             *
             */
            //Se agregan las anotaciones temporales y definitivas a la lista
            // En caso de que sea una actualizacion de una anotacion definitiva
            // se modifica
            fol.setAnotaciones(listaTMPAnotaciones);
            List anotacionesTMP = fol.getAnotacionesTMPs();
            Folio rta = (Folio) fol.toTransferObject();

            if (anotacionesTMP != null) {
                AnotacionTMP anota;
                List cache;
                Anotacion anotaAux;

                for (Iterator it = anotacionesTMP.iterator(); it.hasNext();) {
                    anota = (AnotacionTMP) it.next();
                    cache = new ArrayList();
                    anotaAux = (Anotacion) anota.getDefinitivoFD(cache).toTransferObject();

                    int indice;
                    Anotacion anToUpdate;
                    indice = rta.getAnotaciones().indexOf(anotaAux);

                    if (indice != -1) {
                        //La anotacion temporal representa una actualización a la anotación
                        //definitiva
                        anToUpdate = (Anotacion) rta.getAnotaciones().get(indice);

                        anToUpdate.setTemporal(true);
                        // anToUpdate.setTemporalConContraparteDefinitiva( true );

                        if (anotaAux.getEstado() != null) {
                            anToUpdate.setEstado(anotaAux.getEstado());
                        }

                        if (anotaAux.getNaturalezaJuridica() != null) {
                            anToUpdate.setNaturalezaJuridica(anotaAux.getNaturalezaJuridica());
                        }

                        if (anotaAux.getTipoAnotacion() != null) {
                            anToUpdate.setTipoAnotacion(anotaAux.getTipoAnotacion());
                        }

                        if (anotaAux.getOrden() != null) {
                            anToUpdate.setOrden(anotaAux.getOrden());
                            anToUpdate.setOrdenLPAD(anotaAux.getOrdenLPAD());
                            reinsertarAnotacionEnOrden(rta, indice);
                        }

                        if (anotaAux.getEspecificacion() != null) {
                            anToUpdate.setEspecificacion(anotaAux.getEspecificacion());
                        }

                        if (anotaAux.getComentario() != null) {
                            anToUpdate.setComentario(anotaAux.getComentario());
                        }

                        if (anotaAux.getValor() != anToUpdate.getValor()) {
                            anToUpdate.setValor(anotaAux.getValor());
                        }

                        if (anotaAux.getFechaRadicacion() != null) {
                            anToUpdate.setFechaRadicacion(anotaAux.getFechaRadicacion());
                        }

                        if (anotaAux.getNumRadicacion() != null) {
                            anToUpdate.setNumRadicacion(anotaAux.getNumRadicacion());
                        }

                        //Se setea el documento si existe uno temporal
                        if (anota.getDocumentoTMP() != null) {
                            anToUpdate.setDocumento((Documento) anota.getDocumentoTMP().getDefinitivo()
                                    .toTransferObject());
                        }

                        //Miramos los ciudadanos de la anotacion que se deben,
                        //insertar o borrar
                        AnotacionCiudadano anCiudAux;

                        for (Iterator it2 = anotaAux.getAnotacionesCiudadanos()
                                .iterator(); it2.hasNext();) {
                            anCiudAux = (AnotacionCiudadano) it2.next();

                            if (anToUpdate.getAnotacionesCiudadanos().contains(anCiudAux)) {
                                //Se debe actualizar o borrar el ciudadano del objeto
                                if (anCiudAux.isToDelete()) {
                                    anToUpdate.removeAnotacionesCiudadano(anCiudAux);
                                }
                            } else {
                                //Se debe agregar el ciudadano
                                anToUpdate.addAnotacionesCiudadano(anCiudAux);
                            }
                        }

                        //Miramos las salvedades de la anotacion que se deben,
                        //insertar o borrar
                        SalvedadAnotacion salAux;

                        for (Iterator it3 = anotaAux.getSalvedades().iterator();
                                it3.hasNext();) {
                            salAux = (SalvedadAnotacion) it3.next();

                            if (anToUpdate.getSalvedades().contains(salAux)) {
                                //Se debe actualizar o borrar el ciudadano del objeto
                                if (salAux.isToDelete()) {
                                    anToUpdate.removeSalvedade(salAux);
                                } else {
                                    if (salAux.getDescripcion() != null) {
                                        int ind = anToUpdate.getSalvedades().indexOf(salAux);
                                        SalvedadAnotacion salToUpdate = (SalvedadAnotacion) anToUpdate.getSalvedades()
                                                .get(ind);
                                        salToUpdate.setDescripcion(salAux.getDescripcion());
                                    }
                                }
                            } else {
                                //Se debe agregar la salvedad
                                anToUpdate.addSalvedade(salAux);
                            }
                        }

                        //Miramos las cancelaciones de la anotacion que se deben,
                        //insertar o borrar
                        Cancelacion anCancelAux;

                        for (Iterator it2 = anotaAux.getAnotacionesCancelacions().iterator();
                                it2.hasNext();) {
                            anCancelAux = (Cancelacion) it2.next();

                            if (anToUpdate.getAnotacionesCancelacions().contains(anCancelAux)) {
                                //Se debe actualizar o borrar la cancelacion
                                if (anCancelAux.isToDelete()) {
                                    anToUpdate.removeAnotacionesCancelacion(anCancelAux);
                                }
                            } else {
                                //Se debe agregar el ciudadano
                                anToUpdate.addAnotacionesCancelacion(anCancelAux);
                            }
                        }

                    } else {
                        //*if (!anotaAux.getEstado().getIdEstadoAn().equals(CEstadoAnotacion.OBSOLETA)) {
                        anotaAux.setTemporal(true);
                        rta.addAnotacione(anotaAux);
                        //*}
                    }
                }
            }
            /**
             * Pasar las anotaciones a una lista
             */
            for (Iterator iter = rta.getAnotaciones().iterator(); iter.hasNext();) {
                Anotacion anotacion = (Anotacion) iter.next();
                listaAnotaciones.add(AnotacionEnhanced.enhance(anotacion));
            }
            /**
             *
             */

            //pm.makeTransientAll(rta);
        } catch (JDOObjectNotFoundException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        listaAnotaciones = TransferUtils.makeTransferAll(listaAnotaciones);

        return listaAnotaciones;
    }

    /**
     * obtiene el numero de anotaciones temporales de un folio Obtiene
     *
     * @param oid
     * @return
     * @throws DAOException
     */
    @Override
    public int getAnotacionesFolioTMPCount(FolioPk oid) throws DAOException {
        FolioEnhanced fol = null;
        AnotacionEnhanced anotacionEnh = null;
        PersistenceManager pm = AdministradorPM.getPM();
        List listaAnotaciones = new ArrayList();
        List listaTMPAnotaciones = new ArrayList();

        int numAnota = 0;

        try {
            fol = this.getFolioByID(new FolioEnhancedPk(oid), pm);

            if (fol == null) {
                throw new DAOException("El folio no existe. IdMatricula: "
                        + oid.idMatricula);
            }
            /**
             * @autor: Carlos Torres
             * @mantis: 0011599
             * @cambio: se hace una copia del arreglo de las anotaciones
             */

            listaTMPAnotaciones = this.getAnotacionesRealesFolio(fol, pm);

            //List rta2 = fol.getAnotaciones();
//            for (Iterator itr = rta2.iterator(); itr.hasNext();) {
//            	anotacionEnh = (AnotacionEnhanced) itr.next();
//                this.makeTransientAnotacion(anotacionEnh, pm, new ArrayList());
//                listaTMPAnotaciones.add(anotacionEnh);
//            }
//
//        	for (Iterator itr = fol.getAnotacionesTMPs().iterator();
//	                itr.hasNext();) {
//	            this.makeTransientAnotacionTMP((AnotacionTMP) itr.next(),
//	                pm, new ArrayList());
//	        }
            pm.makeTransient(fol);
            /**
             *
             */
            //Se agregan las anotaciones temporales y definitivas a la lista
            // En caso de que sea una actualizacion de una anotacion definitiva
            // se modifica
            fol.setAnotaciones(listaTMPAnotaciones);
            List anotacionesTMP = fol.getAnotacionesTMPs();
            Folio rta = (Folio) fol.toTransferObject();

            if (anotacionesTMP != null && anotacionesTMP.size() > 0) {
                numAnota = anotacionesTMP.size();
            }

        } catch (JDOObjectNotFoundException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        return numAnota;
    }

    /**
     * Obtiene una lista con las anotaciones del folio especificado por su ID
     *
     * @param oid identificador del Folio conformado por Nro matricula y
     * ZonaRegistral
     * @return lista con las anotaciones del folio, cada anotación contiene los
     * objetos tipoAnotacion, naturalezaJuridica y estado
     * @see gov.sir.core.negocio.modelo.Anotacion
     * @throws DAOException
     */
    protected List getAnotacionesRealesFolio(FolioEnhanced fol,
            PersistenceManager pm) throws DAOException {
        List rta = null;
        ArrayList anotaciones = new ArrayList();
        AnotacionEnhanced anotacionEnh = null;

        try {
            if (fol != null) {
                Query query = pm.newQuery(AnotacionEnhanced.class);
                query.declareParameters("FolioEnhanced fol");
                query.setFilter("this.folio==fol && (this.link==null || this.link==false) ");
                //*query.setFilter("this.folio==fol && this.estado.idEstadoAn!='" +
                //*        CEstadoAnotacion.OBSOLETA + "' && (this.link==null || this.link==false) ");
                query.setOrdering("ordenLPAD ascending");
                rta = (List) query.execute(fol);

                /**
                 * @autor: Carlos Torres
                 * @mantis: 0011599
                 * @cambio: se hace una copia del arreglo de las anotaciones
                 */
                for (Iterator itr = rta.iterator(); itr.hasNext();) {
                    anotacionEnh = (AnotacionEnhanced) itr.next();
                    this.makeTransientAnotacion(anotacionEnh, pm, new ArrayList());
                    anotaciones.add(anotacionEnh);
                }

                for (Iterator itr = fol.getAnotacionesTMPs().iterator();
                        itr.hasNext();) {
                    this.makeTransientAnotacionTMP((AnotacionTMP) itr.next(),
                            pm, new ArrayList());
                }
                /**
                 * @autor:Edgar Lora
                 * @mantis: 0011599
                 * @cambio: se hace una copia del arreglo de las anotaciones, se
                 * ordena segun lo requerido y se imprime en ese nuevo orden.
                 */
//                anotaciones = new ArrayList();
//                for(int i = 0; i < rta.size(); i = i + 1){
//                        AnotacionEnhanced anotacion = (AnotacionEnhanced)rta.get(i);
//                        anotaciones.add(anotacion);
//                }
                Collections.sort(anotaciones, new ComparadorAnotacionImprimible());
            }
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }

        /**
         * @autor:Edgar Lora
         * @mantis: 0011599
         * @requerimiento: 085_151
         */
        return anotaciones;
    }

    /**
     * Retorna las anotaciones de un folio con el criterio dado. Se puede
     * especificar la posición inicial y el número de anotaciones que se quieren
     * obtener a partir de dicha posición.
     *
     * @param oid
     * @param criterio
     * @param valor
     * @param posicionInicial
     * @param cantidad
     * @return
     * @throws DAOException
     */
    @Override
    public List getAnotacionesFolio(FolioPk oid, String criterio,
            String valor, int posicionInicial, int cantidad, boolean vigente)
            throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        List rta = new ArrayList();
        List res = new ArrayList();
        AnotacionEnhanced anota;

        try {
            FolioEnhanced fol = this.getFolioByID(new FolioEnhancedPk(oid), pm);

            if (fol == null) {
                throw new DAOException(
                        "El folio especificado no existe. Matricula: "
                        + oid.idMatricula);
            }

            if (!fol.isDefinitivo()) {
                throw new DAOException(
                        "El folio se encuentra en estado temporal");
            }

            if (criterio == null) {
                throw new DAOException("Se debe especificar un criterio");
            }

            //Se debe buscar por algún criterio las anotaciones
            pm.currentTransaction().begin();

            VersantQuery query = (VersantQuery) pm.newQuery(AnotacionEnhanced.class);
            query.declareParameters("String parametro, FolioEnhanced fol");
            query.setRandomAccess(true);
            query.setOrdering("ordenLPAD ascending");

            if (vigente) {
                query.declareVariables("CancelacionEnhanced cancel");
            }

            String filtro = "this.folio==fol && (this.link==null || this.link==false) ";

            //*String filtro = "this.folio==fol && this.estado.idEstadoAn!='" +
            //*CEstadoAnotacion.OBSOLETA + "' && (this.link==null || this.link==false) ";
            if (criterio.equals(CCriterio.POR_NAT_JURIDICA)) {
                filtro = filtro
                        + " && this.naturalezaJuridica.idNaturalezaJuridica==parametro";
            } else if (criterio.equals(CCriterio.POR_GRUPO_NAT_JURIDICA)) {
                filtro = filtro
                        + " && this.naturalezaJuridica.grupoNaturalezaJuridica.idGrupoNatJuridica==parametro";
            } else if (criterio.equals(CCriterio.POR_ID_ANOTACION)) {
                filtro = filtro + " && this.idAnotacion==parametro";
            } else if (criterio.equals(CCriterio.POR_ORDEN)) {
                filtro = filtro + " && this.orden==parametro";
            } else if (criterio.equals(CCriterio.POR_TIPO_ANOTACION)) {
                filtro = filtro
                        + " && this.tipoAnotacion.idTipoAnotacion==parametro";
            } else if (!criterio.equals(CCriterio.TODAS_LAS_ANOTACIONES)) {
                throw new DAOException("Criterio invalido: " + criterio);
            }

            if (vigente) {
                filtro = filtro + " && !(cancel.cancelada==this)";
            }

            query.setFilter(filtro);
            res = (List) query.execute(valor, fol);

            for (int i = posicionInicial; i < (posicionInicial + cantidad);
                    i++) {
                try {
                    anota = (AnotacionEnhanced) res.get(i);

                    AnotacionEnhanced anotaPersistente2 = this.getAnotacionByID((AnotacionEnhancedPk) pm.getObjectId(anota), pm);
                    this.makeTransientAnotacion(anotaPersistente2, pm, new ArrayList());
                    rta.add(anotaPersistente2);
                    //OJO CON EL makeTransient 
                    //En últimas ponga a leer una anotacion persistente y la hace transiente.
                    //Así esa anotación no estará contaminada de listas random
                    //No olvide Hacer lo mismo en el método que recibe el usuario en la parte de 
                    //anotaciones definitivas y anotaciones temporales.
                    //this.makeTransientAnotacion(anota, pm, new ArrayList());
                    //rta.add(anota);
                } catch (NoSuchElementException ns) {
                    break;
                } catch (ArrayIndexOutOfBoundsException ns) {
                    break;
                }
            }
        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (DAOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw e;
        } catch (Exception e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().commit();
            }

            pm.close();
        }
        /**
         * @autor:Edgar Lora
         * @mantis: 0011599
         * @requerimiento: 085_151
         */
        List result = TransferUtils.makeTransferAll(rta);
        Collections.sort(result, new ComparadorAnotaciones());
        return result;
    }

    /**
     * @author : Ellery David Robles G.
     * @author : Angelica Herreño Gomez
     * @casoMantis : 08469.
     * @actaReq : 024_151 - Error en anotación de medida cautelar.
     * @change : Retorna las anotaciones definitivas y temporales de un folio
     * segun el parametro naturaleza jurudica.
     * @param : oid.
     * @param : naturalezaJuridica.
     * @throws : DAOException.
     */
    @Override
    public List getAnotacionesFolioNJ(FolioPk oid, String naturalezaJuridica) throws DAOException {
        FolioEnhanced fol = null;
        AnotacionEnhanced anotacionEnh = null;
        PersistenceManager pm = AdministradorPM.getPM();
        List listaAnotaciones = new ArrayList();
        List listaTMPAnotaciones = new ArrayList();

        try {
            fol = this.getFolioByID(new FolioEnhancedPk(oid), pm);

            if (fol == null) {
                throw new DAOException("El folio no existe. IdMatricula: " + oid.idMatricula);
            }
            /**
             * @autor: Carlos Torres
             * @mantis: 0011599
             * @cambio: se hace una copia del arreglo de las anotaciones y se
             * comenta codigo que ya se implemento en el metodo
             */

            listaTMPAnotaciones = this.getAnotacionesRealesFolio(fol, pm);

            //List rta2 = fol.getAnotaciones();
//            for (Iterator itr = rta2.iterator(); itr.hasNext();) {
//            	anotacionEnh = (AnotacionEnhanced) itr.next();
//                this.makeTransientAnotacion(anotacionEnh, pm, new ArrayList());
//                listaTMPAnotaciones.add(anotacionEnh);
//            }
//
//        	for (Iterator itr = fol.getAnotacionesTMPs().iterator();
//	                itr.hasNext();) {
//	            this.makeTransientAnotacionTMP((AnotacionTMP) itr.next(),
//	                pm, new ArrayList());
//	        }
            pm.makeTransient(fol);

            // Se agregan las anotaciones temporales y definitivas a la lista
            // En caso de que sea una actualizacion de una anotacion definitiva
            // se modifica
            fol.setAnotaciones(listaTMPAnotaciones);
            List anotacionesTMP = fol.getAnotacionesTMPs();
            Folio rta = (Folio) fol.toTransferObject();

            if (anotacionesTMP != null) {
                AnotacionTMP anota;
                List cache;
                Anotacion anotaAux;

                for (Iterator it = anotacionesTMP.iterator(); it.hasNext();) {
                    anota = (AnotacionTMP) it.next();
                    cache = new ArrayList();
                    anotaAux = (Anotacion) anota.getDefinitivo(cache).toTransferObject();

                    int indice;
                    Anotacion anToUpdate;
                    indice = rta.getAnotaciones().indexOf(anotaAux);

                    if (indice != -1) {
                        //La anotacion temporal representa una actualización a la anotación definitiva
                        anToUpdate = (Anotacion) rta.getAnotaciones().get(indice);
                        anToUpdate.setTemporal(true);

                        if (anotaAux.getNaturalezaJuridica() != null) {
                            anToUpdate.setNaturalezaJuridica(anotaAux.getNaturalezaJuridica());
                        }
                    } else {
                        anotaAux.setTemporal(true);
                        rta.addAnotacione(anotaAux);
                    }
                }
            }
            //Pasar las anotaciones a una lista
            for (Iterator iter = rta.getAnotaciones().iterator(); iter.hasNext();) {
                Anotacion anotacion = (Anotacion) iter.next();
                Boolean validAnotaC = false;
                if (anotacion.getNaturalezaJuridica().getGrupoNaturalezaJuridica().getIdGrupoNatJuridica().substring(0, 2).equals(naturalezaJuridica.substring(0, 2))) {
                    EstadoAnotacion estadoAnot = anotacion.getEstado();
                    if (estadoAnot.getIdEstadoAn().equals("V")) {
                        /*ANOTACIONES TEMPORALES*/
                        for (Iterator iterAC = anotacionesTMP.iterator(); iterAC.hasNext();) {
                            AnotacionTMP anotCanc = null;
                            anotCanc = (AnotacionTMP) iterAC.next();

                            //Anotaciones Temporales Canceladoras
                            if (anotCanc != null) {
                                if (anotCanc.getAnotacionesCancelacionTMPs().size() > 0) {
                                    if (anotCanc.getEstado().getIdEstadoAn().equals("V")) {
                                        List anotCanceladoras = anotCanc.getAnotacionesCancelacionTMPs();
                                        for (Iterator its = anotCanceladoras.iterator(); its.hasNext();) {
                                            CancelacionTMP anotCanceladora = (CancelacionTMP) its.next();
                                            /*Anotacion Definitiva*/
                                            if (anotCanceladora.getCanceladaDef() != null) {
                                                if (anotCanceladora.getCanceladaDef().getIdAnotacion().equals(anotacion.getIdAnotacion())) {
                                                    validAnotaC = true;
                                                }
                                            }
                                            /*Anotacion Temporal*/
                                            if (anotCanceladora.getCanceladaTmp() != null) {
                                                if (anotCanceladora.getCanceladaTmp().getIdAnotacionTmp().equals(anotacion.getIdAnotacion())) {
                                                    validAnotaC = true;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        /*ANOTACIONES DEFINITIVAS*/
                        for (Iterator iterAC = rta.getAnotaciones().iterator(); iterAC.hasNext();) {
                            Anotacion anotCanc = null;
                            anotCanc = (Anotacion) iterAC.next();

                            //Anotaciones Definitivas Canceladoras
                            if (anotCanc != null) {
                                if (anotCanc.getAnotacionesCancelacions().size() > 0) {
                                    if (anotCanc.getEstado().getIdEstadoAn().equals("V")) {
                                        List anotCanceladoras = anotCanc.getAnotacionesCancelacions();
                                        for (Iterator its = anotCanceladoras.iterator(); its.hasNext();) {
                                            Cancelacion anotCanceladora = (Cancelacion) its.next();
                                            /*Anotacion Definitiva*/
                                            if (anotCanceladora.getCancelada() != null) {
                                                if (anotCanceladora.getIdAnotacion1().equals(anotacion.getIdAnotacion())) {
                                                    validAnotaC = true;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        if (!validAnotaC) {
                            listaAnotaciones.add(AnotacionEnhanced.enhance(anotacion));
                        }
                    }
                }
            }
        } catch (JDOObjectNotFoundException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        listaAnotaciones = TransferUtils.makeTransferAll(listaAnotaciones);

        return listaAnotaciones;
    }

    /**
     * Devuelve el número de anotaciones del folio indicado, si el folio no
     * existe retorna 0
     *
     * @param matricula
     * @return
     * @throws DAOException
     */
    public long getCountAnotacionesFolio(String matricula)
            throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        long rta = 0;

        try {
            pm.currentTransaction().begin();

            FolioEnhanced fol = this.getFolioByMatricula(matricula, pm);

            if (fol != null) {
                //Se debe buscar por algún criterio las anotaciones
                VersantQuery query = (VersantQuery) pm.newQuery(AnotacionEnhanced.class);
                query.declareParameters("String matricula");

                String filtro = "this.idMatricula==matricula && (this.link==null || this.link==false)";

                //*"this.idMatricula==matricula && this.estado.idEstadoAn!='" +
                //*CEstadoAnotacion.OBSOLETA + "' && (this.link==null || this.link==false)";
                query.setFilter(filtro);
                query.setResult("count(this)");
                rta = ((Long) query.execute(matricula)).longValue();
            }
        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (Exception e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().commit();
            }

            pm.close();
        }

        return rta;
    }

    /**
     * Obtiene el número de anotaciones de un folio sin tener que recorrer la
     * lista completa
     *
     * @param fol
     * @param pm
     * @return
     * @throws DAOException
     */
    protected long getCountAnotacionesFolio(FolioEnhanced fol,
            PersistenceManager pm) throws DAOException {
        long rta = 0;

        try {
            if (fol != null) {
                //En los VersantQuery, el setIgnoreCache no está haciendo el flush
                //de la transacción, es necesario hacerlo manual:
                if (pm.currentTransaction().isActive()) {
                    VersantPersistenceManager pm2 = (VersantPersistenceManager) pm;
                    pm2.flush();
                }

                String matricula = fol.getIdMatricula();

                //Se debe buscar por algún criterio las anotaciones
                VersantQuery query = (VersantQuery) pm.newQuery(AnotacionEnhanced.class);

                //query.setIgnoreCache(false);
                query.declareParameters("String matricula");

                String filtro
                        = "this.idMatricula==matricula && (this.link==null || this.link==false)";
                query.setFilter(filtro);
                query.setResult("count(this)");
                rta = ((Long) query.execute(matricula)).longValue();
            }
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }

        return rta;
    }

    /**
     * Obtiene el siguiente número de orden a asignarle a la anotación
     *
     * @param fol
     * @param pm
     * @return
     * @throws DAOException
     */
    protected long getNextOrdenAnotacion(FolioEnhanced fol,
            PersistenceManager pm) throws DAOException {
        long rta = 0;

        try {
            //Se revisa si el folio existe:
            FolioEnhancedPk folioID = new FolioEnhancedPk();
            folioID.idMatricula = fol.getIdMatricula();

            FolioEnhanced toVal = this.getFolioByID(folioID, pm);

            if (toVal != null) {
                //Se debe buscar por algún criterio las anotaciones
                long maxLpadDef = this.getMaxOrdenAnotacion(fol, pm);
                long maxLpadTmp = this.getMaxOrdenAnotacionTMP(fol, pm);
                if (maxLpadDef > maxLpadTmp) {
                    rta = maxLpadDef;
                } else {
                    rta = maxLpadTmp;
                }

            } else {
                rta = fol.getLastIdAnotacionTMP();
            }
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }

        return rta + 1;
    }

    /**
     * Obtiene el orden maximo que se tiene dentro del conjunto de anotaciones
     * definitivas de un folio
     *
     * @param folio
     * @param pm
     * @return
     * @throws DAOException
     */
    protected long getMaxOrdenAnotacion(FolioEnhanced folio, PersistenceManager pm) throws DAOException {
        long rta = 0;
        if (this.getCountAnotacionesFolio(folio, pm) != 0) {
            VersantQuery query = (VersantQuery) pm.newQuery(AnotacionEnhanced.class);
            query.declareParameters("String idMat");
            query.setFilter("this.idMatricula==idMat");
            query.setResult("max(ordenLPAD)");
            String maxLpad = (String) query.execute(folio.getIdMatricula());
            rta = Long.parseLong(maxLpad);
        }
        return rta;

    }

    /**
     * Obtiene el orden maximo que se tiene dentro del conjunto de anotaciones
     * definitivas de un folio
     *
     * @param folio
     * @param pm
     * @return
     * @throws DAOException
     */
    protected long getMaxOrdenAnotacionTMP(FolioEnhanced folio, PersistenceManager pm) throws DAOException {
        long rta = 0;
        if (this.getCountAnotacionesTMPFolio(folio, pm) != 0) {
            VersantQuery query = (VersantQuery) pm.newQuery(AnotacionTMP.class);
            query.declareParameters("String idMat");
            query.setFilter("this.idMatricula==idMat");
            query.setResult("max(ordenLPAD)");
            String maxLpad = (String) query.execute(folio.getIdMatricula());
            rta = Long.parseLong(maxLpad);
        }
        return rta;

    }

    /**
     * Obtiene el siguiente orden de anotación con base en el tamaño de las
     * anotaciones definitivas y temporales
     *
     * @param fid
     * @return
     * @throws DAOException
     */
    public long getNextOrdenAnotacion(FolioPk fid) throws DAOException {
        FolioEnhanced fol;
        long rta;
        PersistenceManager pm = AdministradorPM.getPM();

        try {
            fol = this.getFolioByID(new FolioEnhancedPk(fid), pm);

            if (fol == null) {
                throw new DAOException("El folio no existe");
            }

            rta = this.getNextOrdenAnotacion(fol, pm);
        } catch (DAOException e) {
            throw e;
        } finally {
            pm.close();
        }

        return rta;
    }

    /**
     * Obtiene el número de anotaciones de un folio sin tener que recorrer la
     * lista completa
     *
     * @param fol
     * @param pm
     * @return
     * @throws DAOException
     */
    protected long getCountAnotacionesTMPFolio(FolioEnhanced fol,
            PersistenceManager pm) throws DAOException {
        long rta = 0;

        try {
            if (fol != null) {
                //En los VersantQuery, el setIgnoreCache no está haciendo el flush
                //de la transacción, es necesario hacerlo manual:
                if (pm.currentTransaction().isActive()) {
                    VersantPersistenceManager pm2 = (VersantPersistenceManager) pm;
                    pm2.flush();
                }

                //Se debe buscar por algún criterio las anotaciones
                VersantQuery query = (VersantQuery) pm.newQuery(AnotacionTMP.class);
                //query.setIgnoreCache(false);
                query.declareParameters("FolioEnhanced fol");
                query.declareVariables("AnotacionEnhanced anota");

                String filtro = "this.folio==fol"; //&& this.estado.idEstadoAn!='"; +
                //     CEstadoAnotacion.OBSOLETA + "' ";

                //No contar las anotaciones temporales creadas para actualizar definitivas
                filtro = filtro + "&& !(anota.folio==fol \n"
                        + "&& anota.idAnotacion==this.idAnotacionTmp)";

                query.setFilter(filtro);
                query.setResult("count(this)");
                rta = ((Long) query.execute(fol)).longValue();
            }
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }

        return rta;
    }

    /**
     * Obtiene el número actual de anotaciones temporales del folio, el método
     * debe recibir el usuario que tiene bloqueado el folio
     *
     * @param oid
     * @param criterio
     * @param valor
     * @return
     * @throws DAOException
     */
    public long getCountAnotacionesTMPFolio(FolioPk oid, Usuario usuario)
            throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        long rta = 0;

        try {
            FolioEnhanced fol = this.getFolioByID(new FolioEnhancedPk(oid), pm);

            if (fol == null) {
                throw new DAOException(
                        "El folio especificado no existe. Matricula: "
                        + oid.idMatricula);
            }

            //Validar bloqueo del folio
            if (usuario != null) {
                this.validarBloqueoFolio(fol, usuario, pm);
            }

            //Se debe buscar por algún criterio las anotaciones
            pm.currentTransaction().setOptimistic(false);
            pm.currentTransaction().begin();
            rta = this.getCountAnotacionesTMPFolio(fol, pm);
        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (Exception e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().commit();
            }

            pm.close();
        }

        return rta;
    }

    /**
     * @author : Henry Gómez Rocha
     * @change : Evita que al momento de pasar del role Calificador al role
     * Digitador se verifique el usuario que tiene el bloqueo.. Caso Mantis :
     * 0004967 Obtiene el número actual de anotaciones temporales del folio, el
     * método debe recibir el usuario que tiene bloqueado el folio
     * @param oid
     * @param criterio
     * @param valor
     * @return
     * @throws DAOException
     */
    public long getCountAnotacionesTMPFolio(FolioPk oid, Usuario usuario, boolean validarTurno)
            throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        long rta = 0;

        try {
            FolioEnhanced fol = this.getFolioByID(new FolioEnhancedPk(oid), pm);

            if (fol == null) {
                throw new DAOException(
                        "El folio especificado no existe. Matricula: "
                        + oid.idMatricula);
            }

            //Validar bloqueo del folio
            if (usuario != null && validarTurno) {
                this.validarBloqueoFolio(fol, usuario, pm);
            }

            //Se debe buscar por algún criterio las anotaciones
            pm.currentTransaction().setOptimistic(false);
            pm.currentTransaction().begin();
            rta = this.getCountAnotacionesTMPFolio(fol, pm);
        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (Exception e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().commit();
            }

            pm.close();
        }

        return rta;
    }

    /**
     *
     * @param oid
     * @param criterio
     * @param valor
     * @return
     * @throws DAOException
     */
    public long getCountAnotacionesFolio(FolioPk oid, String criterio,
            String valor, boolean vigente) throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        long rta = 0;

        try {
            FolioEnhanced fol = this.getFolioByID(new FolioEnhancedPk(oid), pm);

            if (fol == null) {
                throw new DAOException(
                        "El folio especificado no existe. Matricula: "
                        + oid.idMatricula);
            }

            if (criterio == null) {
                throw new DAOException("Se debe especificar un criterio");
            }

            //Se debe buscar por algún criterio las anotaciones
            pm.currentTransaction().begin();

            VersantQuery query = (VersantQuery) pm.newQuery(AnotacionEnhanced.class);
            query.declareParameters("String parametro, FolioEnhanced fol");

            if (vigente) {
                query.declareVariables("CancelacionEnhanced cancel; CancelacionTMP cancelTMP");
            }

            String filtro = "this.folio==fol && (this.link==null || this.link==false)";
            //*String filtro = "this.folio==fol && this.estado.idEstadoAn!='" +
            //*CEstadoAnotacion.OBSOLETA + "' && (this.link==null || this.link==false)";

            if (criterio.equals(CCriterio.POR_NAT_JURIDICA)) {
                filtro = filtro
                        + " && this.naturalezaJuridica.idNaturalezaJuridica==parametro";
            } else if (criterio.equals(CCriterio.POR_GRUPO_NAT_JURIDICA)) {
                filtro = filtro
                        + " && this.naturalezaJuridica.grupoNaturalezaJuridica.idGrupoNatJuridica==parametro";
            } else if (criterio.equals(CCriterio.POR_ID_ANOTACION)) {
                filtro = filtro + " && this.idAnotacion==parametro";
            } else if (criterio.equals(CCriterio.POR_ORDEN)) {
                filtro = filtro + " && this.orden==parametro";
            } else if (criterio.equals(CCriterio.POR_TIPO_ANOTACION)) {
                filtro = filtro
                        + " && this.tipoAnotacion.idTipoAnotacion==parametro";
            } else if (!criterio.equals(CCriterio.TODAS_LAS_ANOTACIONES)) {
                throw new DAOException("Criterio invalido: " + criterio);
            }

            if (vigente) {
                filtro = filtro + " && !(cancel.cancelada==this)  && !(cancelTMP.canceladaDef==this)";
            }

            query.setFilter(filtro);
            query.setResult("count(this)");
            rta = ((Long) query.execute(valor, fol)).longValue();
        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (DAOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw e;
        } catch (Exception e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().commit();
            }

            pm.close();
        }

        return rta;
    }

    /**
     * Obtiene una lista con las direcciones del folio especificado por su ID
     *
     * @param oid identificador del Folio conformado por Nro matricula y
     * ZonaRegistral
     * @return lista con las direcciones del folio, cada direccion contiene los
     * objetos eje y eje1
     * @see gov.sir.core.negocio.modelo.Direccion
     * @throws DAOException
     */
    public List getDireccionesFolio(FolioPk oid) throws DAOException {
        FolioEnhanced fol = null;
        DireccionEnhanced direccion = null;
        PersistenceManager pm = AdministradorPM.getPM();
        List rta;

        try {
            fol = this.getFolioByID(new FolioEnhancedPk(oid), pm);

            if (fol == null) {
                throw new DAOException("El folio no existe. IdMatricula: "
                        + oid.idMatricula);
            }

            if (!fol.isDefinitivo()) {
                throw new DAOException(
                        "El folio se encuentra en estado temporal");
            }

            rta = fol.getDirecciones();

            for (Iterator itr = rta.iterator(); itr.hasNext();) {
                direccion = (DireccionEnhanced) itr.next();
                pm.makeTransient(direccion.getEje());
                pm.makeTransient(direccion.getEje1());
            }
            pm.makeTransientAll(rta);

        } catch (JDOObjectNotFoundException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        rta = TransferUtils.makeTransferAll(rta);
        this.ordenarDirecciones(rta);
        return rta;
    }

    /**
     * Obtiene una lista con las salvedades del folio especificado por su ID
     *
     * @param oid identificador del Folio conformado por Nro matricula y
     * ZonaRegistral
     * @return lista con las salvedades del folio
     * @see gov.sir.core.negocio.modelo.SalvedadFolio
     * @throws DAOException
     */
    public List getSalvedadesFolio(FolioPk oid) throws DAOException {
        FolioEnhanced fol = null;
        PersistenceManager pm = AdministradorPM.getPM();
        List rta;

        try {
            fol = this.getFolioByID(new FolioEnhancedPk(oid), pm);

            if (fol == null) {
                throw new DAOException("El folio no existe: IdMatricula: "
                        + oid.idMatricula);
            }

            if (!fol.isDefinitivo()) {
                throw new DAOException(
                        "El folio se encuentra en estado temporal");
            }

            rta = fol.getSalvedades();
            pm.makeTransientAll(rta);
        } catch (JDOObjectNotFoundException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        rta = TransferUtils.makeTransferAll(rta);

        return rta;
    }

    /**
     * Indica si el folio se encuentra bloqueado dado su identificador
     *
     * @param oid identificador del Folio conformado por Nro matricula y
     * ZonaRegistral
     * @return true está bloqueado, false no está bloqueado
     * @throws DAOException
     */
    public boolean estaBloqueado(FolioPk oid) throws DAOException {
        return false;
    }

    /**
     * Indica si el folio se encuentra bloqueado dado el número de matrícula
     *
     * @param matricula
     * @return
     * @throws DAOException
     */
    public boolean estaBloqueado(String matricula) throws DAOException {
        boolean rta;
        PersistenceManager pm = AdministradorPM.getPM();

        try {
            Query query = pm.newQuery(FolioEnhanced.class);
            query.declareVariables("BloqueoFolioEnhanced bloqueo");
            query.declareParameters("String matricula");
            query.setFilter("(idMatricula==matricula)&&\n"
                    + "(bloqueoFolio.contains(bloqueo)) &&\n"
                    + "(bloqueo.fechaBloqueo!=null && bloqueo.fechaDesbloqueo==null) && this.estado.idEstado!='"
                    + CEstadoFolio.OBSOLETO + "' && this.definitivo==true");

            Collection col = (Collection) query.execute(matricula);

            Iterator iter = col.iterator();

            if (iter.hasNext()) {
                rta = true;
            } else {
                rta = false;
            }

            query.closeAll();
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        return rta;
    }
    
    /**
     * Indica si el folio se encuentra en una actuacion administrativa
     *
     * @param matricula
     * @return
     * @throws DAOException
     */
    public boolean isActuacion(String idMatricula) throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        boolean isActuacion = false;
        Connection connection = null;
        PreparedStatement ps = null;
        ResultSet rs = null;

        VersantPersistenceManager jdoPM = null;

        String consulta = " SELECT B.ID_MATRICULA, B.BLFL_FECHA_BLOQUEO, B.BLFL_FECHA_DESBLOQUEO,B.BLFL_ID_WORKFLOW,T.ID_PROCESO FROM SIR_REL_BLOQUEO_FOLIO B " +
                            " INNER JOIN SIR_OP_TURNO T ON B.BLFL_ID_WORKFLOW = T.TRNO_ID_WORKFLOW " +
                            " WHERE ID_MATRICULA = '"+idMatricula+"' AND BLFL_FECHA_DESBLOQUEO IS NULL " +
                            " AND BLFL_FECHA_BLOQUEO IS NOT NULL AND T.ID_PROCESO = '3' ";
        try {

            jdoPM = (VersantPersistenceManager) AdministradorPM.getPM();

            jdoPM.currentTransaction().begin();

            connection = jdoPM.getJdbcConnection(null);
            ps = connection.prepareStatement(consulta);

            rs = ps.executeQuery();

           if(rs.next()){
               isActuacion = true;
           }

            jdoPM.currentTransaction().commit();

        } catch (SQLException e) {
            if (jdoPM.currentTransaction().isActive()) {
                jdoPM.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        } catch (JDOObjectNotFoundException e) {
            if (jdoPM.currentTransaction().isActive()) {
                jdoPM.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        } catch (JDOException e) {
            if (jdoPM.currentTransaction().isActive()) {
                jdoPM.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        } catch (Throwable e) {
            if (jdoPM.currentTransaction().isActive()) {
                jdoPM.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        } finally {
            try {
                if (rs != null) {
                    rs.close();
                }
                if (ps != null) {
                    ps.close();
                }
                if (connection != null) {
                    connection.close();
                }

                if (jdoPM != null) {
                    jdoPM.close();
                }

            } catch (SQLException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e);
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
                throw new DAOException(e.getMessage(), e);
            }
        }
        return isActuacion;
    }

    /**
     * Indica si el ciudadano esta en alguna anotacionCiudadano
     *
     * @param idCiudadano
     * @return
     * @throws DAOException
     */
    public boolean estaCiudadanoEnAnotacionCiudadano(String idCiudadano) throws DAOException {
        boolean rta;
        PersistenceManager pm = AdministradorPM.getPM();

        try {
            Query query = pm.newQuery(AnotacionCiudadanoEnhanced.class);
            query.declareParameters("String idCiudadano");
            query.setFilter("this.idCiudadano == idCiudadano");

            Collection col = (Collection) query.execute(idCiudadano);

            Iterator iter = col.iterator();

            if (iter.hasNext()) {
                rta = true;
            } else {
                rta = false;
            }

            query.closeAll();

            if (!rta) {
                Query query2 = pm.newQuery(AnotacionCiudadanoTMP.class);
                query2.declareParameters("String idCiudadano");
                query2.setFilter("this.idCiudadano == idCiudadano");

                Collection col2 = (Collection) query2.execute(idCiudadano);

                Iterator iter2 = col2.iterator();

                if (iter2.hasNext()) {
                    rta = true;
                } else {
                    rta = false;
                }

                query2.closeAll();
            }

        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        return rta;
    }

    /**
     * Obtiene el usuario que tiene bloqueado el folio. El folio debe estar
     * bloqueado de lo contrario genera un DAOException
     *
     * @param oid identificador del folio
     * @return objeto Usuario que tiene bloqueado el folio
     * @throws DAOException
     */
    public Usuario getUsuarioBloqueoFolio(FolioPk oid)
            throws DAOException {
        Usuario rta;
        FolioEnhanced folio;
        UsuarioEnhanced usuAux = null;
        PersistenceManager pm = AdministradorPM.getPM();

        try {
            //Validamos si el folio existe
            folio = this.getFolioByID(new FolioEnhancedPk(oid), pm);

            if (folio == null) {
                throw new DAOException(
                        "El folio con la llave especificada no existe");
            }

            //Validamos si el folio está bloqueado
            BloqueoFolioEnhanced bloqueo = this.getBloqueoFolio(folio.getIdMatricula(),
                    pm);

            if (bloqueo == null) {
                throw new DAOException("La matricula no se encuentra bloqueada");
            }

            //Validamos que el usuario sea dueño del bloqueo del folio
            usuAux = this.getUsuarioByLlaveBloqueo(bloqueo.getLlaveBloqueo(), pm);

            if (usuAux == null) {
                throw new DAOException(
                        "Error en la obtención del usuario a partir de la llave de bloqueo");
            }

            pm.makeTransient(usuAux);
        } catch (JDOObjectNotFoundException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        rta = (Usuario) usuAux.toTransferObject();

        return rta;
    }

    /**
     * Obtiene una lista con las llaves actuales de bloqueo del usuario
     *
     * @param oid identificador del usuario
     * @return lista de LlaveBloqueo
     * @see gov.sir.core.negocio.modelo.LlaveBloqueo
     * @throws DAOException
     */
    public List getLlavesBloqueo(UsuarioPk oid) throws DAOException {
        return null;
    }

    /**
     * Obtiene una lista con los BloqueoFolio correspondientes a la llave
     * especificada
     *
     * @param oid identificador de la llave
     * @return lista con BloqueoFolio, cada bloqueoFolio contiene el objeto
     * Folio
     * @see gov.sir.core.negocio.modelo.BloqueoFolio
     * @throws DAOException
     */
    public List getBloqueoFolios(LlaveBloqueoPk oid) throws DAOException {
        LlaveBloqueoEnhanced llave = null;
        BloqueoFolioEnhanced bloqueo = null;
        PersistenceManager pm = AdministradorPM.getPM();
        List rta;

        try {
            llave = (LlaveBloqueoEnhanced) pm.getObjectById(new LlaveBloqueoEnhancedPk(
                    oid), true);

            rta = llave.getBloqueoFolios();

            for (Iterator itr = rta.iterator(); itr.hasNext();) {
                bloqueo = (BloqueoFolioEnhanced) itr.next();
                pm.makeTransient(bloqueo.getFolio());
            }

            pm.makeTransientAll(rta);
        } catch (JDOObjectNotFoundException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        rta = TransferUtils.makeTransferAll(rta);

        return rta;
    }

    /**
     * Obtiene una anotacion dado su identificador
     *
     * @param oid identificador de la anotación conformado por el idAnotacion,
     * IdMatricula y IdZonaRegistral
     * @return objeto Anotacion con los objetos naturalezaJuridica,
     * tipoAnotacion y estado
     * @throws DAOException
     */
    public Anotacion getAnotacionByID(AnotacionPk oid)
            throws DAOException {

        return getAnotacionById(oid);
    }

    /**
     * Obtiene una anotacion dado su identificador en una transacción
     *
     * @param oid identificador de la anotacion conformado por el idAnotacion,
     * IdMatricula y IdZonaRegistral
     * @param pm PersistenceManager de la transacción
     * @return Anotación persistente
     * @throws DAOException
     */
    protected AnotacionEnhanced getAnotacionByID(AnotacionEnhancedPk oid,
            PersistenceManager pm) throws DAOException {
        AnotacionEnhanced rta = null;

        if ((oid.idAnotacion != null) && (oid.idMatricula != null)) {
            try {
                rta = (AnotacionEnhanced) pm.getObjectById(oid, true);

                //Las anotaciones en estado OBSOLETA no existen, están en la BD por auditoría
                //*
                /*if (rta.getEstado().getIdEstadoAn().equals(CEstadoAnotacion.OBSOLETA)) {
                    rta = null;
                }*/
            } catch (JDOObjectNotFoundException e) {
                rta = null;
            } catch (JDOException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                throw new DAOException(e.getMessage(), e);
            }
        }
        return rta;
    }

    /**
     * Obtiene una lista con las salvedades la anotación especificada por su ID
     *
     * @param oid identificador de la anotación conformado por el idAnotacion,
     * IdMatricula y IdZonaRegistral
     * @return lista con las salvedades de la anotación
     * @see gov.sir.core.negocio.modelo.SalvedadAnotacion
     * @throws DAOException
     */
    public List getSalvedadesAnotacion(AnotacionPk oid)
            throws DAOException {
        AnotacionEnhanced anota = null;
        PersistenceManager pm = AdministradorPM.getPM();
        List rta = null;

        try {
            anota = this.getAnotacionByID(new AnotacionEnhancedPk(oid), pm);

            if (anota != null) {
                rta = anota.getSalvedades();
                pm.makeTransientAll(rta);

            } else {
                AnotacionTMP anotaTmp;
                AnotacionTMPPk anotaTMPPk = new AnotacionTMPPk();
                anotaTMPPk.idAnotacionTmp = oid.idAnotacion;
                anotaTMPPk.idMatricula = oid.idMatricula;
                anotaTmp = this.getAnotacionTMPByID(anotaTMPPk, pm);

                for (Iterator itr5 = anotaTmp.getSalvedadesTMPs().iterator();
                        itr5.hasNext();) {
                    this.makeTransientSalvedadAnotacionTMP((SalvedadAnotacionTMP) itr5.next(),
                            pm);
                }

                List rtaTmp = anotaTmp.getSalvedadesTMPs();

                for (Iterator salvItera = rtaTmp.iterator();
                        salvItera.hasNext();) {
                    if (rta == null) {
                        rta = new ArrayList();
                    }
                    SalvedadAnotacionTMP salvTmp = (SalvedadAnotacionTMP) salvItera.next();
                    rta.add(salvTmp.getDefinitivo());
                }

                if (anotaTmp == null) {
                    throw new DAOException("La anotación no existe. IdMatricula: "
                            + oid.idMatricula + " idAnotacion: " + oid.idAnotacion);
                }
            }

        } catch (JDOObjectNotFoundException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        rta = TransferUtils.makeTransferAll(rta);

        return rta;
    }

    /**
     * Retorna la dirección con Mayor ID, de manera trasiente y sin dependencias
     *
     * @param direcciones
     * @return
     */
    public Direccion getUltimaDireccion(FolioPk fid) throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        DireccionEnhanced dir;
        Direccion rta;
        try {
            FolioEnhancedPk feid = new FolioEnhancedPk();
            feid.idMatricula = fid.idMatricula;
            dir = this.getUltimaDireccion(feid, pm);
        } catch (JDOObjectNotFoundException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        if (dir != null) {
            rta = (Direccion) dir.toTransferObject();
        } else {
            rta = null;
        }

        return rta;
    }

    /**
     * Obtiene el documento asociado con la anotacion
     *
     * @param oid identificador de la anotación conformado por el idAnotacion,
     * IdMatricula y IdZonaRegistral
     * @return objeto Documento con toda su jerarquía de objetos
     * @throws DAOException
     */
    public Documento getDocumentoAnotacion(AnotacionPk oid)
            throws DAOException {
        AnotacionEnhanced anota = null;
        PersistenceManager pm = AdministradorPM.getPM();
        DocumentoEnhanced rta;
        Documento aux = null;

        try {
            anota = this.getAnotacionByID(new AnotacionEnhancedPk(oid), pm);

            if (anota == null) {
                throw new DAOException("La anotación no existe. IdMatricula: "
                        + oid.idMatricula + " idAnotacion: " + oid.idAnotacion);
            }

            rta = anota.getDocumento();

            if (rta != null) {
                this.makeTransientDocumento(rta, pm);
            }
        } catch (JDOObjectNotFoundException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        if (rta != null) {
            aux = (Documento) rta.toTransferObject();
        }

        return aux;
    }

    /**
     * Obtiene un documento dado su identificador en una transacción
     *
     * @param oid identificador del documento
     * @param pm PersistenceManager
     * @return Documento, null si no lo encuentra
     * @throws DAOException
     */
    protected DocumentoEnhanced getDocumento(DocumentoEnhancedPk oid,
            PersistenceManager pm) throws DAOException {
        DocumentoEnhanced rta = null;

        if (oid.idDocumento != null) {
            try {
                rta = (DocumentoEnhanced) pm.getObjectById(oid, true);
            } catch (JDOObjectNotFoundException e) {
                rta = null;
            } catch (JDOException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                throw new DAOException(e.getMessage(), e);
            }
        }

        return rta;
    }

    protected SalvedadFolioTMP getSalvedadFolioTMP(
            SalvedadFolioTMPPk oid, PersistenceManager pm
    ) throws DAOException {

        SalvedadFolioTMP rta = null;

        if (null != oid.idSalvedadFoTmp
                && null != oid.idMatricula) {

            try {
                rta = (SalvedadFolioTMP) pm.getObjectById(oid, true);
            } catch (JDOObjectNotFoundException e) {
                rta = null;
            } catch (JDOException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                throw new DAOException(e.getMessage(), e);
            }
        }

        return rta;
    }

    /**
     * Obtiene un documento temporal persistente por su ID
     *
     * @param oid
     * @param pm
     * @return
     * @throws DAOException
     */
    protected DocumentoTMP getDocumentoTMP(DocumentoTMPPk oid,
            PersistenceManager pm) throws DAOException {
        DocumentoTMP rta = null;

        if (oid.idDocumentoTmp != null) {
            try {
                rta = (DocumentoTMP) pm.getObjectById(oid, true);
            } catch (JDOObjectNotFoundException e) {
                rta = null;
            } catch (JDOException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                throw new DAOException(e.getMessage(), e);
            }
        }

        return rta;
    }

    /**
     * Obtiene una lista de objetos tipo Cancelacion de la anotación
     * especificada por su identificador
     *
     * @param oid identificador de la anotación conformado por el idAnotacion,
     * IdMatricula y IdZonaRegistral
     * @return lista de objetos tipo Cancelacion, cada una contiene el objeto
     * cancelada que indica la anotación cancelada
     * @see gov.sir.core.negocio.modelo.Cancelacion
     * @throws DAOException
     */
    public List getAnotacionesCanceladas(AnotacionPk oid)
            throws DAOException {
        CancelacionEnhanced anotaCanc = null;
        AnotacionEnhanced anota = null;
        PersistenceManager pm = AdministradorPM.getPM();
        List rta;

        try {
            anota = this.getAnotacionByID(new AnotacionEnhancedPk(oid), pm);

            if (anota == null) {
                throw new DAOException("La anotación no existe. IdMatricula: "
                        + oid.idMatricula + " idAnotacion: " + oid.idAnotacion);
            }

            rta = anota.getAnotacionesCancelacions();

            for (Iterator itr = rta.iterator(); itr.hasNext();) {
                anotaCanc = (CancelacionEnhanced) itr.next();
                pm.makeTransient(anotaCanc.getCancelada());
            }

            pm.makeTransientAll(rta);
        } catch (JDOObjectNotFoundException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        rta = TransferUtils.makeTransferAll(rta);

        return rta;
    }

    /**
     * Obtiene una lista con las anotaciones del folio especificado por su
     * matricula
     *
     * @param matricula Nro de matrícula
     * @return lista con las anotaciones del folio, cada anotación contiene los
     * objetos tipoAnotacion, naturalezaJuridica y estado
     * @throws DAOException
     */
    public List getAnotacionesFolio(String matricula) throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        List rta;
        AnotacionEnhanced anota = null;

        try {
            Query query = pm.newQuery(AnotacionEnhanced.class);
            query.declareParameters("String matricula");
            query.setFilter("folio.idMatricula==matricula && (this.link==null || this.link==false)");

            //*"folio.idMatricula==matricula && this.estado.idEstadoAn!='" +
            //*CEstadoAnotacion.OBSOLETA + "' && (this.link==null || this.link==false)");
            rta = (List) query.execute(matricula);

            for (Iterator itr = rta.iterator(); itr.hasNext();) {
                anota = (AnotacionEnhanced) itr.next();
                this.makeTransientAnotacion(anota, pm, new ArrayList());
            }

            pm.makeTransientAll(rta);

            if (rta.size() == 0) {
                rta = new ArrayList();
            }

            query.closeAll();
        } catch (JDOObjectNotFoundException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        rta = TransferUtils.makeTransferAll(rta);

        return rta;
    }

    /**
     * Obtiene una lista de objetos tipo AnotacionCiudadano de la anotación
     * especificada por su identificador
     *
     * @param oid identificador de la anotación conformado por el idAnotacion,
     * IdMatricula y IdZonaRegistral
     * @return lista de objetos tipo AnotacionCiudadano, cada uno contiene el
     * objeto ciudadano
     * @see gov.sir.core.negocio.modelo.AnotacionCiudadano
     * @see gov.sir.core.negocio.modelo.Ciudadano
     * @throws DAOException
     */
    public List getAnotacionesCiudadano(AnotacionPk oid)
            throws DAOException {
        AnotacionCiudadanoEnhanced anotaCiud = null;
        AnotacionEnhanced anota = null;
        PersistenceManager pm = AdministradorPM.getPM();
        List rta;

        try {
            anota = this.getAnotacionByID(new AnotacionEnhancedPk(oid), pm);

            if (anota == null) {
                throw new DAOException("La anotación no existe. IdMatricula: "
                        + oid.idMatricula + " idAnotacion: " + oid.idAnotacion);
            }

            rta = anota.getAnotacionesCiudadanos();

            for (Iterator itr = rta.iterator(); itr.hasNext();) {
                anotaCiud = (AnotacionCiudadanoEnhanced) itr.next();
                pm.makeTransient(anotaCiud.getCiudadano());
            }

            pm.makeTransientAll(rta);
        } catch (JDOObjectNotFoundException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        rta = TransferUtils.makeTransferAll(rta);

        return rta;
    }

    /**
     * Obtiene las anotaciones hijas de una anotacion
     *
     * @param oid identificador de la anotación conformado por el idAnotacion,
     * IdMatricula y IdZonaRegistral
     * @return lista de objetos FolioDerivado, cada uno contiene el objeto hijo
     * que indica la anotación derivada
     * @see gov.sir.core.negocio.modelo.FolioDerivado
     * @throws DAOException
     */
    public List getAnotacionesHijas(AnotacionPk oid) throws DAOException {
        AnotacionEnhanced anota = null;
        FolioDerivadoEnhanced fd = null;
        PersistenceManager pm = AdministradorPM.getPM();
        List rta;

        try {
            anota = this.getAnotacionByID(new AnotacionEnhancedPk(oid), pm);

            if (anota == null) {
                throw new DAOException("La anotación no existe. IdMatricula: "
                        + oid.idMatricula + " idAnotacion: " + oid.idAnotacion);
            }

            rta = anota.getAnotacionesHijos();

            for (Iterator itr = rta.iterator(); itr.hasNext();) {
                fd = (FolioDerivadoEnhanced) itr.next();
                pm.makeTransient(fd.getHijo());
            }

            pm.makeTransientAll(rta);
        } catch (JDOObjectNotFoundException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        rta = TransferUtils.makeTransferAll(rta);

        return rta;
    }

    /**
     * Obtiene las anotaciones padre de una anotacion
     *
     * @param oid identificador de la anotación conformado por el idAnotacion,
     * IdMatricula y IdZonaRegistral
     * @return lista de objetos FolioDerivado, cada uno contiene el objeto padre
     * que indica la anotación derivada
     * @see gov.sir.core.negocio.modelo.FolioDerivado
     * @throws DAOException
     */
    public List getAnotacionesPadre(AnotacionPk oid) throws DAOException {
        AnotacionEnhanced anota = null;
        FolioDerivadoEnhanced fd = null;
        PersistenceManager pm = AdministradorPM.getPM();
        List rta;

        try {
            anota = this.getAnotacionByID(new AnotacionEnhancedPk(oid), pm);

            if (anota == null) {
                throw new DAOException("La anotación no existe. IdMatricula: "
                        + oid.idMatricula + " idAnotacion: " + oid.idAnotacion);
            }

            rta = anota.getAnotacionesPadre();

            List cache = new ArrayList();

            for (Iterator itr = rta.iterator(); itr.hasNext();) {
                fd = (FolioDerivadoEnhanced) itr.next();
                this.makeTransientAnotacionPadre(fd, pm, cache);
            }

            pm.makeTransientAll(rta);
        } catch (JDOObjectNotFoundException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        rta = TransferUtils.makeTransferAll(rta);

        return rta;
    }

    /**
     * Obtiene el folio asociado a una anotación
     *
     * @param oid identificador de la anotación conformado por el idAnotacion,
     * IdMatricula y IdZonaRegistral
     * @return Objeto Folio con sus objetos estado, lindero, tipoPredio y
     * ZonaRegistral. El objeto ZonaRegistral contiene la jerarquía circulo,
     * vereda, municipio y departamento null si no encuentra un folio que
     * coincida con el identificador dado
     * @throws DAOException
     */
    public Folio getFolioAnotacion(AnotacionPk oid) throws DAOException {
        FolioPk fid = new FolioPk();
        fid.idMatricula = oid.idMatricula;

        return this.getFolioByID(fid);
    }

    /**
     * Busca una complementación en una transacción
     *
     * @param oid identificador de la complementación
     * @param pm PersistenceManager
     * @return objeto Complementacion, si no existe retorna null
     * @throws DAOException
     */
    protected ComplementacionEnhanced getComplementacion(
            ComplementacionEnhancedPk oid, PersistenceManager pm)
            throws DAOException {
        ComplementacionEnhanced rta = null;

        if (oid.idComplementacion != null) {
            try {
                rta = (ComplementacionEnhanced) pm.getObjectById(oid, true);
            } catch (JDOObjectNotFoundException e) {
                rta = null;
            } catch (JDOException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                throw new DAOException(e.getMessage(), e);
            }
        }

        return rta;
    }

    /**
     *
     * @param datos
     * @param pm
     * @return
     * @throws DAOException
     */
    public boolean validarActualizacionCiudadanoTurno(Turno turno) throws DAOException {

        StringBuffer sqlStatement = new StringBuffer(4096);

        sqlStatement.append(" select id_ciudadano_tmp from sir_ne_ciudadano_tmp where cdtm_radicacion = '" + turno.getIdWorkflow() + "'");

        // ---------------------------------
        long result_NumberOfRecords = 0;

        Connection connection = null;
        PreparedStatement ps = null;
        ResultSet rs = null;

        VersantPersistenceManager jdoPM = null;
        // get jdo.commnection ---------------
        try {
            jdoPM = (VersantPersistenceManager) AdministradorPM.getPM();
            jdoPM.currentTransaction().setOptimistic(false);
            jdoPM.currentTransaction().begin();
            connection = jdoPM.getJdbcConnection(null);
        } catch (JDOException e) {
            if (jdoPM.currentTransaction().isActive()) {
                jdoPM.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        }

        // -----------------------------------
        try {

            ps = connection.prepareStatement(sqlStatement.toString());

            rs = ps.executeQuery();

            while (rs.next()) {
                result_NumberOfRecords++;
            } // while

            jdoPM.currentTransaction().commit();

        } catch (SQLException e) {
            if (jdoPM.currentTransaction().isActive()) {
                jdoPM.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException("Error SQL: " + e.getMessage(), e);
        } catch (JDOException e) {
            if (jdoPM.currentTransaction().isActive()) {
                jdoPM.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        } catch (Throwable e) { // necessary ?
            if (jdoPM.currentTransaction().isActive()) {
                jdoPM.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        } finally {

            try {

                if (rs != null) {
                    rs.close();
                }

                if (ps != null) {
                    ps.close();
                }

                if (connection != null) {
                    connection.close();
                }
                if (jdoPM != null) {
                    jdoPM.close();
                }

            } catch (SQLException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e);
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            } // try

        } // try

        if (result_NumberOfRecords > 0) {
            return true;
        }
        return false;
    }

    /**
     *
     * @param datos
     * @param pm
     * @return
     * @throws DAOException
     */
    public List getFolioDerivePadre(String IdMatricula, String IdAnotacion) throws DAOException {

        Connection connection = null;
        PreparedStatement ps = null;
        ResultSet rs = null;

        VersantPersistenceManager jdoPM = null;

        List ListDerivados = new ArrayList();
        try {

            String consulta
                    = " SELECT ID_ANOTACION_TMP,ID_MATRICULA,ID_ANOTACION1_TMP,ID_MATRICULA1, "
                    + " FDTM_PORCENTAJE,FDTM_AREA,FDTM_HECTAREAS,FDTM_METROS,FDTM_CENTIMETROS,FDTM_LOTE "
                    + " FROM SIR_NE_FOLIO_DERIVADO_TMP "
                    + " WHERE ID_MATRICULA1 = ? "
                    + " AND ID_ANOTACION1_TMP = ?";

            jdoPM = (VersantPersistenceManager) AdministradorPM.getPM();

            jdoPM = (VersantPersistenceManager) AdministradorPM.getPM();
            jdoPM.currentTransaction().setOptimistic(false);
            jdoPM.currentTransaction().begin();

            connection = jdoPM.getJdbcConnection(null);
            ps = connection.prepareStatement(consulta);

            ps.setString(1, IdMatricula);
            ps.setString(2, IdAnotacion);

            rs = ps.executeQuery();

            while (rs.next()) {
                FolioDerivado flDerivado = new FolioDerivado();
                flDerivado.setIdAnotacion(rs.getString(1));
                flDerivado.setIdMatricula(rs.getString(2));
                flDerivado.setIdAnotacion1(rs.getString(3));
                flDerivado.setIdMatricula1(rs.getString(4));
                flDerivado.setPorcentaje(rs.getString(5));
                flDerivado.setArea(rs.getString(6));
                flDerivado.setHectareas(rs.getString(7));
                flDerivado.setMetros(rs.getString(8));
                flDerivado.setCentimetros(rs.getString(9));
                flDerivado.setLote(rs.getString(10));

                ListDerivados.add(flDerivado);
            }
            jdoPM.currentTransaction().commit();
        } catch (SQLException e) {
            if (jdoPM.currentTransaction().isActive()) {
                jdoPM.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        } catch (JDOObjectNotFoundException e) {
            if (jdoPM.currentTransaction().isActive()) {
                jdoPM.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        } catch (JDOException e) {
            if (jdoPM.currentTransaction().isActive()) {
                jdoPM.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        } catch (Throwable e) {
            if (jdoPM.currentTransaction().isActive()) {
                jdoPM.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        } finally {
            try {
                if (rs != null) {
                    rs.close();
                }
                if (ps != null) {
                    ps.close();
                }
                if (connection != null) {
                    connection.close();
                }

            } catch (SQLException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e);
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
                throw new DAOException(e.getMessage(), e);
            }
        }
        return ListDerivados;
    }

    /**
     *
     * @param datos
     * @param pm
     * @return
     * @throws DAOException
     */
    protected boolean crearFolio(FolioEnhanced datos, UsuarioEnhanced usuario,
            PersistenceManager pm, TurnoEnhanced turno, boolean validarTurno) throws DAOException {
        JDOGenieZonaRegistralDAO zonaRegistralDAO = new JDOGenieZonaRegistralDAO();
        FolioEnhancedPk rta = new FolioEnhancedPk();
        FolioEnhanced val = null;
        boolean flagPKManual = false;
        VersantPersistenceManager pm2 = null;

        CirculoEnhanced cir;
        String idCirculo = "";

        try {
            ZonaRegistralEnhanced zr;

            //Si viene el número de matrícula se valida que no exista un folio
            //con el mismo número
            if ((datos.getIdMatricula() != null)) {
                flagPKManual = true;

                val = this.getFolioByMatriculaIncluyendoObsoletos(datos.getIdMatricula(),
                        pm);

                if (val != null) {
                    if (val.getEstado().getIdEstado().equals(CEstadoFolio.OBSOLETO)) {
                        throw new DAOException(
                                "El número de matrícula especificado ya fue utilizado para un folio");
                    } else if (!val.isDefinitivo()) {
                        throw new DAOException(
                                "El número de matrícula ya fue utilizado para un folio temporal");
                    } else {
                        throw new DAOException(
                                "El folio con el número de matrícula especificado ya existe");
                    }
                }
            }

            //Se valida que el folio tenga zona registral
            if (datos.getZonaRegistral() == null) {
                throw new DAOException(
                        "No existe una zona registral asociado al folio ");
            }

            //Se valida y asocia la zona registral, si existe un ID de zona
            //registral se busca por el id, en caso que no exista se busca
            //la zona registral por el círculo y la vereda
            if (datos.getZonaRegistral().getIdZonaRegistral() != null) {
                ZonaRegistralEnhancedPk zrId = new ZonaRegistralEnhancedPk();
                zrId.idZonaRegistral = datos.getZonaRegistral()
                        .getIdZonaRegistral();
                zr = zonaRegistralDAO.getZonaRegistral(zrId, pm);

                if (zr == null) {
                    throw new DAOException(
                            "No encontró la zona registral con el ID: "
                            + zrId.idZonaRegistral);
                }
            } else {
                zr = zonaRegistralDAO.getZonaRegistralByCirculoVereda(datos.getZonaRegistral()
                        .getCirculo(),
                        datos.getZonaRegistral().getVereda(), pm);

                if (zr == null) {
                    throw new DAOException(
                            "No encontró la zona registral del circulo y vereda especificados");
                }
            }

            //Lo primero que se necesita leer es el círculo con el fin
            //de bloquear el registro para obtener el secuencial. Esto se hace
            //sólamente si el número de matrícula es autogenerado
            if (!flagPKManual) {
                //Se hace el cambio de tipo de bloqueo pesimista para
                //que se bloquee la tabla de circulo la cual  nos
                //provee el secuencial
                pm2 = (VersantPersistenceManager) pm;
                try {
                    pm2.setDatastoreTxLocking(VersantPersistenceManager.LOCKING_ALL);
                    pm = pm2;

                    CirculoEnhancedPk cid = new CirculoEnhancedPk();
                    cid.idCirculo = zr.getCirculo().getIdCirculo();
                    cir = zonaRegistralDAO.getCirculo(cid, pm);

                    if (cir == null) {
                        pm2.setDatastoreTxLocking(VersantPersistenceManager.LOCKING_NONE);
                        throw new DAOException(
                                "El círculo de la zona registral no existe");
                    }

                    idCirculo = cid.idCirculo;

                    //Volvemos a setear el tipo de bloqueo pesimista
                    //para que no nos bloquee los siquientes registros
                    //consultados
                    pm2.setDatastoreTxLocking(VersantPersistenceManager.LOCKING_NONE);
                } catch (Exception e) {
                    pm2.setDatastoreTxLocking(VersantPersistenceManager.LOCKING_NONE);
                    if (pm.currentTransaction().isActive()) {
                        pm.currentTransaction().rollback();
                    }
                    Log.getInstance().error(this.getClass(), e.getMessage());
                    throw new DAOException(e.getMessage(), e);
                }

                long cons;

                //Se verifica primero en la tabla de matrículas no grabadas
                //con el fin de utilizar estos números de matrícula
                //Se elimina la reutilización por bug 3447
                MatriculaNoGrabadaEnhanced matNoGrab = this.getFirstMatriculaNoGrabada(cir, pm);
                Folio folioTemp = null;

                //Se verifica si la matricula existe en la tabla de folios
                if (matNoGrab != null) {
                    cons = matNoGrab.getIdMatNoGrabada();
                    String matriculaTemp = matNoGrab.getIdCirculo() + "-" + String.valueOf(cons);
                    folioTemp = this.getFolioByID(matriculaTemp);
                }

                if (matNoGrab != null && folioTemp == null) {
                    //La matrícula se saca de la tabla de matrículas no grabadas en definitivo
                    cons = matNoGrab.getIdMatNoGrabada();
                    pm.deletePersistent(matNoGrab);
                } else {

                    // En caso de que la matricula este tanto en la tabla de matriculas no grabadas
                    //como en la de folio, se elimina de matriculas no grabadas
                    if (matNoGrab != null && folioTemp != null) {
                        pm.deletePersistent(matNoGrab);
                    }
                    //Se busca el siguiente número de matricula para
                    //el nuevo folio dentro del circulo dado
                    cons = cir.getLastNoMatricula() + 1;
                    boolean flag = true;
                    String matAux;

                    while (flag) {
                        matAux = cir.getIdCirculo() + "-" + String.valueOf(cons);

                        if (this.getFolioByMatricula(matAux, pm) == null) {
                            flag = false;
                        } else {
                            cons++;
                        }
                    }
                    cir.setLastNoMatricula(cons);
                }

                datos.setIdMatricula(cir.getIdCirculo() + "-"
                        + String.valueOf(cons));

            } else {
                StringTokenizer st = new StringTokenizer(datos.getIdMatricula(),
                        "-");
                String cirID = st.nextToken();
                String secuencial = st.nextToken();

                long sec = Long.parseLong(secuencial);

                if ((zr.getCirculo().getLastNoMatricula() + 1) < sec) {
                    throw new DAOException(
                            "El número de matrícula especificado supera la secuencia del círculo");
                } else if ((zr.getCirculo().getLastNoMatricula() + 1) == sec) {
                    zr.getCirculo().setLastNoMatricula(zr.getCirculo()
                            .getLastNoMatricula()
                            + 1);
                }

                if (!cirID.equals(datos.getZonaRegistral().getCirculo()
                        .getIdCirculo())) {
                    throw new DAOException(
                            "El identificador del círculo de la matrícula no coincide con el círculo especificado en la zona registral");
                }

                idCirculo = cirID;
            }

            //Se asocia la zona registral al folio
            datos.setZonaRegistral(zr);

            //Se valida y asocia el estado del folio por defecto (ACTIVO)
            EstadoFolioEnhanced ef;
            EstadoFolioEnhancedPk efId = new EstadoFolioEnhancedPk();
            efId.idEstado = CEstadoFolio.ACTIVO;
            ef = this.getEstadoFolio(efId, pm);

            if (ef == null) {
                throw new DAOException(
                        "No encontró el estado de folio con el ID: "
                        + efId.idEstado);
            }

            datos.setEstado(ef);

            //Se valida y asocia el tipo de predio
            TipoPredioEnhanced tp = datos.getTipoPredio();

            if (tp == null) {
                throw new DAOException(
                        "No existe un tipo de predio asociado con el folio");
            }

            TipoPredioEnhancedPk tpId = new TipoPredioEnhancedPk();
            tpId.idPredio = tp.getIdPredio();
            tp = this.getTipoPredio(tpId, pm);

            if (tp == null) {
                throw new DAOException(
                        "No encontró el tipo de predio con el ID: "
                        + tpId.idPredio);
            }

            datos.setTipoPredio(tp);

            //Se valida y asocia la complementación, si la complementación
            //ya existe en la base de datos se asocia, si no existe se crea
            //la complementación temporal
            ComplementacionEnhanced com = datos.getComplementacion();

            if (com != null) {
                //Si viene una complementacion:
                ComplementacionEnhancedPk comID = new ComplementacionEnhancedPk();
                comID.idComplementacion = com.getIdComplementacion();

                ComplementacionEnhanced comAux = this.getComplementacion(comID,
                        pm);

                if (comAux != null) {
                    //La complementación se debe asociar, sin embargo se
                    //debe buscar si la complementacion ya se encuentra
                    //en estado temporal
                    //TODO
                    ComplementacionTMPPk cidTMP = new ComplementacionTMPPk();
                    cidTMP.idComplementacionTmp = com.getIdComplementacion();

                    ComplementacionTMP temp = this.getComplementacionTMP(cidTMP,
                            pm);

                    if (temp != null) {
                        //ya existe una complementación temporal para la complementación dada
                        //Se setea la complementación temporal
                        temp.setComplementacion(datos.getComplementacion()
                                .getComplementacion());
                        datos.setComplementacionTMP(temp);
                    } else {
                        //Se crea la complementación temporal con la información actual
                        datos.setComplementacionTMP(new ComplementacionTMP(
                                comAux));
                    }
                } else {
                    //La complementación se debe crear
                    com.setComplementacion(datos.getComplementacion()
                            .getComplementacion());

                    //Se obtiene y se bloquea la tabla que provee la secuencia de complementacion
                    com.setIdComplementacion(String.valueOf(this.getSecuencial(
                            CComplementacion.TABLE_NAME, null)));

                    ComplementacionTMP cTMP = new ComplementacionTMP(com);
                    datos.setComplementacionTMP(cTMP);
                }

                datos.setComplementacion(null);
            }

            //Si tiene documento se asocia
            DocumentoEnhanced doc = datos.getDocumento();

            if (doc != null) {
                if (doc.getCirculo() == null) {
                    doc.setCirculo(idCirculo);
                }
                this.setDocumentoToFolio(datos, doc, pm);
            }

            datos.setDefinitivo(false);
            datos.setFechaApertura(new Date());
            datos.setLastIdAnotacion(0);
            datos.setLastIdDireccion(0);
            datos.setLastIdSalvedad(0);
            datos.setLastIdAnotacionTMP(0);
            datos.setLastIdDireccionTMP(0);
            datos.setLastIdSalvedadTMP(0);

            datos.setCirculo(idCirculo);

            //Se crean las direcciones temporales
            List direcciones = datos.getDirecciones();
            DireccionTMP direccion;
            DireccionEnhanced dir;

            for (Iterator itr = direcciones.iterator(); itr.hasNext();) {
                dir = (DireccionEnhanced) itr.next();
                direccion = new DireccionTMP(dir);
                datos.addDireccionesTMP(direccion);
                this.addDireccionTMPToFolio(datos, direccion, usuario, pm);
            }

            //Se quitan las direcciones de definitivo
            datos.removeAllDirecciones();

            //Se crean las salvedades temporales
            List salvedades = datos.getSalvedades();
            SalvedadFolioTMP salvedad;
            SalvedadFolioEnhanced sal;

            for (Iterator itr = salvedades.iterator(); itr.hasNext();) {
                sal = (SalvedadFolioEnhanced) itr.next();
                salvedad = new SalvedadFolioTMP(sal);
                datos.addSalvedadesTMP(salvedad);
                this.addSalvedadTMPToFolio(datos, salvedad, usuario, pm);
            }

            //se quitan las salvedades de definitivo
            datos.removeAllSalvedades();

            //Se crean las anotaciones temporales
            List anotaciones = datos.getAnotaciones();
            AnotacionTMP anotacion;
            AnotacionEnhanced anota;
            List cache;

            //Se agregan anotaciones temporales en caso
            //que se manden explicitamente en la lista
            //de anotaciones temporales
            List anotacionesTMP = datos.getAnotacionesTMPs();

            for (Iterator itr = anotacionesTMP.iterator(); itr.hasNext();) {
                anotacion = (AnotacionTMP) itr.next();

                //Se le quita el ID para que se asigne un ID automático
                anotacion.setIdAnotacionTmp(null);
                anotacion.setOrden(String.valueOf(this.getNextOrdenAnotacion(datos, pm)));

                this.addAnotacionTMPToFolio(datos, anotacion, usuario, turno, pm);
            }

            for (Iterator itr = anotaciones.iterator(); itr.hasNext();) {
                cache = new ArrayList();
                anota = (AnotacionEnhanced) itr.next();
                anotacion = new AnotacionTMP(anota, cache);

                //Se le quita el ID para que se asigne un ID automático
                anotacion.setIdAnotacionTmp(null);
                anotacion.setOrden(String.valueOf(this.getNextOrdenAnotacion(datos, pm)));

                datos.addAnotacionesTMP(anotacion);
                this.addAnotacionTMPToFolio(datos, anotacion, usuario, turno, pm);

                /* if(anotacion.getAnotacionesPadreTMPs() != null && anotacion.getAnotacionesPadreTMPs().isEmpty()){
                	Iterator iteraFlDirivePadre = anotacion.getAnotacionesPadreTMPs().iterator(); 
                	while(iteraFlDirivePadre.hasNext()){


                		FolioDerivadoEnhanced folioDerivePadre = (FolioDerivadoEnhanced)iteraFlDirivePadre.next();
                		folioDerivePadre.setIdMatricula1(datos.getIdMatricula());                		            		            			
            			pm.makePersistent(folioDerivePadre);
            		}
                }*/
            }

            //Se quitan las anotaciones de definitivo
            datos.removeAllAnotaciones();

            //Se valida y se crea la asociación con el turno
            if (validarTurno) {
                if (datos.getTurnosFolios().size() == 0) {
                    throw new DAOException(
                            "No existe un turno asociado para crear el folio");
                } else if ((TurnoFolioEnhanced) datos.getTurnosFolios().get(0) == null) {
                    throw new DAOException(
                            "No existe un turno asociado para crear el folio");
                } else {
                    if (datos.getTurnosFolios().size() > 1) {
                        Log.getInstance().debug(JDOGenieFolioDAO.class, "Turno tiene (DAO - private -TF)" + datos.getTurnosFolios().size());
                        throw new DAOException("No puede asociar varios TurnosFolios al folio");
                    }

                    TurnoFolioEnhanced tf = (TurnoFolioEnhanced) datos.getTurnosFolios()
                            .get(0);
                    addTurnoFolioToFolio(datos, tf, pm);
                }
            }

            //Se setea el suaurio creador:
            datos.setUsuarioCreacion(usuario);

            pm.makePersistent(datos);
            this.setHistorialAreaByEnhanced(datos, pm, usuario.getUsername());
            return true;
        } catch (DAOException e) {
            if (pm2 != null && !pm2.isClosed()) {
                pm2.setDatastoreTxLocking(VersantPersistenceManager.LOCKING_NONE);
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw e;
        } catch (JDOException e) {
            if (pm2 != null && !pm2.isClosed()) {
                pm2.setDatastoreTxLocking(VersantPersistenceManager.LOCKING_NONE);
            }
            DAOException daoe = new DAOException(e.getMessage(), e);
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw daoe;
        }
    }

    /**
     *
     * @param datos
     * @param pm
     * @return
     * @throws DAOException
     */
    protected boolean crearFolioSegeng(FolioEnhanced datos, UsuarioEnhanced usuario,
            PersistenceManager pm, TurnoEnhanced turno, boolean validarTurno) throws DAOException {
        JDOGenieZonaRegistralDAO zonaRegistralDAO = new JDOGenieZonaRegistralDAO();
        FolioEnhancedPk rta = new FolioEnhancedPk();
        FolioEnhanced val = null;
        boolean flagPKManual = false;
        VersantPersistenceManager pm2 = null;

        CirculoEnhanced cir;
        String idCirculo = "";

        try {
            ZonaRegistralEnhanced zr;

            //Si viene el número de matrícula se valida que no exista un folio
            //con el mismo número
            if ((datos.getIdMatricula() != null)) {
                flagPKManual = true;

                val = this.getFolioByMatriculaIncluyendoObsoletos(datos.getIdMatricula(),
                        pm);

                if (val != null) {
                    if (val.getEstado().getIdEstado().equals(CEstadoFolio.OBSOLETO)) {
                        throw new DAOException(
                                "El número de matrícula especificado ya fue utilizado para un folio");
                    } else if (!val.isDefinitivo()) {
                        throw new DAOException(
                                "El número de matrícula ya fue utilizado para un folio temporal");
                    } else {
                        throw new DAOException(
                                "El folio con el número de matrícula especificado ya existe");
                    }
                }
            }

            //Se valida que el folio tenga zona registral
            if (datos.getZonaRegistral() == null) {
                throw new DAOException(
                        "No existe una zona registral asociado al folio ");
            }

            //Se valida y asocia la zona registral, si existe un ID de zona
            //registral se busca por el id, en caso que no exista se busca
            //la zona registral por el círculo y la vereda
            if (datos.getZonaRegistral().getIdZonaRegistral() != null) {
                ZonaRegistralEnhancedPk zrId = new ZonaRegistralEnhancedPk();
                zrId.idZonaRegistral = datos.getZonaRegistral()
                        .getIdZonaRegistral();
                zr = zonaRegistralDAO.getZonaRegistral(zrId, pm);

                if (zr == null) {
                    throw new DAOException(
                            "No encontró la zona registral con el ID: "
                            + zrId.idZonaRegistral);
                }
            } else {
                zr = zonaRegistralDAO.getZonaRegistralByCirculoVereda(datos.getZonaRegistral()
                        .getCirculo(),
                        datos.getZonaRegistral().getVereda(), pm);

                if (zr == null) {
                    throw new DAOException(
                            "No encontró la zona registral del circulo y vereda especificados");
                }
            }

            //Lo primero que se necesita leer es el círculo con el fin
            //de bloquear el registro para obtener el secuencial. Esto se hace
            //sólamente si el número de matrícula es autogenerado
            if (!flagPKManual) {
                //Se hace el cambio de tipo de bloqueo pesimista para
                //que se bloquee la tabla de circulo la cual  nos
                //provee el secuencial
                pm2 = (VersantPersistenceManager) pm;
                try {
                    pm2.setDatastoreTxLocking(VersantPersistenceManager.LOCKING_ALL);
                    pm = pm2;

                    CirculoEnhancedPk cid = new CirculoEnhancedPk();
                    cid.idCirculo = zr.getCirculo().getIdCirculo();
                    cir = zonaRegistralDAO.getCirculo(cid, pm);

                    if (cir == null) {
                        pm2.setDatastoreTxLocking(VersantPersistenceManager.LOCKING_NONE);
                        throw new DAOException(
                                "El círculo de la zona registral no existe");
                    }

                    idCirculo = cid.idCirculo;

                    //Volvemos a setear el tipo de bloqueo pesimista
                    //para que no nos bloquee los siquientes registros
                    //consultados
                    pm2.setDatastoreTxLocking(VersantPersistenceManager.LOCKING_NONE);
                } catch (Exception e) {
                    pm2.setDatastoreTxLocking(VersantPersistenceManager.LOCKING_NONE);
                    if (pm.currentTransaction().isActive()) {
                        pm.currentTransaction().rollback();
                    }
                    Log.getInstance().error(this.getClass(), e.getMessage());
                    throw new DAOException(e.getMessage(), e);
                }

                long cons;

                //Se verifica primero en la tabla de matrículas no grabadas
                //con el fin de utilizar estos números de matrícula
                //Se elimina la reutilización por bug 3447
                MatriculaNoGrabadaEnhanced matNoGrab = this.getFirstMatriculaNoGrabada(cir, pm);
                Folio folioTemp = null;

                //Se verifica si la matricula existe en la tabla de folios
                if (matNoGrab != null) {
                    cons = matNoGrab.getIdMatNoGrabada();
                    String matriculaTemp = matNoGrab.getIdCirculo() + "-" + String.valueOf(cons);
                    folioTemp = this.getFolioByID(matriculaTemp);
                }

                if (matNoGrab != null && folioTemp == null) {
                    //La matrícula se saca de la tabla de matrículas no grabadas en definitivo
                    cons = matNoGrab.getIdMatNoGrabada();
                    pm.deletePersistent(matNoGrab);
                } else {

                    // En caso de que la matricula este tanto en la tabla de matriculas no grabadas
                    //como en la de folio, se elimina de matriculas no grabadas
                    if (matNoGrab != null && folioTemp != null) {
                        pm.deletePersistent(matNoGrab);
                    }
                    //Se busca el siguiente número de matricula para
                    //el nuevo folio dentro del circulo dado
                    cons = cir.getLastNoMatricula() + 1;
                    boolean flag = true;
                    String matAux;

                    while (flag) {
                        matAux = cir.getIdCirculo() + "-" + String.valueOf(cons);

                        if (this.getFolioByMatricula(matAux, pm) == null) {
                            flag = false;
                        } else {
                            cons++;
                        }
                    }
                    cir.setLastNoMatricula(cons);
                }

                datos.setIdMatricula(cir.getIdCirculo() + "-"
                        + String.valueOf(cons));

            } else {
                StringTokenizer st = new StringTokenizer(datos.getIdMatricula(),
                        "-");
                String cirID = st.nextToken();
                String secuencial = st.nextToken();

                long sec = Long.parseLong(secuencial);

                if ((zr.getCirculo().getLastNoMatricula() + 1) < sec) {
                    throw new DAOException(
                            "El número de matrícula especificado supera la secuencia del círculo");
                } else if ((zr.getCirculo().getLastNoMatricula() + 1) == sec) {
                    zr.getCirculo().setLastNoMatricula(zr.getCirculo()
                            .getLastNoMatricula()
                            + 1);
                }

                if (!cirID.equals(datos.getZonaRegistral().getCirculo()
                        .getIdCirculo())) {
                    throw new DAOException(
                            "El identificador del círculo de la matrícula no coincide con el círculo especificado en la zona registral");
                }

                idCirculo = cirID;
            }

            //Se asocia la zona registral al folio
            datos.setZonaRegistral(zr);

            //Se valida y asocia el estado del folio por defecto (ACTIVO)
            EstadoFolioEnhanced ef;
            EstadoFolioEnhancedPk efId = new EstadoFolioEnhancedPk();
            efId.idEstado = CEstadoFolio.ACTIVO;
            ef = this.getEstadoFolio(efId, pm);

            if (ef == null) {
                throw new DAOException(
                        "No encontró el estado de folio con el ID: "
                        + efId.idEstado);
            }

            datos.setEstado(ef);

            //Se valida y asocia el tipo de predio
            TipoPredioEnhanced tp = datos.getTipoPredio();

            if (tp == null) {
                throw new DAOException(
                        "No existe un tipo de predio asociado con el folio");
            }

            TipoPredioEnhancedPk tpId = new TipoPredioEnhancedPk();
            tpId.idPredio = tp.getIdPredio();
            tp = this.getTipoPredio(tpId, pm);

            if (tp == null) {
                throw new DAOException(
                        "No encontró el tipo de predio con el ID: "
                        + tpId.idPredio);
            }

            datos.setTipoPredio(tp);

            //Se valida y asocia la complementación, si la complementación
            //ya existe en la base de datos se asocia, si no existe se crea
            //la complementación temporal
            ComplementacionEnhanced com = datos.getComplementacion();

            if (com != null) {
                //Si viene una complementacion:
                ComplementacionEnhancedPk comID = new ComplementacionEnhancedPk();
                comID.idComplementacion = com.getIdComplementacion();

                ComplementacionEnhanced comAux = this.getComplementacion(comID,
                        pm);

                if (comAux != null) {
                    //La complementación se debe asociar, sin embargo se
                    //debe buscar si la complementacion ya se encuentra
                    //en estado temporal
                    //TODO
                    ComplementacionTMPPk cidTMP = new ComplementacionTMPPk();
                    cidTMP.idComplementacionTmp = com.getIdComplementacion();

                    ComplementacionTMP temp = this.getComplementacionTMP(cidTMP,
                            pm);

                    if (temp != null) {
                        //ya existe una complementación temporal para la complementación dada
                        //Se setea la complementación temporal
                        temp.setComplementacion(datos.getComplementacion()
                                .getComplementacion());
                        datos.setComplementacionTMP(temp);
                    } else {
                        //Se crea la complementación temporal con la información actual
                        datos.setComplementacionTMP(new ComplementacionTMP(
                                comAux));
                    }
                } else {
                    //La complementación se debe crear
                    com.setComplementacion(datos.getComplementacion()
                            .getComplementacion());

                    //Se obtiene y se bloquea la tabla que provee la secuencia de complementacion
                    com.setIdComplementacion(String.valueOf(this.getSecuencial(
                            CComplementacion.TABLE_NAME, null)));

                    ComplementacionTMP cTMP = new ComplementacionTMP(com);
                    datos.setComplementacionTMP(cTMP);
                }

                datos.setComplementacion(null);
            }

            //Si tiene documento se asocia
            DocumentoEnhanced doc = datos.getDocumento();

            if (doc != null) {
                if (doc.getCirculo() == null) {
                    doc.setCirculo(idCirculo);
                }
                this.setDocumentoToFolio(datos, doc, pm);
            }

            datos.setDefinitivo(false);
            datos.setFechaApertura(new Date());
            datos.setLastIdAnotacion(0);
            datos.setLastIdDireccion(0);
            datos.setLastIdSalvedad(0);
            datos.setLastIdAnotacionTMP(0);
            datos.setLastIdDireccionTMP(0);
            datos.setLastIdSalvedadTMP(0);

            datos.setCirculo(idCirculo);

            //Se crean las direcciones temporales
            List direcciones = datos.getDireccionesTMPs();
            //DireccionTMP direccion;
            //DireccionEnhanced dir;
            /*List lstDireccionesTmp = new ArrayList();
           for (Iterator itr = direcciones.iterator(); itr.hasNext();) {
        	   DireccionTMP direccionE = (DireccionTMP)itr.next();
        	   DireccionTMP direccion = new DireccionTMP();
        	   direccion.setIdDireccionTmp(direccionE.getIdDireccionTmp());
        	   direccion.setEspecificacion(direccionE.getEspecificacion());
        	   direccion.setValorEje(direccionE.getValorEje());
        	   direccion.setValorEje1(direccionE.getValorEje1());
        	   direccion.setEje(direccionE.getEje());
        	   direccion.setEje1(direccionE.getEje1());
        	   direccion.setToDelete(direccionE.isToDelete());
        	   lstDireccionesTmp.add(direccion);
              
           }*/

            //datos.getDireccionesTMPs().removeAll(datos.getDireccionesTMPs());
            //datos.removeAllDirecciones();
            for (Iterator itr = direcciones.iterator(); itr.hasNext();) {
                DireccionTMP direccionADDF = (DireccionTMP) itr.next();
                //datos.addDireccionesTMP(direccionADDF); 
                this.addDireccionTMPToFolio(datos, direccionADDF, usuario, pm);
            }

            //Se quitan las direcciones de definitivo
            datos.removeAllDirecciones();
            List lstSalvedadesTmp = datos.getSalvedadesTMPs();
            //Se crean las salvedades temporales

            for (Iterator itr = lstSalvedadesTmp.iterator(); itr.hasNext();) {
                SalvedadFolioTMP salvedadTMPE = (SalvedadFolioTMP) itr.next();
                //datos.addSalvedadesTMP(salvedadTMPE);
                this.addSalvedadTMPToFolio(datos, salvedadTMPE, usuario, pm);
            }

            //se quitan las salvedades de definitivo
            datos.removeAllSalvedades();

            //Se crean las anotaciones temporales
            List anotaciones = datos.getAnotaciones();
            AnotacionTMP anotacion;
            AnotacionEnhanced anota;
            List cache;

            //Se agregan anotaciones temporales en caso
            //que se manden explicitamente en la lista
            //de anotaciones temporales
            List anotacionesTMP = datos.getAnotacionesTMPs();

            for (Iterator itr = anotacionesTMP.iterator(); itr.hasNext();) {
                anotacion = (AnotacionTMP) itr.next();

                //Se le quita el ID para que se asigne un ID automático
                anotacion.setIdAnotacionTmp(null);
                anotacion.setOrden(String.valueOf(this.getNextOrdenAnotacion(datos, pm)));

                this.addAnotacionTMPToFolio(datos, anotacion, usuario, turno, pm);
            }

            List listAnotaSave = new ArrayList();
            if (anotaciones != null) {
                listAnotaSave.addAll(anotaciones);
                datos.removeAllAnotaciones();
            }
            Iterator itr = listAnotaSave.iterator();
            while (itr.hasNext() && !listAnotaSave.isEmpty()) {
                cache = new ArrayList();
                anota = (AnotacionEnhanced) itr.next();
                if (anota.isTemporal()) {
                    anotacion = new AnotacionTMP(anota, cache, true);
                    if (anotacion.getAnotacionesPadreTMPs() != null && !anotacion.getAnotacionesPadreTMPs().isEmpty()) {
                        Iterator iteraFlDirivePadreTMP = anotacion.getAnotacionesPadreTMPs().iterator();
                        while (iteraFlDirivePadreTMP.hasNext()) {
                            FolioDerivadoTMP folioDerivePadreTMP = (FolioDerivadoTMP) iteraFlDirivePadreTMP.next();
                            folioDerivePadreTMP.setIdMatricula1(datos.getIdMatricula());
                        }
                    }
                    datos.addAnotacionesTMP(anotacion);
                    this.addAnotacionTMPToFolio(datos, anotacion, usuario, turno, pm);
                } else {
                    if (anota.getAnotacionesPadre() != null && !anota.getAnotacionesPadre().isEmpty()) {
                        Iterator iteraFlDirivePadre = anota.getAnotacionesPadre().iterator();
                        while (iteraFlDirivePadre.hasNext()) {
                            FolioDerivadoEnhanced folioDerivePadre = (FolioDerivadoEnhanced) iteraFlDirivePadre.next();
                            folioDerivePadre.setIdMatricula1(datos.getIdMatricula());
                            //pm.makePersistent(folioDerivePadre);
                        }
                    }
                    datos.addAnotacione(anota);
                    this.addAnotacionToFolio(datos, anota, null, null, false, pm);
                    anota.setUsuarioCreacionTMP(null);
                    anota.setUsuarioCreacion(usuario);
                }
            }

//         Se asocian los datos temporales del folio
            if (datos.getDatosTMP() != null) {
                datos.getDatosTMP().setIdMatricula(datos.getIdMatricula());
            }

            //datos.removeAllAnotaciones();
            //Se valida y se crea la asociación con el turno
            if (validarTurno) {
                if (datos.getTurnosFolios().size() == 0) {
                    throw new DAOException(
                            "No existe un turno asociado para crear el folio");
                } else if ((TurnoFolioEnhanced) datos.getTurnosFolios().get(0) == null) {
                    throw new DAOException(
                            "No existe un turno asociado para crear el folio");
                } else {
                    if (datos.getTurnosFolios().size() > 1) {
                        Log.getInstance().debug(JDOGenieFolioDAO.class, "Turno tiene (DAO - private -TF)" + datos.getTurnosFolios().size());
                        throw new DAOException("No puede asociar varios TurnosFolios al folio");
                    }

                    TurnoFolioEnhanced tf = (TurnoFolioEnhanced) datos.getTurnosFolios()
                            .get(0);
                    addTurnoFolioToFolio(datos, tf, pm);
                }
            }

            //Se setea el suaurio creador:
            datos.setUsuarioCreacion(usuario);

            pm.makePersistent(datos);

            //pm.makePersistentAll(listAnotaSave);
            return true;
        } catch (DAOException e) {
            if (pm2 != null && !pm2.isClosed()) {
                pm2.setDatastoreTxLocking(VersantPersistenceManager.LOCKING_NONE);
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw e;
        } catch (JDOException e) {
            if (pm2 != null && !pm2.isClosed()) {
                pm2.setDatastoreTxLocking(VersantPersistenceManager.LOCKING_NONE);
            }
            DAOException daoe = new DAOException(e.getMessage(), e);
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw daoe;
        }

    }

    /**
     * Crea un folio. Si el idMatricula del folio es nulo el sistema asigna el
     * siguiente número disponible dentro del círculo. Si el idMatricula no es
     * nulo se crea el folio con el número especificado. Si el número
     * especificado corresponde a un folio existente en el círculo se lanza un
     * DAOException
     *
     * @param datos objeto Folio que debe contener codCatastral y sus objetos
     * ZonaRegistral, estado, lindero y tipoPredio. Si la complementación existe
     * se asocia, si no se crea. Recibe la lista de anotaciones,
     * @return objeto Folio con el número de matrícula asignado
     * @throws DAOException
     */
    public Folio crearFolio(Folio folio, Usuario us, TurnoPk oid, boolean validarTurno) throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();

        FolioEnhanced fe = new FolioEnhanced();

        UsuarioEnhanced usuario;

        UsuarioEnhancedPk usId = new UsuarioEnhancedPk();
        usId.idUsuario = us.getIdUsuario();

        TurnoEnhancedPk toid = new TurnoEnhancedPk();
        TurnoEnhanced turno = null;

        if (oid != null) {
            toid.anio = oid.anio;
            toid.idCirculo = oid.idCirculo;
            toid.idProceso = oid.idProceso;
            toid.idTurno = oid.idTurno;
            turno = this.getTurnoByID(toid, pm);
        }

        try {
            pm.currentTransaction().setOptimistic(false);
            pm.currentTransaction().begin();

            usuario = this.getUsuarioByID(usId, pm);

            if (us == null) {
                throw new DAOException("El usuario especificado no existe");
            }

            fe = FolioEnhanced.enhance(folio);
            this.crearFolio(fe, usuario, pm, turno, validarTurno);
            //El flag en true del anterior método nos asegura la siguiente linea
            if (validarTurno) {
                TurnoFolioEnhanced turnoF = (TurnoFolioEnhanced) fe.getTurnosFolios().get(0);

                //Se bloquea el folio al usuario que lo creó
                LlaveBloqueoEnhanced llave = this.crearLlaveBloqueo(pm);
                BloqueoFolioEnhanced bf = new BloqueoFolioEnhanced();
                bf.setFechaBloqueo(new Date());
                bf.setFolio(fe);
                bf.setLlaveBloqueo(llave);
                bf.setIdWorkflowBloqueo(turnoF.getTurno().getIdWorkflow());
                pm.makePersistent(bf);
                usuario.addLlavesBloqueo(llave);
            }
            pm.currentTransaction().commit();
            this.makeTransientFolioTMP(fe, pm);
        } catch (DAOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            e.addError(e.getMessage());
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw e;
        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            DAOException daoe = new DAOException(e.getMessage(), e);
            daoe.addError(e.getMessage());
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw daoe;
        } catch (Throwable e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            DAOException daoe = new DAOException(e.getMessage(), e);
            daoe.addError(e.getMessage());
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw daoe;
        } finally {
            pm.close();
        }

        return this.getMaskedFolio(fe);
    }

    /**
     * Crea un folio con tdas las asociaciones para el proceso de las
     * segregaciones . Si el idMatricula del folio es nulo el sistema asigna el
     * siguiente número disponible dentro del círculo. Si el idMatricula no es
     * nulo se crea el folio con el número especificado. Si el número
     * especificado corresponde a un folio existente en el círculo se lanza un
     * DAOException
     *
     * @param datos objeto Folio que debe contener codCatastral y sus objetos
     * ZonaRegistral, estado, lindero y tipoPredio. Si la complementación existe
     * se asocia, si no se crea. Recibe la lista de anotaciones,
     * @return objeto Folio con el número de matrícula asignado
     * @throws DAOException
     */
    public Folio crearFolioSegeng(Folio folio, Usuario us, TurnoPk oid, boolean validarTurno, Folio folioB) throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        FolioEnhanced datos = FolioEnhanced.enhance(folio);
        FolioEnhanced fe = new FolioEnhanced();

        Folio rta = null;
        UsuarioEnhanced usuario;

        UsuarioEnhancedPk usId = new UsuarioEnhancedPk();
        usId.idUsuario = us.getIdUsuario();

        TurnoEnhancedPk toid = new TurnoEnhancedPk();
        TurnoEnhanced turno = null;

        if (oid != null) {
            toid.anio = oid.anio;
            toid.idCirculo = oid.idCirculo;
            toid.idProceso = oid.idProceso;
            toid.idTurno = oid.idTurno;
            turno = this.getTurnoByID(toid, pm);
        }

        try {
            pm.currentTransaction().setOptimistic(false);
            pm.currentTransaction().begin();

            usuario = this.getUsuarioByID(usId, pm);

            if (us == null) {
                throw new DAOException("El usuario especificado no existe");
            }

//          Obtenemos el folio persistente correspondiente a la informacion
            // temporal
            FolioEnhanced folioE;
            FolioEnhancedPk fid = new FolioEnhancedPk();
            fid.idMatricula = folioB.getIdMatricula();

            folioE = this.getFolioByID(fid, pm);

            List DirTmps = new ArrayList();
            List SalTmps = new ArrayList();
            if (folioE != null && folioE.getDireccionesTMPs() != null && !folioE.getDireccionesTMPs().isEmpty()) {
                Iterator iteraAnotaTmp = folioE.getDireccionesTMPs().iterator();
                while (iteraAnotaTmp.hasNext()) {
                    DireccionTMP direccionE = (DireccionTMP) iteraAnotaTmp.next();
                    DireccionTMP direccion = new DireccionTMP();
                    direccion.setIdDireccionTmp(direccionE.getIdDireccionTmp());
                    direccion.setEspecificacion(direccionE.getEspecificacion());
                    direccion.setValorEje(direccionE.getValorEje());
                    direccion.setValorEje1(direccionE.getValorEje1());
                    direccion.setEje(direccionE.getEje());
                    direccion.setEje1(direccionE.getEje1());
                    direccion.setToDelete(direccionE.isToDelete());
                    DirTmps.add(direccion);
                }
            }
            if (folioE != null && folioE.getSalvedadesTMPs() != null && !folioE.getSalvedadesTMPs().isEmpty()) {
                Iterator iteraSalvedadTmp = folioE.getSalvedadesTMPs().iterator();
                while (iteraSalvedadTmp.hasNext()) {

                    SalvedadFolioTMP salvedadTMPE = (SalvedadFolioTMP) iteraSalvedadTmp.next();
                    SalvedadFolioTMP salvedadTMP = new SalvedadFolioTMP();

                    salvedadTMP.setIdSalvedadFoTmp(salvedadTMPE.getIdSalvedadFoTmp());
                    salvedadTMP.setDescripcion(salvedadTMPE.getDescripcion());
                    salvedadTMP.setFechaCreacion(salvedadTMPE.getFechaCreacion());
                    salvedadTMP.setNumRadicacion(salvedadTMPE.getNumRadicacion());
                    SalTmps.add(salvedadTMP);
                }
            }

            //Se busca si existe información en datos temporales
            //para deshacerla
            FolioDatosTMP dTMP = null;
            /*si exite informacion temporal se asocia ya que esta no se deja
	         * cambiar el id por estar atada a el viejo id en la persistencia*/

            FolioDatosTMP dTMPSinUP = new FolioDatosTMP();
            try {
                if (folioE != null) {
                    dTMP = folioE.getDatosTMP();
                    dTMPSinUP.setCodCatastral(dTMP.getCodCatastral());
                    dTMPSinUP.setCodCatastralAnterior(dTMP.getCodCatastralAnterior());
                    dTMPSinUP.setEstado(dTMP.getEstado());
                    dTMPSinUP.setFechaApertura(dTMP.getFechaApertura());
                    dTMPSinUP.setLindero(dTMP.getLindero());
                    dTMPSinUP.setNupre(dTMP.getNupre());
                    dTMPSinUP.setDeterminaInm(dTMP.getDeterminaInm());
                    dTMPSinUP.setPrivMetros(dTMP.getPrivMetros());
                    dTMPSinUP.setPrivCentimetros(dTMP.getPrivCentimetros());
                    dTMPSinUP.setConsMetros(dTMP.getConsMetros());
                    dTMPSinUP.setConsCentimetros(dTMP.getConsCentimetros());
                    dTMPSinUP.setCoeficiente(dTMP.getCoeficiente());
                    dTMPSinUP.setHectareas(dTMP.getHectareas());
                    dTMPSinUP.setMetros(dTMP.getMetros());
                    dTMPSinUP.setCentimetros(dTMP.getCentimetros());
                    dTMPSinUP.setNumRadicaCodCatastral(dTMP.getNumRadicaCodCatastral());
                    dTMPSinUP.setNumRadicaCodCatastralAnterior(dTMP.getNumRadicaCodCatastralAnterior());
                    dTMPSinUP.setNumRadicaEstado(dTMP.getNumRadicaEstado());
                    dTMPSinUP.setNumRadicaFechaApertura(dTMP.getNumRadicaFechaApertura());
                    dTMPSinUP.setNumRadicaLindero(dTMP.getNumRadicaLindero());
                    dTMPSinUP.setNumRadicaNupre(dTMP.getNumRadicaNupre());
                    dTMPSinUP.setNumRadicaDeterminaInm(dTMP.getNumRadicaDeterminaInm());
                    dTMPSinUP.setNumRadicaPrivMetros(dTMP.getNumRadicaPrivMetros());
                    dTMPSinUP.setNumRadicaPrivCentimetros(dTMP.getNumRadicaPrivCentimetros());
                    dTMPSinUP.setNumRadicaConsMetros(dTMP.getNumRadicaConsMetros());
                    dTMPSinUP.setNumRadicaConsCentimetros(dTMP.getNumRadicaConsCentimetros());
                    dTMPSinUP.setNumRadicaCoeficiente(dTMP.getNumRadicaCoeficiente());
                    dTMPSinUP.setNumRadicaHectareas(dTMP.getNumRadicaHectareas());
                    dTMPSinUP.setNumRadicaMetros(dTMP.getNumRadicaMetros());
                    dTMPSinUP.setNumRadicaCentimetros(dTMP.getNumRadicaCentimetros());
                    dTMPSinUP.setNumRadicaRadicacion(dTMP.getNumRadicaRadicacion());
                    dTMPSinUP.setNumRadicaTipoPredio(dTMP.getNumRadicaTipoPredio());
                    dTMPSinUP.setNumRadicaZonaRegistral(dTMP.getNumRadicaZonaRegistral());
                    dTMPSinUP.setRadicacion(dTMP.getRadicacion());
                    dTMPSinUP.setTipoPredio(dTMP.getTipoPredio());
                    dTMPSinUP.setZonaRegistral(dTMP.getZonaRegistral());
//	    			se el quitan los ids a la informacion temporal
                    //dTMP.setIdMatricula(null);
                }
            } catch (JDOObjectNotFoundException e) {
                dTMP = null;
            }

            fe = FolioEnhanced.enhance(folio);
            fe.setDatosTMP(dTMPSinUP);

            if (DirTmps != null && !DirTmps.isEmpty()) {
                Iterator iteraAnotaTmp = DirTmps.iterator();
                while (iteraAnotaTmp.hasNext()) {
                    DireccionTMP dirTmp = (DireccionTMP) iteraAnotaTmp.next();
                    if (fe.getDireccionesTMPs() != null && dirTmp != null) {
                        //dirTmp.setIdMatricula(null);
                        fe.addDireccionesTMP(dirTmp);
                    }
                }
            }
            if (SalTmps != null && !SalTmps.isEmpty()) {
                Iterator iteraSalvedadTmp = SalTmps.iterator();
                while (iteraSalvedadTmp.hasNext()) {
                    SalvedadFolioTMP salTmp = (SalvedadFolioTMP) iteraSalvedadTmp.next();
                    if (fe.getSalvedadesTMPs() != null && salTmp != null) {
                        //salTmp.setIdMatricula(null);
                        fe.addSalvedadesTMP(salTmp);
                    }
                }
            }

            this.crearFolioSegeng(fe, usuario, pm, turno, validarTurno);

            //El flag en true del anterior método nos asegura la siguiente linea
            if (validarTurno) {
                TurnoFolioEnhanced turnoF = (TurnoFolioEnhanced) fe.getTurnosFolios().get(0);

                //Se bloquea el folio al usuario que lo creó
                LlaveBloqueoEnhanced llave = this.crearLlaveBloqueo(pm);
                BloqueoFolioEnhanced bf = new BloqueoFolioEnhanced();
                bf.setFechaBloqueo(new Date());
                bf.setFolio(fe);
                bf.setLlaveBloqueo(llave);
                bf.setIdWorkflowBloqueo(turnoF.getTurno().getIdWorkflow());
                pm.makePersistent(bf);
                usuario.addLlavesBloqueo(llave);
            }

            if (fe != null && fe.getIdMatricula() != null && turno != null
                    && turno.getSolicitud() != null && turno.getSolicitud().getIdSolicitud() != null) {
                SolicitudFolioEnhanced sf = new SolicitudFolioEnhanced();

                sf.setFolio(fe);
                sf.setIdMatricula(fe.getIdMatricula());
                //SolicitudEnhanced se = new SolicitudEnhanced(); 			
                sf.setSolicitud(turno.getSolicitud());
                sf.setIdSolicitud(turno.getSolicitud().getIdSolicitud());
                sf.setCirculo(datos.getCirculo() != null ? datos.getCirculo() : null);
                sf.setUsuario(usuario);
                sf.setEstado(0);
                pm.makePersistent(sf);

            }

            /*
			 * Borrado del folio auxiliar traido desdes ancorreccion con el fin de que este en el persisten manager
			 * y asi garantizar que el folio sea creado nuevo sea creado cuando se halla borrado el viejo
			 * 
             */
            this.eliminarFolioSegregacion(folioB, us, turno, pm);

            if (folio != null) {
                folio.setIdMatricula(fe.getIdMatricula());
                if (folio.getSalvedades() != null
                        && !folio.getSalvedades().isEmpty()) {
                    Iterator iteraSalvedades = folio.getSalvedades().iterator();
                    while (iteraSalvedades.hasNext()) {
                        SalvedadFolio salvedadFolio = (SalvedadFolio) iteraSalvedades.next();
                        salvedadFolio.setIdMatricula(fe.getIdMatricula());
                    }
                }
                if (folio.getDirecciones() != null
                        && !folio.getDirecciones().isEmpty()) {
                    Iterator iteraDirecciones = folio.getDirecciones().iterator();
                    while (iteraDirecciones.hasNext()) {
                        Direccion direccion = (Direccion) iteraDirecciones.next();
                        direccion.setIdMatricula(fe.getIdMatricula());
                    }
                }

                if (folio.getHistorialEstados() != null
                        && !folio.getHistorialEstados().isEmpty()) {
                    Iterator iteraEstadosHisto = folio.getHistorialEstados().iterator();
                    while (iteraEstadosHisto.hasNext()) {
                        EstadoHistoria estadoHistoria = (EstadoHistoria) iteraEstadosHisto.next();
                        estadoHistoria.setIdMatricula(fe.getIdMatricula());
                    }
                }

                /*se devuelve el folio*/
                folio.setAnotaciones(new ArrayList());
                /*if(folio.getAnotaciones() != null){
					Iterator iteralstAnota = folio.getAnotaciones().iterator();*/

 /* validaciones para las anotaciones del nuevo folio a guardar
					 * */
 /*while (iteralstAnota.hasNext()){
						Anotacion anotacion = (Anotacion)iteralstAnota.next();
						
						if(anotacion != null && anotacion.getAnotacionesPadre() != null
							&& !anotacion.getAnotacionesPadre().isEmpty()){
							Iterator iteralstFolioDerive = anotacion.getAnotacionesPadre().iterator();
							while (iteralstFolioDerive.hasNext()){
								FolioDerivado folioDerivado = (FolioDerivado)iteralstFolioDerive.next();
								folioDerivado.setIdMatricula1(fe.getIdMatricula());								
							}
						}
						
						anotacion.setIdMatricula(null);
						if(anotacion != null && anotacion.getAnotacionesCancelacions() != null
							&& !anotacion.getAnotacionesCancelacions().isEmpty()){
							Iterator iteralstAnotaCancel = anotacion.getAnotacionesCancelacions().iterator();
							while (iteralstAnotaCancel.hasNext()){
								Cancelacion cancelacion = (Cancelacion)iteralstAnotaCancel.next();
								cancelacion.setIdMatricula(fe.getIdMatricula());
							}
						}
						if(anotacion != null && anotacion.getAnotacionesCiudadanos() != null
							&& !anotacion.getAnotacionesCiudadanos().isEmpty()){
							Iterator iteralstAnotaCiudad = anotacion.getAnotacionesCiudadanos().iterator();
							while (iteralstAnotaCiudad.hasNext()){
								AnotacionCiudadano anotacionCiudadano = (AnotacionCiudadano)iteralstAnotaCiudad.next();
								anotacionCiudadano.setIdMatricula(fe.getIdMatricula());
							}
						}
						if(anotacion != null && anotacion.getAnotacionesHijos() != null
							&& !anotacion.getAnotacionesHijos().isEmpty()){
							Iterator iteralstAnotaHijo = anotacion.getAnotacionesHijos().iterator();
							while (iteralstAnotaHijo.hasNext()){
								FolioDerivado flDerivado = (FolioDerivado)iteralstAnotaHijo.next();
								flDerivado.setIdMatricula(fe.getIdMatricula());
							}
						}
						if(anotacion != null && anotacion.getAnotacionesPadre() != null
							&& !anotacion.getAnotacionesPadre().isEmpty()){
							Iterator iteralstAnotaPadre = anotacion.getAnotacionesPadre().iterator();
							while (iteralstAnotaPadre.hasNext()){
								FolioDerivado flDerivado = (FolioDerivado)iteralstAnotaPadre.next();
								flDerivado.setIdMatricula1(fe.getIdMatricula());
							}
						}
						if(anotacion != null && anotacion.getSalvedades() != null
							&& !anotacion.getSalvedades().isEmpty()){
							Iterator iteralstSalvedades = anotacion.getSalvedades().iterator();
							while (iteralstSalvedades.hasNext()){
								SalvedadAnotacion salveadAnotacion = (SalvedadAnotacion)iteralstSalvedades.next();
								salveadAnotacion.setIdMatricula(fe.getIdMatricula());
							}
						}
					}
				}*/
            }

            /**/
            pm.currentTransaction().commit();
            //this.makeTransientFolioTMP(fe, pm);
            //rta = this.getMaskedFolio(fe);
        } catch (DAOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            e.addError(e.getMessage());
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw e;
        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            DAOException daoe = new DAOException(e.getMessage(), e);
            daoe.addError(e.getMessage());
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw daoe;
        } catch (Throwable e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            DAOException daoe = new DAOException(e.getMessage(), e);
            daoe.addError(e.getMessage());
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw daoe;
        } finally {
            pm.close();
        }
        return folio;
    }

    /**
     * Valida la información del folio antes de crearlo. Si existe por lo menos
     * un error lanza un DAOException Los errores son listados en DAOException
     *
     * @param datos
     * @throws DAOException
     */
    public void validarCrearFolio(Folio folio, boolean validarTurno) throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        JDOGenieZonaRegistralDAO zonaRegistralDAO = new JDOGenieZonaRegistralDAO();
        FolioEnhancedPk rta = new FolioEnhancedPk();
        FolioEnhanced val = null;
        FolioEnhanced datos = FolioEnhanced.enhance(folio);
        DAOException exc = new DAOException(
                "Fallo en validación de creación de folio");

        if (datos.getZonaRegistral() == null) {
            exc.addError("El folio no tiene zona registral");
        } else {
            if (datos.getZonaRegistral().getCirculo() == null) {
                exc.addError("La zona registral no tiene el círculo asociado");
            } else if (datos.getZonaRegistral().getVereda() == null) {
                exc.addError("La zona registral no tiene la vereda asociada");
            } else {
                Log.getInstance().debug(JDOGenieFolioDAO.class, "ZONA REGISTRAL CIRCULO: " + datos.getZonaRegistral().getCirculo().getIdCirculo());
                Log.getInstance().debug(JDOGenieFolioDAO.class, "ZONA REGISTRAL VEREDA: " + datos.getZonaRegistral().getVereda().getIdVereda());
                ZonaRegistralEnhanced zrTMP = zonaRegistralDAO.getZonaRegistralByCirculoVereda(datos.getZonaRegistral()
                        .getCirculo(),
                        datos.getZonaRegistral().getVereda(), pm);

                if (zrTMP == null) {
                    exc.addError(
                            "La zona registral del círculo y la vereda no existe");
                }

                if ((datos.getIdMatricula() != null)) {
                    StringTokenizer st = new StringTokenizer(datos.getIdMatricula(),
                            "-");
                    String cirID = st.nextToken();
                    String secuencial = st.nextToken();

                    long sec = Long.parseLong(secuencial);

                    if (!cirID.equals(datos.getZonaRegistral().getCirculo()
                            .getIdCirculo())) {
                        exc.addError(
                                "El identificador del círculo de la matrícula no coincide con el círculo especificado en la zona registral");
                    } else {
                        if ((zrTMP.getCirculo().getLastNoMatricula() + 1) < sec) {
                            exc.addError(
                                    "El número de matrícula especificado supera la secuencia del círculo");
                        }

                        val = this.getFolioByMatriculaIncluyendoObsoletos(datos.getIdMatricula(),
                                pm);

                        if (val != null) {
                            if (val.getEstado().getIdEstado().equals(CEstadoFolio.OBSOLETO)) {
                                exc.addError(
                                        "El número de matrícula especificado ya fue utilizado para un folio");
                            } else if (!val.isDefinitivo()) {
                                exc.addError(
                                        "El número de matrícula ya fue utilizado para un folio temporal");
                            } else {
                                exc.addError(
                                        "El folio con el número de matrícula especificado ya existe");
                            }
                        }
                    }
                }
            }
        }

        if (datos.getEstado() != null) {
            EstadoFolioEnhanced ef = datos.getEstado();
            EstadoFolioEnhancedPk efId = new EstadoFolioEnhancedPk();
            efId.idEstado = ef.getIdEstado();
            ef = this.getEstadoFolio(efId, pm);

            if (ef == null) {
                exc.addError("No encontró el estado de folio con el ID: "
                        + efId.idEstado);
            }
        }

        if (datos.getTipoPredio() == null) {
            exc.addError("El folio debe tener tipo de predio");
        } else {
            TipoPredioEnhanced tp = datos.getTipoPredio();
            TipoPredioEnhancedPk tpId = new TipoPredioEnhancedPk();
            tpId.idPredio = tp.getIdPredio();
            tp = this.getTipoPredio(tpId, pm);

            if (tp == null) {
                exc.addError("No encontró el tipo de predio con el ID: "
                        + tpId.idPredio);
            }
        }

        if (datos.getDocumento() != null) {
            DocumentoEnhanced doc = datos.getDocumento();

            if (doc.getIdDocumento() != null) {
                DocumentoEnhancedPk docId = new DocumentoEnhancedPk();
                docId.idDocumento = doc.getIdDocumento();
                doc = this.getDocumento(docId, pm);

                if (doc == null) {
                    exc.addError("No encontró el documento con el ID: "
                            + docId.idDocumento);
                }
            }
        }

        if (validarTurno) {
            if (datos.getTurnosFolios().size() == 0) {
                exc.addError("No existe un turno asociado para crear el folio");
            } else if ((TurnoFolioEnhanced) datos.getTurnosFolios().get(0) == null) {
                exc.addError("No existe un turno asociado para crear el folio");
            } else {
                TurnoEnhanced t = ((TurnoFolioEnhanced) datos.getTurnosFolios().get(0)).getTurno();

                if (t == null) {
                    exc.addError("El turno de creación es nulo");
                } else {
                    TurnoEnhanced aux;
                    TurnoEnhancedPk tid = new TurnoEnhancedPk();
                    tid.anio = t.getAnio();
                    tid.idCirculo = t.getIdCirculo();
                    tid.idProceso = t.getIdProceso();
                    tid.idTurno = t.getIdTurno();
                    aux = this.getTurnoByID(tid, pm);

                    if (aux == null) {
                        exc.addError("El turno especificado no existe");
                    }
                }
            }
        }

        List direcciones = datos.getDirecciones();
        DireccionEnhanced dir = null;

        int indice = 1;

        for (Iterator itr = direcciones.iterator(); itr.hasNext(); indice++) {
            dir = (DireccionEnhanced) itr.next();

            try {
                this.validarDireccion(dir, indice, pm);
            } catch (DAOException e) {
                exc.appendErrores(e.getErrores());
            }
        }

        List anotaciones = datos.getAnotaciones();
        AnotacionEnhanced anota = null;

        indice = 1;

        for (Iterator itr = anotaciones.iterator(); itr.hasNext(); indice++) {
            anota = (AnotacionEnhanced) itr.next();

            try {
                this.validarAnotacion(anota, indice, pm);
            } catch (DAOException e) {
                exc.appendErrores(e.getErrores());
            }
        }

        if (exc.getErrores().size() > 0) {
            throw exc;
        }
    }

    /**
     * @param dir
     * @param indice
     * @param pm
     */
    protected void validarAnotacion(AnotacionEnhanced datos, int indice,
            PersistenceManager pm) throws DAOException {
        JDOGenieZonaRegistralDAO zonaRegistralDAO = new JDOGenieZonaRegistralDAO();
        DAOException exc = new DAOException(
                "Fallo en validación de creación de direccion");

        if (datos.getEstado() != null) {
            EstadoAnotacionEnhancedPk eId = new EstadoAnotacionEnhancedPk();
            eId.idEstadoAn = datos.getEstado().getIdEstadoAn();

            EstadoAnotacionEnhanced estado = this.getEstadoAnotacion(eId, pm);

            if (estado == null) {
                exc.addError("No encontró el estado de la anotación " + indice
                        + " con el ID: " + eId.idEstadoAn);
            }
        }

        if (datos.getNaturalezaJuridica() == null) {
            exc.addError("La anotación" + indice
                    + " debe tener naturaleza jurídica");
        } else {
            NaturalezaJuridicaEnhancedPk njId = new NaturalezaJuridicaEnhancedPk();
            njId.idNaturalezaJuridica = datos.getNaturalezaJuridica()
                    .getIdNaturalezaJuridica();
            /*
        *  @author Carlos Torres
        *  @chage   se asigna valor a la propiedad version
        *  @mantis 12705: Acta - Requerimiento No 056_453_Modificiación_de_Naturaleza_Jurídica
             */
            njId.version = datos.getNaturalezaJuridica().getVersion();

            NaturalezaJuridicaEnhanced naturaleza = this.getNaturalezaJuridica(njId,
                    pm);

            if (naturaleza == null) {
                exc.addError(
                        "No encontró la naturaleza jurídica de la anotación "
                        + indice + " con el ID: " + njId.idNaturalezaJuridica);
            }
        }

        /*
        if (datos.getTipoAnotacion() == null) {
        exc.addError("La anotación " + indice +
        " debe tener tipo de anotación");
        } else {
        TipoAnotacion.ID taId = new TipoAnotacion.ID();
        taId.idTipoAnotacion = datos.getTipoAnotacion().getIdTipoAnotacion();

        TipoAnotacion tipoAnota = this.getTipoAnotacion(taId, pm);

        if (tipoAnota == null) {
        exc.addError("No encontró el tipo de la anotación " + indice +
        " con el ID: " + taId.idTipoAnotacion);
        }
        }
         */
        DocumentoEnhanced doc = datos.getDocumento();

        if (doc != null) {
            if (doc.getOficinaOrigen() == null && doc.getComentario() == null && doc.getOficinaInternacional() == null) {
                exc.addError("El documento de la anotacion " + indice
                        + " debe tener oficina origen");
            } else {
                if (doc.getOficinaOrigen() != null) {
                    OficinaOrigenEnhancedPk ofid = new OficinaOrigenEnhancedPk();
                    ofid.idOficinaOrigen = doc.getOficinaOrigen()
                            .getIdOficinaOrigen();
                    /*
                      *  @author Carlos Torres
                      *  @chage   se agrega validacion de version diferente
                      *  @mantis 0013414: Acta - Requerimiento No 069_453_Código_Notaria_NC
                     */
                    ofid.version = doc.getOficinaOrigen().getVersion();

                    OficinaOrigenEnhanced oficina = zonaRegistralDAO.getOficinaOrigen(ofid,
                            pm);

                    if (oficina == null) {
                        exc.addError(
                                "La oficina origen del documento de la anotación "
                                + indice + " no existe. IdOficina: "
                                + ofid.idOficinaOrigen);
                    }
                }
            }

            if (doc.getTipoDocumento() == null) {
                exc.addError("El documento de la anotación " + indice
                        + " debe tener tipo de documento");
            } else {
                TipoDocumentoEnhancedPk tdid = new TipoDocumentoEnhancedPk();
                tdid.idTipoDocumento = doc.getTipoDocumento()
                        .getIdTipoDocumento();

                TipoDocumentoEnhanced tipoDoc = this.getTipoDocumento(tdid, pm);

                if (tipoDoc == null) {
                    exc.addError("El tipo del documento de la anotación "
                            + indice + " no existe. IdTipoDocumento: "
                            + tdid.idTipoDocumento);
                }
            }
        }

        if (exc.getErrores().size() > 0) {
            throw exc;
        }
    }

    /**
     * @param dir
     * @param indice
     * @param pm
     */
    protected void validarDireccion(DireccionEnhanced datos, int indice,
            PersistenceManager pm) throws DAOException {
        JDOGenieZonaRegistralDAO zonaRegistralDAO = new JDOGenieZonaRegistralDAO();

        DireccionEnhancedPk rta = new DireccionEnhancedPk();
        DireccionEnhanced val = null;

        DAOException exc = new DAOException(
                "Fallo en validación de creación de direccion");

        EjeEnhanced eje = datos.getEje();

        if (eje == null) {
            exc.addError("La direccion " + indice
                    + " debe tener el primer eje asociado");
        } else {
            EjeEnhancedPk ejeId = new EjeEnhancedPk();
            ejeId.idEje = eje.getIdEje();
            eje = zonaRegistralDAO.getEje(ejeId, pm);

            if (eje == null) {
                exc.addError("No encontró el primer eje de la dirección"
                        + indice + " con el ID: " + ejeId.idEje);
            }
        }

        if (datos.getEje1() != null) {
            EjeEnhanced eje1 = datos.getEje1();
            EjeEnhancedPk eje1Id = new EjeEnhancedPk();
            eje1Id.idEje = eje1.getIdEje();
            eje1 = zonaRegistralDAO.getEje(eje1Id, pm);

            if (eje1 == null) {
                exc.addError("No encontró el segundo eje de la dirección"
                        + indice + " con el ID: " + eje1Id.idEje);
            }
        }

        if (exc.getErrores().size() > 0) {
            throw exc;
        }
    }

    /**
     * Obtiene una lista con todos los posibles estados de un folio configurados
     * en el sistema
     *
     * @return lista de objetos EstadoFolio
     * @see gov.sir.core.negocio.modelo.EstadoFolio
     * @throws DAOException
     */
    public List getEstadosFolio() throws DAOException {
        List rta = null;
        PersistenceManager pm = AdministradorPM.getPM();

        try {
            rta = this.getEstadosFolio(pm);
            pm.makeTransientAll(rta);
        } catch (DAOException e) {
            throw e;
        } finally {
            pm.close();
        }

        return TransferUtils.makeTransferAll(rta);
    }

    /**
     * Obtiene una lista de estados Folio de la configuración del sistema
     *
     * @return lista de objetos EstadoFolio
     * @see gov.sir.core.negocio.modelo.EstadoFolio
     * @throws DAOException
     *
     * AHERRENO 25/01/2013 Requerimiento No 039_453 Validaciones_Folios
     * _Estado_Bloqueado Se agregar condicion query.setFilter("idEstado !=
     * 'B'");
     */
    protected List getEstadosFolio(PersistenceManager pm)
            throws DAOException {
        try {
            Query query = pm.newQuery(EstadoFolioEnhanced.class);
            query.setFilter("idEstado != 'B'");
            query.setOrdering("nombre ascending");

            List rta = (List) query.execute();

            return rta;
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }
    }

    /**
     * Obtiene un EstadoFolio dado su identificador
     *
     * @param oid
     * @return objeto EstadoFolio
     * @throws DAOException
     */
    public EstadoFolio getEstadoFolio(EstadoFolioPk oid)
            throws DAOException {
        EstadoFolioEnhanced ef = null;
        PersistenceManager pm = AdministradorPM.getPM();
        EstadoFolio aux = null;

        try {
            ef = this.getEstadoFolio(new EstadoFolioEnhancedPk(oid), pm);
            pm.makeTransient(ef);
        } catch (DAOException e) {
            throw e;
        } finally {
            pm.close();
        }

        if (ef != null) {
            aux = (EstadoFolio) ef.toTransferObject();
        }

        return aux;
    }

    /**
     * Obtiene un EstadoFolio dado su identificador, método usado en
     * transacciones se debe dar el PersistenceManager
     *
     * @param oid
     * @return objeto EstadoFolio
     * @throws DAOException
     */
    protected EstadoFolioEnhanced getEstadoFolio(EstadoFolioEnhancedPk oid,
            PersistenceManager pm) throws DAOException {
        EstadoFolioEnhanced rta = null;

        if (oid.idEstado != null) {
            try {
                rta = (EstadoFolioEnhanced) pm.getObjectById(oid, true);
            } catch (JDOObjectNotFoundException e) {
                rta = null;
            } catch (JDOException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                throw new DAOException(e.getMessage(), e);
            }
        }

        return rta;
    }

    /**
     * Adiciona un EstadoFolio a la configuración del sistema
     *
     * @param datos objeto EstadoFolio con sus atributos exceptuando su
     * identificador
     * @param usuario que adiciona el estado del folio el cual es generado por
     * el sistema
     * @return identificador de estadoFolio generado
     */
    public EstadoFolioPk addEstadoFolio(EstadoFolio datos, Usuario usuario)
            throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        EstadoFolioEnhanced estado = EstadoFolioEnhanced.enhance(datos);

        try {
            //Validación de identificador del EstadoAnotacion
            EstadoFolioEnhancedPk eid = new EstadoFolioEnhancedPk();
            eid.idEstado = estado.getIdEstado();

            EstadoFolioEnhanced vcir = this.getEstadoFolio(eid, pm);
            //Obtener el usuario que adiciona el estado del folio
            UsuarioEnhancedPk usuarioEnhId = new UsuarioEnhancedPk();
            usuarioEnhId.idUsuario = usuario.getIdUsuario();
            UsuarioEnhanced usuarioEnh = (UsuarioEnhanced) pm.getObjectById(usuarioEnhId, true);
            if (vcir != null) {
                throw new DAOException(
                        "Ya existe un estado folio con el identificador: "
                        + eid.idEstado);
            }
            estado.setUsuario(usuarioEnh);
            pm.currentTransaction().setOptimistic(false);
            pm.currentTransaction().begin();
            pm.makePersistent(estado);
            pm.currentTransaction().commit();

            EstadoFolioEnhancedPk rta = (EstadoFolioEnhancedPk) pm.getObjectId(estado);

            return rta.getEstadoFolioID();
        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (Exception e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }
    }

    /**
     * Obtiene una lista con todos los posibles tipos de predio configurados en
     * el sistema
     *
     * @return lista de objetos tipo TipoPredio
     * @see gov.sir.core.negocio.modelo.TipoPredio
     * @throws DAOException
     */
    public List getTiposPredio() throws DAOException {
        List rta = null;
        PersistenceManager pm = AdministradorPM.getPM();

        try {
            rta = this.getTiposPredio(pm);
            pm.makeTransientAll(rta);
        } catch (DAOException e) {
            throw e;
        } finally {
            pm.close();
        }

        return TransferUtils.makeTransferAll(rta);
    }

    /**
     * Obtiene una lista con todos los posibles tipos de predio configurados en
     * el sistema de manera transaccional
     *
     * @param pm
     * @return lista de objetos tipo TipoPredio
     * @see gov.sir.core.negocio.modelo.TipoPredio
     * @throws DAOException
     */
    protected List getTiposPredio(PersistenceManager pm)
            throws DAOException {
        try {
            Query query = pm.newQuery(TipoPredioEnhanced.class);
            query.setOrdering("nombre ascending");

            List rta = (List) query.execute();

            return rta;
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }
    }

    /**
     * Obtiene un TipoPredio dado su identificador
     *
     * @param oid identificador del tipoPredio
     * @return objeto TipoPredio
     * @throws DAOException
     */
    public TipoPredio getTipoPredio(TipoPredioPk oid)
            throws DAOException {
        TipoPredioEnhanced ef = null;
        PersistenceManager pm = AdministradorPM.getPM();
        TipoPredio aux = null;

        try {
            ef = this.getTipoPredio(new TipoPredioEnhancedPk(oid), pm);
            pm.makeTransient(ef);
        } catch (DAOException e) {
            throw e;
        } finally {
            pm.close();
        }

        if (ef != null) {
            aux = (TipoPredio) ef.toTransferObject();
        }

        return aux;
    }

    /**
     * Obtiene un TipoPredio dado su identificador, usado para transacciones se
     * debe dar el PersistenceManager
     *
     * @param oid identificador del tipoPredio
     * @return objeto TipoPredio
     * @throws DAOException
     */
    protected TipoPredioEnhanced getTipoPredio(TipoPredioEnhancedPk oid,
            PersistenceManager pm) throws DAOException {
        TipoPredioEnhanced rta = null;

        if (oid.idPredio != null) {
            try {
                rta = (TipoPredioEnhanced) pm.getObjectById(oid, true);
            } catch (JDOObjectNotFoundException e) {
                rta = null;
            } catch (JDOException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                throw new DAOException(e.getMessage(), e);
            }
        }

        return rta;
    }

    /**
     * Adiciona un TipoPredio a la configuración del sistema
     *
     * @param datos objeto TipoPredio con sus atributos exceptuando su
     * identificador el cual es generado por el sistema
     * @return identificador de estadoFolio generado
     * @throws DAOException
     */
    public TipoPredioPk addTipoPredio(TipoPredio datos)
            throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        TipoPredioEnhanced tipo = TipoPredioEnhanced.enhance(datos);

        try {
            //Validación de identificador del Tipo Predio
            TipoPredioEnhancedPk eid = new TipoPredioEnhancedPk();
            eid.idPredio = tipo.getIdPredio();

            TipoPredioEnhanced vest = this.getTipoPredio(eid, pm);

            if (vest != null) {
                throw new DAOException(
                        "Ya existe un tipo de predio con el identificador: "
                        + eid.idPredio);
            }

            pm.currentTransaction().setOptimistic(false);
            pm.currentTransaction().begin();
            pm.makePersistent(tipo);
            pm.currentTransaction().commit();

            TipoPredioEnhancedPk rta = (TipoPredioEnhancedPk) pm.getObjectId(tipo);

            return rta.getTipoPredioID();
        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (Exception e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }
    }

    /**
     * Obtiene una lista con todos los posibles tipos de naturaleza jurídica
     * configurados en el sistema
     *
     * @return lista de objetos NaturalezaJuridica
     * @see gov.sir.core.negocio.modelo.NaturalezaJuridica
     * @throws DAOException
     */
    public List getNaturalezasJuridicas() throws DAOException {
        return null;
    }

    /**
     * Obtiene un objeto NaturalezaJuridica dado su identificador
     *
     * @param oid identificador de NaturalezaJuridica
     * @return objeto NaturalezaJuridica con su objeto grupoNaturalezaJuridica
     * @throws DAOException
     */
    public NaturalezaJuridica getNaturalezaJuridica(NaturalezaJuridicaPk oid)
            throws DAOException {
        NaturalezaJuridicaEnhanced rta = null;
        PersistenceManager pm = AdministradorPM.getPM();
        NaturalezaJuridica aux = null;

        try {
            rta = this.getNaturalezaJuridica(new NaturalezaJuridicaEnhancedPk(
                    oid), pm);

            if (rta == null) {
                throw new DAOException("La naturaleza Jurídica NO existe");
            }

            pm.makeTransient(rta.getGrupoNaturalezaJuridica());
            pm.makeTransient(rta.getDominioNaturalezaJuridica());
            pm.makeTransient(rta);
        } catch (DAOException e) {
            throw e;
        } finally {
            pm.close();
        }

        if (rta != null) {
            aux = (NaturalezaJuridica) rta.toTransferObject();
        }

        return aux;
    }

    /**
     * Obtiene un objeto NaturalezaJuridica dado su identificador. Usado para
     * transacciones se debe dar el PersistenceManager
     *
     * @param oid identificador de NaturalezaJuridica
     * @return objeto NaturalezaJuridica
     * @throws DAOException
     */
    protected NaturalezaJuridicaEnhanced getNaturalezaJuridica(
            NaturalezaJuridicaEnhancedPk oid, PersistenceManager pm)
            throws DAOException {
        NaturalezaJuridicaEnhanced rta = null;

        if (oid.idNaturalezaJuridica != null) {
            try {
                rta = (NaturalezaJuridicaEnhanced) pm.getObjectById(oid, true);
            } catch (JDOObjectNotFoundException e) {
                rta = null;
            } catch (JDOException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                throw new DAOException(e.getMessage(), e);
            }
        }

        return rta;
    }

    /**
     * Adiciona un tipo de naturaleza jurídica a la configuración del sistema
     *
     * @param datos objeto NaturalezaJuridica con sus atributos exceptuando su
     * identificador el cual es generado por el sistema, el usuario que adicina
     * la naturaleza juridica
     * @return identificador de NaturalezaJuridica generado
     * @throws DAOException
     */
    public NaturalezaJuridicaPk addNaturalezaJuridicaToGrupo(
            NaturalezaJuridica datos, GrupoNaturalezaJuridicaPk gid, Usuario usuario)
            throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        NaturalezaJuridicaEnhanced naturaleza = NaturalezaJuridicaEnhanced.enhance(datos);

        try {
            //Validación del grupo de la naturaleza juridica
            GrupoNaturalezaJuridicaEnhanced vcir = this.getGrupoNaturalezaJuridica(new GrupoNaturalezaJuridicaEnhancedPk(
                    gid), pm);

            if (vcir == null) {
                throw new DAOException(
                        "No existe un grupo de naturaleza jurídica con el identificador: "
                        + gid.idGrupoNatJuridica);
            }
            UsuarioEnhancedPk usuarioEnhId = new UsuarioEnhancedPk();
            usuarioEnhId.idUsuario = usuario.getIdUsuario();
            UsuarioEnhanced usuarioEnh = (UsuarioEnhanced) pm.getObjectById(usuarioEnhId, true);
            naturaleza.setUsuario(usuarioEnh);
            naturaleza.setGrupoNaturalezaJuridica(vcir);

            //Validación del dominio de la natiraleza jurídica
            if (naturaleza.getDominioNaturalezaJuridica() != null) {
                DominioNaturalezaJuridicaEnhancedPk dnid = new DominioNaturalezaJuridicaEnhancedPk();
                dnid.idDominioNatJur = naturaleza.getDominioNaturalezaJuridica()
                        .getIdDominioNatJur();

                DominioNaturalezaJuridicaEnhanced dominio = this.getDominioNaturalezaJuridica(dnid,
                        pm);

                /*Se elimina esta validación que ya no es requerida según nuevas reglas de negocio.
                if (dominio == null) {
                    throw new DAOException(
                        "No encontrño un dominio de naturaleza jurídica con el ID: " +
                        dnid.idDominioNatJur);
                }*/
                naturaleza.setDominioNaturalezaJuridica(dominio);
            }

            //Validación del identificador de la naturaleza jurídica
            NaturalezaJuridicaEnhancedPk vNat = new NaturalezaJuridicaEnhancedPk();
            vNat.idNaturalezaJuridica = naturaleza.getIdNaturalezaJuridica();
            /*
        *  @author Carlos Torres
        *  @chage   se asigna valor a la propiedad version
        *  @mantis 12705: Acta - Requerimiento No 056_453_Modificiación_de_Naturaleza_Jurídica
             */
            vNat.version = naturaleza.getVersion();

            NaturalezaJuridicaEnhanced vNatJur = this.getNaturalezaJuridica(vNat,
                    pm);

            if (vNatJur != null) {
                throw new DAOException(
                        "Ya existe una naturaleza jurídica con el ID: "
                        + vNat.idNaturalezaJuridica);
            }

            pm.currentTransaction().setOptimistic(false);
            pm.currentTransaction().begin();
            pm.makePersistent(naturaleza);
            vcir.addNaturalezaJuridica(naturaleza);
            pm.currentTransaction().commit();

            NaturalezaJuridicaEnhancedPk rta = (NaturalezaJuridicaEnhancedPk) pm.getObjectId(naturaleza);

            return rta.getNaturalezaJuridicaID();
        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (DAOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw e;
        } catch (Exception e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }
    }

    /**
     * Obtiene una lista con todos los posibles tipos de anotacion configurados
     * en el sistema
     *
     * @return lista de objetos TipoAnotacion
     * @see gov.sir.core.negocio.modelo.TipoAnotacion
     * @throws DAOException
     */
    public List getTiposAnotacion() throws DAOException {
        return null;
    }

    /**
     * Obtiene un objeto TipoAnotacion dado su identificador
     *
     * @param oid identificador del tipo de anotación
     * @return objeto TipoAnotación
     * @throws DAOException
     */
    public TipoAnotacion getTipoAnotacion(TipoAnotacionPk oid)
            throws DAOException {
        TipoAnotacionEnhanced rta = null;
        PersistenceManager pm = AdministradorPM.getPM();
        TipoAnotacion aux = null;

        try {
            rta = this.getTipoAnotacion(new TipoAnotacionEnhancedPk(oid), pm);
            pm.makeTransient(rta);
        } catch (DAOException e) {
            throw e;
        } finally {
            pm.close();
        }

        if (rta != null) {
            aux = (TipoAnotacion) rta.toTransferObject();
        }

        return aux;
    }

    /**
     * Obtiene un objeto TipoAnotacion dado su identificador. Usado para
     * transacciones se debe dar el PersistenceManager
     *
     * @param oid identificador del tipo de anotación
     * @return objeto TipoAnotación
     * @throws DAOException
     */
    protected TipoAnotacionEnhanced getTipoAnotacion(
            TipoAnotacionEnhancedPk oid, PersistenceManager pm)
            throws DAOException {
        TipoAnotacionEnhanced rta = null;

        if (oid.idTipoAnotacion != null) {
            try {
                rta = (TipoAnotacionEnhanced) pm.getObjectById(oid, true);
            } catch (JDOObjectNotFoundException e) {
                rta = null;
            } catch (JDOException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                throw new DAOException(e.getMessage(), e);
            }
        }

        return rta;
    }

    /**
     * Obtiene un objeto EstadoAnotacion dado su identificador. Usado para
     * transacciones se debe dar el PersistenceManager
     *
     * @param oid identificador del tipo de anotación
     * @return objeto EstadoAnotación
     * @throws DAOException
     */
    protected EstadoAnotacionEnhanced getEstadoAnotacion(
            EstadoAnotacionEnhancedPk oid, PersistenceManager pm)
            throws DAOException {
        EstadoAnotacionEnhanced rta = null;

        if (oid.idEstadoAn != null) {
            try {
                rta = (EstadoAnotacionEnhanced) pm.getObjectById(oid, true);
            } catch (JDOObjectNotFoundException e) {
                rta = null;
            } catch (JDOException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                throw new DAOException(e.getMessage(), e);
            }
        }

        return rta;
    }

    /**
     * Adiciona un tipo de anotación a la configuración del sistema
     *
     * @param datos objeto TipoAnotacion con sus atributos exceptuando su
     * identificador el cual es generado por el sistema
     * @return identificador de TipoAnotacion generado
     * @throws DAOException
     */
    public TipoAnotacionPk addTipoAnotacion(TipoAnotacion datos)
            throws DAOException {
        return null;
    }

    /**
     * Obtiene una lista con todos los posibles tipos de documentos configurados
     * en el sistema
     *
     * @return lista de objetos TipoDocumento
     * @see gov.sir.core.negocio.modelo.TipoDocumento
     * @throws DAOException
     */
    public List getTiposDocumento() throws DAOException {
        List rta = null;
        PersistenceManager pm = AdministradorPM.getPM();

        try {
            rta = this.getTiposDocumento(pm);
            pm.makeTransientAll(rta);
        } catch (DAOException e) {
            throw e;
        } finally {
            pm.close();
        }

        return TransferUtils.makeTransferAll(rta);
    }

    /**
     *
     * @param pm
     * @return
     * @throws DAOException
     */
    protected List getTiposDocumento(PersistenceManager pm)
            throws DAOException {
        try {
            Query query = pm.newQuery(TipoDocumentoEnhanced.class);
            query.setOrdering("nombre ascending");

            List rta = (List) query.execute();

            return rta;
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }
    }

    /**
     * Obtiene un objeto TipoDocumento dado su identificador
     *
     * @param oid identificador del tipo de documento
     * @return objeto TipoDocumento
     * @throws DAOException
     */
    public TipoDocumento getTipoDocumento(TipoDocumentoPk oid)
            throws DAOException {
        TipoDocumentoEnhanced ef = null;
        PersistenceManager pm = AdministradorPM.getPM();
        TipoDocumento aux = null;

        try {
            ef = this.getTipoDocumento(new TipoDocumentoEnhancedPk(oid), pm);
            pm.makeTransient(ef);
        } catch (DAOException e) {
            throw e;
        } finally {
            pm.close();
        }

        if (ef != null) {
            aux = (TipoDocumento) ef.toTransferObject();
        }

        return aux;
    }

    /**
     * Obtiene un objeto TipoDocumento dado su identificador en una transacción
     *
     * @param oid identificador del Tipo de Documento
     * @param pm PersistenceManager con la transacción
     * @return objeto TipoDocumento persistente
     * @throws DAOException
     */
    protected TipoDocumentoEnhanced getTipoDocumento(
            TipoDocumentoEnhancedPk oid, PersistenceManager pm)
            throws DAOException {
        TipoDocumentoEnhanced rta = null;

        if (oid.idTipoDocumento != null) {
            try {
                rta = (TipoDocumentoEnhanced) pm.getObjectById(oid, true);
            } catch (JDOObjectNotFoundException e) {
                rta = null;
            } catch (JDOException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                throw new DAOException(e.getMessage(), e);
            }
        }

        return rta;
    }

    /**
     * Adiciona un tipo de documento a la configuración del sistema
     *
     * @param datos objeto TipoDocumento con sus atributos exceptuando su
     * identificador el cual es generado por el sistema
     * @return identificador de TipoAnotacion generado
     * @throws DAOException
     */
    public TipoDocumentoPk addTipoDocumento(TipoDocumento datos, Usuario usuario)
            throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        TipoDocumentoEnhanced tipo = TipoDocumentoEnhanced.enhance(datos);

        try {
            UsuarioEnhancedPk usuarioEnhId = new UsuarioEnhancedPk();
            usuarioEnhId.idUsuario = usuario.getIdUsuario();
            UsuarioEnhanced usuarioEnh = (UsuarioEnhanced) pm.getObjectById(usuarioEnhId, true);
            //Validación de identificador del Tipo Oficina
            TipoDocumentoEnhancedPk eid = new TipoDocumentoEnhancedPk();
            eid.idTipoDocumento = tipo.getIdTipoDocumento();

            TipoDocumentoEnhanced vest = this.getTipoDocumento(eid, pm);

            if (vest != null) {
                throw new DAOException(
                        "Ya existe un tipo de documento con el identificador: "
                        + eid.idTipoDocumento);
            }
            tipo.setUsuario(usuarioEnh);
            pm.currentTransaction().setOptimistic(false);
            pm.currentTransaction().begin();
            pm.makePersistent(tipo);
            pm.currentTransaction().commit();

            TipoDocumentoEnhancedPk rta = (TipoDocumentoEnhancedPk) pm.getObjectId(tipo);

            return rta.getTipoDocumentoID();
        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (Exception e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }
    }

    /**
     * Obtiene una lista con todos los posibles tipos de oficina configurados en
     * el sistema
     *
     * @return lista de objetos TipoOficina
     * @see gov.sir.core.negocio.modelo.TipoOficina
     * @throws DAOException
     */
    public List getTiposOficina() throws DAOException {
        List rta = null;
        PersistenceManager pm = AdministradorPM.getPM();

        try {
            rta = this.getTiposOficina(pm);
            pm.makeTransientAll(rta);
        } catch (DAOException e) {
            throw e;
        } finally {
            pm.close();
        }

        return TransferUtils.makeTransferAll(rta);
    }

    /**
     *
     * @param pm
     * @return
     * @throws DAOException
     */
    protected List getTiposOficina(PersistenceManager pm)
            throws DAOException {
        try {
            Query query = pm.newQuery(TipoOficinaEnhanced.class);
            query.setOrdering("nombre ascending");

            List rta = (List) query.execute();

            return rta;
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }
    }

    /**
     * Obtiene un objeto TipoOficina dado su identificador
     *
     * @param oid identificador del tipo de oficina
     * @return objeto TipoOficina
     * @throws DAOException
     */
    public TipoOficina getTipoOficina(TipoOficinaPk oid)
            throws DAOException {
        return null;
    }

    /**
     * Adiciona un tipo de oficina a la configuración del sistema
     *
     * @param datos objeto TipoOficina con sus atributos exceptuando su
     * identificador
     * @param Usuario que adiciona el tipo de oficina el cual es generado por el
     * sistema
     * @return identificador de TipoOficina generado
     * @throws DAOException
     */
    public TipoOficinaPk addTipoOficina(TipoOficina datos, Usuario usuario)
            throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();

        try {

            //Validación de identificador del Tipo Oficina
            pm.currentTransaction().setOptimistic(false);
            pm.currentTransaction().begin();
            long idTipoOf = this.getSecuencial(CSecuencias.SIR_NE_TIPO_OFICINA, pm);
            datos.setIdTipoOficina(Long.toString(idTipoOf));
            TipoOficinaEnhanced tipo = TipoOficinaEnhanced.enhance(datos);
            TipoOficinaEnhancedPk eid = new TipoOficinaEnhancedPk();
            eid.idTipoOficina = tipo.getIdTipoOficina();
            //Tener el usuario que va adicionar el tipo de oficina
            UsuarioEnhancedPk usuarioEnhId = new UsuarioEnhancedPk();
            usuarioEnhId.idUsuario = usuario.getIdUsuario();
            UsuarioEnhanced usuarioEnh = (UsuarioEnhanced) pm.getObjectById(usuarioEnhId, true);
            tipo.setUsuario(usuarioEnh);
            TipoOficinaEnhanced vest = this.getTipoOficina(eid, pm);

            if (vest != null) {
                throw new DAOException(
                        "Ya existe un tipo de oficina con el identificador: "
                        + eid.idTipoOficina);
            }

            pm.makePersistent(tipo);
            pm.currentTransaction().commit();

            TipoOficinaEnhancedPk rta = (TipoOficinaEnhancedPk) pm.getObjectId(tipo);

            return rta.getTipoOficinaID();
        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (DAOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw e;
        } catch (Exception e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }
    }

    /**
     * Agrega una direccion a un folio transaccional, si la dirección tiene
     * idDireccion se asigna la direccion especificada, si no, se le asigna una
     * direccion dependiendo de la secuencia generada
     *
     * @param folio El objeto debe estar en una transaccion
     * @param datos Dirección a agregar, debe contener el objeto eje. El eje1
     * puede ser nulo
     * @param pm PersistenceManager
     * @return
     * @throws DAOException
     */
    protected boolean addDireccionToFolio(FolioEnhanced folio,
            DireccionEnhanced datos, PersistenceManager pm)
            throws DAOException {
        JDOGenieZonaRegistralDAO zonaRegistralDAO = new JDOGenieZonaRegistralDAO();
        boolean rta = false;

        try {
            EjeEnhanced eje = datos.getEje();

            if (eje == null) {
                throw new DAOException("El eje no debe ser nulo");
            }

            EjeEnhancedPk ejeId = new EjeEnhancedPk();
            ejeId.idEje = eje.getIdEje();
            eje = zonaRegistralDAO.getEje(ejeId, pm);

            if (eje == null) {
                throw new DAOException(
                        "No encontró el eje de la dirección con el ID: "
                        + ejeId.idEje);
            }

            datos.setEje(eje);

            if (datos.getEje1() != null) {
                EjeEnhanced eje1 = datos.getEje1();
                EjeEnhancedPk eje1Id = new EjeEnhancedPk();
                eje1Id.idEje = eje1.getIdEje();
                eje1 = zonaRegistralDAO.getEje(eje1Id, pm);

                if (eje1 == null) {
                    throw new DAOException(
                            "No encontró el eje de la dirección con el ID: "
                            + eje1Id.idEje);
                }

                datos.setEje1(eje1);
            }

            //Asigna secuencial en caso que la direccion no tenga identificador
            if (datos.getIdDireccion() == null) {
                datos.setIdDireccion(String.valueOf(folio.getLastIdDireccion()
                        + 1));
                folio.setLastIdDireccion(folio.getLastIdDireccion() + 1);
            }

            datos.setCirculo(folio.getCirculo());
            datos.setFolio(folio);

            rta = true;
        } catch (DAOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw e;
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }

        return rta;
    }

    /**
     * Agrega una direccion a un folio transaccional, si la dirección tiene
     * idDireccion se asigna la direccion especificada, si no, se le asigna una
     * direccion dependiendo de la secuencia generada
     *
     * @param folio El objeto debe estar en una transaccion
     * @param datos Dirección a agregar, debe contener el objeto eje. El eje1
     * puede ser nulo
     * @param pm PersistenceManager
     * @return
     * @throws DAOException
     */
    protected boolean addDireccionToFolio(FolioEnhanced folio,
            DireccionEnhanced datos, PersistenceManager pm, Integer orden)
            throws DAOException {
        JDOGenieZonaRegistralDAO zonaRegistralDAO = new JDOGenieZonaRegistralDAO();
        boolean rta = false;

        try {
            EjeEnhanced eje = datos.getEje();

            if (eje == null) {
                throw new DAOException("El eje no debe ser nulo");
            }

            EjeEnhancedPk ejeId = new EjeEnhancedPk();
            ejeId.idEje = eje.getIdEje();
            eje = zonaRegistralDAO.getEje(ejeId, pm);

            if (eje == null) {
                throw new DAOException(
                        "No encontró el eje de la dirección con el ID: "
                        + ejeId.idEje);
            }

            datos.setEje(eje);

            if (datos.getEje1() != null) {
                EjeEnhanced eje1 = datos.getEje1();
                EjeEnhancedPk eje1Id = new EjeEnhancedPk();
                eje1Id.idEje = eje1.getIdEje();
                eje1 = zonaRegistralDAO.getEje(eje1Id, pm);

                if (eje1 == null) {
                    throw new DAOException(
                            "No encontró el eje de la dirección con el ID: "
                            + eje1Id.idEje);
                }

                datos.setEje1(eje1);
            }

            //Asigna secuencial en caso que la direccion no tenga identificador
            if (datos.getIdDireccion() == null && (orden == null || orden.longValue() > folio.getLastIdDireccion())) {
                datos.setIdDireccion(String.valueOf(folio.getLastIdDireccion()
                        + 1));
                folio.setLastIdDireccion(folio.getLastIdDireccion() + 1);
            } else {
                datos.setIdDireccion(String.valueOf(orden));
            }

            datos.setCirculo(folio.getCirculo());
            datos.setFolio(folio);

            rta = true;
        } catch (DAOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw e;
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }

        return rta;
    }

    /**
     * Agrega una direccion temporal a un folio transaccional
     *
     * @param folio El objeto debe estar en una transaccion
     * @param datos Dirección a agregar, debe contener el objeto eje. El eje1
     * puede ser nulo
     * @param pm PersistenceManager
     * @return
     * @throws DAOException
     */
    protected boolean addDireccionTMPToFolio(FolioEnhanced folio,
            DireccionTMP datos, UsuarioEnhanced usuario, PersistenceManager pm)
            throws DAOException {
        JDOGenieZonaRegistralDAO zonaRegistralDAO = new JDOGenieZonaRegistralDAO();
        boolean rta = false;

        try {
            EjeEnhanced eje = datos.getEje();

            if (eje == null) {
                throw new DAOException("El eje no debe ser nulo");
            }

            EjeEnhancedPk ejeId = new EjeEnhancedPk();
            ejeId.idEje = eje.getIdEje();
            eje = zonaRegistralDAO.getEje(ejeId, pm);

            if (eje == null) {
                throw new DAOException(
                        "No encontró el eje de la dirección con el ID: "
                        + ejeId.idEje);
            }

            datos.setEje(eje);

            if (datos.getEje1() != null) {
                EjeEnhanced eje1 = datos.getEje1();
                EjeEnhancedPk eje1Id = new EjeEnhancedPk();
                eje1Id.idEje = eje1.getIdEje();
                eje1 = zonaRegistralDAO.getEje(eje1Id, pm);

                if (eje1 == null) {
                    throw new DAOException(
                            "No encontró el eje de la dirección con el ID: "
                            + eje1Id.idEje);
                }

                datos.setEje1(eje1);
            }

            //Asociamos el usuario creador
            datos.setUsuario(usuario);

            if (datos.getIdDireccionTmp() == null) {
                /*if(datos.getOrden() != null && !datos.getOrden().equals("")){
					datos.setIdDireccionTmp(String.valueOf(datos.getOrden()));
				}else*/
                datos.setIdDireccionTmp(String.valueOf(folio.getLastIdDireccionTMP() + 1));
                folio.setLastIdDireccionTMP(folio.getLastIdDireccionTMP() + 1);
            }

            datos.setFolio(folio);

            rta = true;
        } catch (DAOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw e;
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }

        return rta;
    }

    /**
     * Agrega una direccion a un folio transaccional
     *
     * @param folio El objeto debe estar en una transaccion
     * @param datos Dirección a agregar, debe contener el objeto eje. El eje1
     * puede ser nulo
     * @param pm PersistenceManager
     * @return
     * @throws DAOException
     */
    protected boolean addAnotacionCiudadanoToAnotacion(
            AnotacionEnhanced anota, AnotacionCiudadanoEnhanced datos,
            PersistenceManager pm) throws DAOException {
        JDOGenieZonaRegistralDAO zonaRegistralDAO = new JDOGenieZonaRegistralDAO();
        JDOGenieCiudadanoDAO ciudadanoDAO = new JDOGenieCiudadanoDAO();
        boolean rta = false;

        try {
            CiudadanoEnhanced ciudadano = datos.getCiudadano();
            CiudadanoEnhanced ciud = null;

            if (ciudadano == null) {
                throw new DAOException(
                        "La AnotacionCiudadano no tiene ciudadano");
            }

            JDOGenieCiudadanoDAO ciudDAO = new JDOGenieCiudadanoDAO();
            if (ciudadano.getIdCiudadano() != null) {
                CiudadanoEnhancedPk ciudID = new CiudadanoEnhancedPk();
                ciudID.idCiudadano = ciudadano.getIdCiudadano();
                ciud = ciudDAO.getCiudadano(ciudID, pm);
            }

            if (ciud == null) {
                ciud = ciudDAO.getCiudadanoByDocumento(ciudadano.getTipoDoc(),
                        ciudadano.getDocumento(), false, pm, ciudadano.getIdCirculo());
            }

            if (ciud != null) {
                if (ciudadanoDAO.hasProhibicionActiva(ciud, CProhibicion.ENAJENAR, pm) && datos.getRolPersona().equals(CAnotacionCiudadano.ROL_PERSONA_DE)
                        && !datos.toDelete) {
                    throw new DAOException(
                            "El ciudadano tiene prohibición de enajenación. Tipo Doc: "
                            + ciud.getTipoDoc() + " Número Doc: "
                            + ciud.getDocumento());
                }

                datos.setCiudadano(ciud);
            } else {
                ciud = ciudadanoDAO.crearCiudadano(ciudadano, pm);
                datos.setCiudadano(ciud);
            }

            datos.setAnotacion(anota);
            datos.setCirculo(anota.getCirculo());
            rta = true;
        } catch (DAOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw e;
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }

        return rta;
    }

    /**
     * Agrega una direccion a un folio
     *
     * @param oid Identificador del folio
     * @param datos Dirección a agregar, debe contener el objeto eje. El eje1
     * puede ser nulo
     * @param pm PersistenceManager
     * @return identificador de la dirección asignada por el sistema
     * @throws DAOException
     */
    public DireccionPk addDireccionToFolio(FolioPk oid, Direccion datos)
            throws DAOException {
        DireccionEnhancedPk rta = new DireccionEnhancedPk();
        FolioEnhanced folio = new FolioEnhanced();
        PersistenceManager pm = AdministradorPM.getPM();

        DireccionEnhanced direccion = DireccionEnhanced.enhance(datos);

        try {
            pm.currentTransaction().setOptimistic(false);
            pm.currentTransaction().begin();

            folio = this.getFolioByID(new FolioEnhancedPk(oid), pm);

            if (folio == null) {
                throw new DAOException("El folio especificado no existe");
            }

            addDireccionToFolio(folio, direccion, pm);
            pm.makePersistent(direccion);

            pm.currentTransaction().commit();
            rta = (DireccionEnhancedPk) pm.getObjectId(direccion);
        } catch (DAOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            throw e;
        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (Exception e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        return rta.getDireccionID();
    }

    /**
     * Añade una anotación en una transacción a un folio
     *
     * @param folio
     * @param datos La anotación debe contener los objetos existentes: estado,
     * naturalezaJuridica y tipoAnotacion. Si el idDocumento de la anotacion es
     * direfente de null se valida que exista y se asocia, si el documento de la
     * anotación es null se crea
     * @param pm
     * @return
     * @throws DAOException
     */
    protected boolean addAnotacionToFolio(FolioEnhanced folio,
            AnotacionEnhanced datos, UsuarioEnhanced usuario, TurnoEnhanced turno, boolean validarTurno,
            PersistenceManager pm) throws DAOException {
        JDOGenieZonaRegistralDAO zonaRegistralDAO = new JDOGenieZonaRegistralDAO();
        boolean rta = false;

        try {
            EstadoAnotacionEnhanced estado;

            datos.setCirculo(folio.getCirculo());

            if (datos.getEstado() != null) {
                EstadoAnotacionEnhancedPk eId = new EstadoAnotacionEnhancedPk();
                eId.idEstadoAn = datos.getEstado().getIdEstadoAn();

                estado = this.getEstadoAnotacion(eId, pm);

                if (estado == null) {
                    throw new DAOException(
                            "No encontró el estado de la anotación con el ID: "
                            + eId.idEstadoAn);
                }
            } else {
                EstadoAnotacionEnhancedPk eId = new EstadoAnotacionEnhancedPk();
                eId.idEstadoAn = CEstadoAnotacion.ACTIVO;

                estado = this.getEstadoAnotacion(eId, pm);

                if (estado == null) {
                    throw new DAOException(
                            "No encontró el estado de la anotación con el ID: "
                            + eId.idEstadoAn);
                }
            }

            if (datos.getNaturalezaJuridica() == null) {
                throw new DAOException(
                        "La anotación debe tener naturaleza jurídica");
            }

            NaturalezaJuridicaEnhancedPk njId = new NaturalezaJuridicaEnhancedPk();
            njId.idNaturalezaJuridica = datos.getNaturalezaJuridica()
                    .getIdNaturalezaJuridica();
            /*
            *  @author Carlos Torres
            *  @chage   se asigna valor a la propiedad version
            *  @mantis 12705: Acta - Requerimiento No 056_453_Modificiación_de_Naturaleza_Jurídica
             */
            njId.version = datos.getNaturalezaJuridica().getVersion();

            NaturalezaJuridicaEnhanced naturaleza = this.getNaturalezaJuridica(njId,
                    pm);

            if (naturaleza == null) {
                throw new DAOException(
                        "No encontró la naturaleza jurídica de la anotación con el ID: "
                        + njId.idNaturalezaJuridica);
            }

            TipoAnotacionEnhancedPk taId = new TipoAnotacionEnhancedPk();

            if (datos.getTipoAnotacion() == null) {
                taId.idTipoAnotacion = CTipoAnotacion.ESTANDAR;
            } else {
                taId.idTipoAnotacion = datos.getTipoAnotacion()
                        .getIdTipoAnotacion();
            }

            TipoAnotacionEnhanced tipoAnota = this.getTipoAnotacion(taId, pm);

            if (tipoAnota == null) {
                throw new DAOException(
                        "No encontró el tipo de la anotación con el ID: "
                        + taId.idTipoAnotacion);
            }

            datos.setEstado(estado);
            datos.setNaturalezaJuridica(naturaleza);
            datos.setTipoAnotacion(tipoAnota);

            if (datos.getDocumento() != null) {
                this.setDocumentoToAnotacion(datos, datos.getDocumento(), pm);
            }

            //Se establece la llave primaria de anotación, si es diferente de null
            //se asigna una con la secuencia que lleva folio
            if (datos.getIdAnotacion() == null) {
                datos.setIdAnotacion(String.valueOf(folio.getLastIdAnotacion()
                        + 1));
                folio.setLastIdAnotacion(folio.getLastIdAnotacion() + 1);
            }

            datos.setFolio(folio);

            //Se asocia la información de antiguo sistema
            if (datos.getDatosAntiguoSistema() != null) {
                DatosAntiguoSistemaEnhanced datosAS = datos.getDatosAntiguoSistema();

                //Se mira si la información de antiguo sistema ya existe en la base de datos
                DatosAntiguoSistemaEnhancedPk dASid = new DatosAntiguoSistemaEnhancedPk();
                dASid.idDatosAntiguoSistema = datosAS.getIdDatosAntiguoSistema();

                DatosAntiguoSistemaEnhanced dASVal = this.getDatosAntiguoSistema(dASid,
                        pm);

                if (dASVal != null) {
                    //Se asocia
                    datos.setDatosAntiguoSistema(dASVal);
                } else {
                    //Se sete el ID para crearlo en la BD
                    datosAS.setIdDatosAntiguoSistema(datos.getIdMatricula() + "-"
                            + datos.getIdAnotacion());
                }
            }

            //Salvedades para agregar
            List salvedades = datos.getSalvedades();
            SalvedadAnotacionEnhanced salvedad = null;

            for (Iterator itr = salvedades.iterator(); itr.hasNext();) {
                salvedad = (SalvedadAnotacionEnhanced) itr.next();
                this.addSalvedadToAnotacion(datos, salvedad, usuario, turno, validarTurno, pm);
            }

            //Anotaciones ciudadano para agregar
            List anotacionesCiudadano = datos.getAnotacionesCiudadanos();
            AnotacionCiudadanoEnhanced anotaCiud = null;

            for (Iterator itr = anotacionesCiudadano.iterator(); itr.hasNext();) {
                anotaCiud = (AnotacionCiudadanoEnhanced) itr.next();
                this.addAnotacionCiudadanoToAnotacion(datos, anotaCiud, pm);
            }

            //Anotaciones cancelacion para agregar
            List anotacionesCancelacion = datos.getAnotacionesCancelacions();
            CancelacionEnhanced cancel = null;

            for (Iterator itr = anotacionesCancelacion.iterator();
                    itr.hasNext();) {
                cancel = (CancelacionEnhanced) itr.next();
                this.addCancelacionToAnotacion(datos, cancel, pm);
            }

            if (turno != null && turno.getIdFase() != null && turno.getIdFase().equals("ANT_CREACION_FOLIO")
                    && (turno.getIdProceso() == 6 || turno.getIdProceso() == 3 || turno.getIdProceso() == 1)) {
                List foliosDerivadosP = datos.getAnotacionesPadre();
                FolioDerivadoEnhanced fd = null;

                for (Iterator itr = foliosDerivadosP.iterator(); itr.hasNext();) {
                    fd = (FolioDerivadoEnhanced) itr.next();
                    this.addFolioDerivadoPadreToAnotacion(datos, fd, usuario, turno, validarTurno, pm);
                }
            }

            //Folios derivados para agregar
            List foliosDerivados = datos.getAnotacionesHijos();
            FolioDerivadoEnhanced fd = null;

            for (Iterator itr = foliosDerivados.iterator(); itr.hasNext();) {
                fd = (FolioDerivadoEnhanced) itr.next();
                this.addFolioDerivadoHijoToAnotacion(datos, fd, usuario, turno, validarTurno, pm);
            }

            //Se revisa si el turno de numRadicación corresponde a un turno existente:
            if (datos.getNumRadicacion() == null) {
                //Si no tiene número de radicación se asocia el turno que lo está haciendo
                //definitivo
                if (turno != null) {
                    TurnoAnotacionEnhanced tae = new TurnoAnotacionEnhanced();
                    tae.setTurno(turno);
                    tae.setAnotacion(datos);
                    datos.addTurnoAnotacion(tae);
                    datos.setNumRadicacion(turno.getIdWorkflow());
                }
            } else {
                TurnoEnhanced turnoAux = this.getTurnoByWFId(datos.getNumRadicacion(), pm);
                if (turnoAux != null) {
                    TurnoAnotacionEnhanced tae = new TurnoAnotacionEnhanced();
                    tae.setTurno(turnoAux);
                    tae.setAnotacion(datos);
                    datos.addTurnoAnotacion(tae);
                }
            }

            rta = true;
        } catch (DAOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw e;
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }

        return rta;
    }

    /**
     * Obtiene un turno dado el identificador de su instancia en workflow,
     * método utilizado para transacciones
     *
     * @param wfId Documento de pago con sus atributos numero de cheque y numero
     * de cuenta
     * @param pm PersistenceManager de la transaccion
     * @return Turno con todos sus atributos.
     * @throws DAOException
     */
    protected TurnoEnhanced getTurnoByWFId(String wfId, PersistenceManager pm)
            throws DAOException {
        TurnoEnhanced rta = null;
        String Wf = wfId;

        try {

            //SE INTENTA OBTENER EL CIRCULO PARA COLOCARLO COMO PARTE DE LA CONSULTA
            String wfTurno = wfId;
            boolean wfValido = false;
            String idCirculo = null;

            if (wfTurno.indexOf("-") != -1) {
                String[] partes = wfTurno.split("-");
                if (partes.length == 4) {
                    wfValido = true;
                    TurnoPk idTurno = new TurnoPk(wfTurno);
                    idCirculo = idTurno.idCirculo;
                }
            }

            Query query = pm.newQuery(TurnoEnhanced.class);

            if (wfValido) {
                query.declareParameters("String Wf, String idCir");
            } else {
                query.declareParameters("String Wf");
            }

            if (wfValido) {
                query.setFilter("idWorkflow == Wf  && idCirculo ==idCir");
            } else {
                query.setFilter("idWorkflow == Wf");
            }

            Collection col = null;
            if (wfValido) {
                col = (Collection) query.execute(Wf, idCirculo);
            } else {
                col = (Collection) query.execute(Wf);
            }

            if (col.size() == 0) {
                rta = null;
            } else {
                for (Iterator iter = col.iterator(); iter.hasNext();) {
                    rta = (TurnoEnhanced) iter.next();
                }

                query.closeAll();
            }
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        }

        return rta;
    }

    /**
     * Añade una anotación a un folio
     *
     * @param folio
     * @param datos La anotación debe contener los objetos existentes: estado,
     * naturalezaJuridica y tipoAnotacion. Si el idDocumento de la anotacion es
     * direfente de null se valida que exista y se asocia, si el documento de la
     * anotación es null se crea
     * @return
     * @throws DAOException
     */
    public AnotacionPk addAnotacionToFolio(FolioPk oid, Anotacion datos)
            throws DAOException {
        AnotacionPk rta = null;
        FolioEnhanced folio = new FolioEnhanced();
        PersistenceManager pm = AdministradorPM.getPM();
        AnotacionEnhanced anota = AnotacionEnhanced.enhance(datos);

        try {
            pm.currentTransaction().setOptimistic(false);
            pm.currentTransaction().begin();

            folio = this.getFolioByID(new FolioEnhancedPk(oid), pm);

            if (folio == null) {
                throw new DAOException("El folio especificado no existe");
            }

            this.addAnotacionToFolio(folio, anota, null, null, false, pm);
            pm.makePersistent(anota);
            pm.currentTransaction().commit();
            rta = ((AnotacionEnhancedPk) pm.getObjectId(anota)).getAnotacionID();
        } catch (DAOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            throw e;
        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (Exception e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e);
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        return rta;
    }

    /**
     * Setea el documento de la anotación en una transacción. Si idDocumento es
     * nulo, se asigna un consecutivo y se crea el documento, si el idDocumento
     * es diferente de nulo se valida que exista y se asocia
     *
     * @param anotacion
     * @param datos Documento con los objetos OficinaOrigen y TipoOficina
     * @param pm PersistenceManager de la transacción
     * @return
     * @throws DAOException
     */
    protected boolean setDocumentoToAnotacion(AnotacionEnhanced anotacion,
            DocumentoEnhanced datos, PersistenceManager pm)
            throws DAOException {
        DocumentoEnhanced doc = null;
        boolean rta;

        JDOGenieZonaRegistralDAO zonaRegistralDAO = new JDOGenieZonaRegistralDAO();

        try {
            if (datos.getIdDocumento() != null) {
                DocumentoEnhancedPk did = new DocumentoEnhancedPk();
                did.idDocumento = datos.getIdDocumento();
                doc = this.getDocumento(did, pm);

                if (doc == null) {
                    throw new DAOException(
                            "No encontró el documento con el ID: "
                            + did.idDocumento);
                }

                anotacion.setDocumento(doc);
            } else {

                //Asignación de llave:
                datos.setIdDocumento(String.valueOf(this.getSecuencial(
                        CDocumento.TABLE_NAME, null)));

                if ((datos.getOficinaInternacional() == null) || (datos.getOficinaInternacional().length() <= 0)) {
                    if (datos.getOficinaOrigen() == null) {
                        throw new DAOException("El documento debe tener oficina origen");
                    }
                }

                if (datos.getTipoDocumento() == null) {
                    throw new DAOException(
                            "El documento debe tener tipo de documento");
                }

                OficinaOrigenEnhancedPk ofid = new OficinaOrigenEnhancedPk();
                ofid.idOficinaOrigen = datos.getOficinaOrigen()
                        .getIdOficinaOrigen();
                /*
                  *  @author Carlos Torres
                  *  @chage   se agrega validacion de version diferente
                  *  @mantis 0013414: Acta - Requerimiento No 069_453_Código_Notaria_NC
                 */
                ofid.version = datos.getOficinaOrigen().getVersion();

                OficinaOrigenEnhanced oficina = zonaRegistralDAO.getOficinaOrigen(ofid,
                        pm);

                if (oficina == null) {
                    throw new DAOException(
                            "La oficina origen no existe. IdOficina: "
                            + ofid.idOficinaOrigen);
                }

                TipoDocumentoEnhancedPk tdid = new TipoDocumentoEnhancedPk();
                tdid.idTipoDocumento = datos.getTipoDocumento()
                        .getIdTipoDocumento();

                TipoDocumentoEnhanced tipoDoc = this.getTipoDocumento(tdid, pm);

                if (tipoDoc == null) {
                    throw new DAOException(
                            "El tipo de documento no existe. IdTipoDocumento: "
                            + tdid.idTipoDocumento);
                }

                datos.setOficinaOrigen(oficina);
                datos.setTipoDocumento(tipoDoc);
                anotacion.setDocumento(datos);
            }

            rta = true;
        } catch (DAOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw e;
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }

        return rta;
    }

    /**
     * Setea el documento de la anotación en una transacción. Si idDocumento es
     * nulo, se asigna un consecutivo y se crea el documento, si el idDocumento
     * es diferente de nulo se valida que exista y se asocia
     *
     * @param anotacion
     * @param datos Documento con los objetos OficinaOrigen y TipoOficina
     * @param pm PersistenceManager de la transacción
     * @return
     * @throws DAOException
     */
    protected boolean setDocumentoToFolio(FolioEnhanced folio,
            DocumentoEnhanced datos, PersistenceManager pm)
            throws DAOException {
        DocumentoEnhanced doc = null;
        boolean rta;

        JDOGenieZonaRegistralDAO zonaRegistralDAO = new JDOGenieZonaRegistralDAO();

        try {
            if (datos.getIdDocumento() != null) {
                DocumentoEnhancedPk did = new DocumentoEnhancedPk();
                did.idDocumento = datos.getIdDocumento();
                doc = this.getDocumento(did, pm);

                if (doc == null) {
                    throw new DAOException(
                            "No encontró el documento con el ID: "
                            + did.idDocumento);
                }

                folio.setDocumento(doc);
            } else {
                /*
                if (datos.getOficinaOrigen() == null) {
                    throw new DAOException(
                        "El documento debe tener oficina origen");
                }*/
                //Asignación de llave:
                datos.setIdDocumento(String.valueOf(this.getSecuencial(
                        CDocumento.TABLE_NAME, null)));

                if (datos.getTipoDocumento() == null) {
                    throw new DAOException(
                            "El documento debe tener tipo de documento");
                }

                if (datos.getOficinaOrigen() != null) {
                    OficinaOrigenEnhancedPk ofid = new OficinaOrigenEnhancedPk();
                    ofid.idOficinaOrigen = datos.getOficinaOrigen()
                            .getIdOficinaOrigen();
                    /*
                      *  @author Carlos Torres
                      *  @chage   se agrega validacion de version diferente
                      *  @mantis 0013414: Acta - Requerimiento No 069_453_Código_Notaria_NC
                     */
                    ofid.version = datos.getOficinaOrigen().getVersion();

                    OficinaOrigenEnhanced oficina = zonaRegistralDAO.getOficinaOrigen(ofid,
                            pm);

                    if (oficina == null) {
                        throw new DAOException(
                                "La oficina origen no existe. IdOficina: "
                                + ofid.idOficinaOrigen);
                    }

                    datos.setOficinaOrigen(oficina);
                }

                TipoDocumentoEnhancedPk tdid = new TipoDocumentoEnhancedPk();
                tdid.idTipoDocumento = datos.getTipoDocumento()
                        .getIdTipoDocumento();

                TipoDocumentoEnhanced tipoDoc = this.getTipoDocumento(tdid, pm);

                if (tipoDoc == null) {
                    throw new DAOException(
                            "El tipo de documento no existe. IdTipoDocumento: "
                            + tdid.idTipoDocumento);
                }

                datos.setTipoDocumento(tipoDoc);
                folio.setDocumento(datos);
            }

            rta = true;
        } catch (DAOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw e;
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }

        return rta;
    }

    /**
     * Setea el documento temporal del folio en una transacción. Si idDocumento
     * es nulo, se asigna un consecutivo y se crea el documento, si el
     * idDocumento es diferente de nulo se crea el documento temporal con ese ID
     *
     * @param folio
     * @param datos
     * @param pm
     * @return
     * @throws DAOException
     */
    protected boolean setDocumentoTMPToFolio(FolioEnhanced folio,
            DocumentoTMP datos, PersistenceManager pm) throws DAOException {
        DocumentoTMP doc = null;
        boolean rta;

        JDOGenieZonaRegistralDAO zonaRegistralDAO = new JDOGenieZonaRegistralDAO();

        try {
            if (datos.getTipoDocumento() == null) {
                throw new DAOException(
                        "El documento debe tener tipo de documento");
            }

            if (datos.getOficinaOrigen() != null) {
                OficinaOrigenEnhancedPk ofid = new OficinaOrigenEnhancedPk();
                ofid.idOficinaOrigen = datos.getOficinaOrigen()
                        .getIdOficinaOrigen();
                /*
                      *  @author Carlos Torres
                      *  @chage   se agrega validacion de version diferente
                      *  @mantis 0013414: Acta - Requerimiento No 069_453_Código_Notaria_NC
                 */
                ofid.version = datos.getOficinaOrigen().getVersion();

                OficinaOrigenEnhanced oficina = zonaRegistralDAO.getOficinaOrigen(ofid,
                        pm);

                if (oficina == null) {
                    throw new DAOException(
                            "La oficina origen no existe. IdOficina: "
                            + ofid.idOficinaOrigen);
                }

                datos.setOficinaOrigen(oficina);
            }

            TipoDocumentoEnhancedPk tdid = new TipoDocumentoEnhancedPk();
            tdid.idTipoDocumento = datos.getTipoDocumento().getIdTipoDocumento();

            TipoDocumentoEnhanced tipoDoc = this.getTipoDocumento(tdid, pm);

            if (tipoDoc == null) {
                throw new DAOException(
                        "El tipo de documento no existe. IdTipoDocumento: "
                        + tdid.idTipoDocumento);
            }

            datos.setTipoDocumento(tipoDoc);
            folio.setDocumentoTMP(datos);

            rta = true;
        } catch (DAOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw e;
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }

        return rta;
    }

    /**
     * Setea el documento temporal de la anotación en una transacción. Si
     * idDocumento es nulo, se asigna un consecutivo y se crea el documento, si
     * el idDocumento es diferente de nulo se crea el documento temporal con ese
     * ID
     *
     * @param folio
     * @param datos
     * @param pm
     * @return
     * @throws DAOException
     */
    protected boolean setDocumentoTMPToAnotacion(AnotacionTMP anotacion,
            DocumentoTMP datos, PersistenceManager pm) throws DAOException {
        DocumentoTMP doc = null;
        boolean rta;

        JDOGenieZonaRegistralDAO zonaRegistralDAO = new JDOGenieZonaRegistralDAO();

        try {
            if (datos.getTipoDocumento() == null) {
                throw new DAOException(
                        "El documento debe tener tipo de documento");
            }

            if (datos.getOficinaOrigen() != null) {
                OficinaOrigenEnhancedPk ofid = new OficinaOrigenEnhancedPk();
                ofid.idOficinaOrigen = datos.getOficinaOrigen()
                        .getIdOficinaOrigen();
                /*
                      *  @author Carlos Torres
                      *  @chage   se agrega validacion de version diferente
                      *  @mantis 0013414: Acta - Requerimiento No 069_453_Código_Notaria_NC
                 */
                ofid.version = datos.getOficinaOrigen().getVersion();

                OficinaOrigenEnhanced oficina = zonaRegistralDAO.getOficinaOrigen(ofid,
                        pm);

                if (oficina == null) {
                    throw new DAOException(
                            "La oficina origen no existe. IdOficina: "
                            + ofid.idOficinaOrigen);
                }

                datos.setOficinaOrigen(oficina);
            }

            TipoDocumentoEnhancedPk tdid = new TipoDocumentoEnhancedPk();
            tdid.idTipoDocumento = datos.getTipoDocumento().getIdTipoDocumento();

            TipoDocumentoEnhanced tipoDoc = this.getTipoDocumento(tdid, pm);

            if (tipoDoc == null) {
                throw new DAOException(
                        "El tipo de documento no existe. IdTipoDocumento: "
                        + tdid.idTipoDocumento);
            }

            datos.setTipoDocumento(tipoDoc);
            anotacion.setDocumentoTMP(datos);

            rta = true;
        } catch (DAOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw e;
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }

        return rta;
    }

    /**
     * Setea el documento de una anotacion. Si idDocumento es nulo, se asigna un
     * consecutivo y se crea el documento, si el idDocumento es diferente de
     * nulo se valida que exista y se asocia
     *
     * @param anotacion
     * @param datos
     * @return
     * @throws DAOException
     */
    public DocumentoPk setDocumentoToAnotacion(AnotacionPk oid,
            Documento datos) throws DAOException {
        DocumentoPk rta = null;
        DocumentoEnhanced documento = DocumentoEnhanced.enhance(datos);
        AnotacionEnhanced anota = new AnotacionEnhanced();
        PersistenceManager pm = AdministradorPM.getPM();

        try {
            pm.currentTransaction().setOptimistic(false);
            pm.currentTransaction().begin();
            anota = this.getAnotacionByID(new AnotacionEnhancedPk(oid), pm);

            if (anota == null) {
                throw new DAOException("La anotación especificada no existe");
            }

            this.setDocumentoToAnotacion(anota, documento, pm);
            pm.currentTransaction().commit();
            rta = ((DocumentoEnhancedPk) pm.getObjectId(anota.getDocumento())).getDocumentoID();
        } catch (DAOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            throw e;
        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (Exception e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        return rta;
    }

    /**
     * Servicio utilizado para establecer si el folio con el número de matrícula
     * se encuentra en trámite
     *
     * @param matricula
     * @return true: folio en trámite, false: folio no se encuentra en trámite
     * @throws DAOException
     */
    public boolean enTramiteFolio(String matricula) throws DAOException {
        boolean rta = false;
        PersistenceManager pm = AdministradorPM.getPM();

        String idRegistro = CProceso.PROCESO_REGISTRO;
        String idCorreccion = CProceso.PROCESO_CORRECCIONES;

        try {
            pm.currentTransaction().begin();

            FolioEnhanced fol = this.getFolioByMatricula(matricula, pm);

            if (fol != null) {
                Query query = pm.newQuery(SolicitudFolioEnhanced.class);
                query.declareVariables("TurnoEnhanced turno; TurnoHistoriaEnhanced th");
                query.declareParameters("FolioEnhanced fol");
                query.setFilter(
                        "folio==fol && turno.solicitud == solicitud && "
                        + "turno.idCirculo==turno.solicitud.circulo && "
                        + "turno.anulado == \"" + CTurno.TURNO_NO_ANULADO + "\" && "
                        + "turno.fechaFin==null && !(turno.historial.contains(th) && "
                        + "((th.fase==\"" + CFase.REG_ENTREGA + "\")||"
                        + "(th.fase==\"" + CFase.REG_ENTREGA_EXTERNO + "\")||"
                        + /**
                         * @Autor: Fernando Padilla Velez, 30/06/2015
                         * @change:1209.AJUSTE.IMPRIMIBLE.CERTIFICADO.BP.SIR, Se
                         * agrega las fases faltantes.
                         *
                         */
                        "(th.fase==\"" + CFase.REG_FINALIZADO + "\")||"
                        + "(th.fase==\"" + CFase.COS_FINALIZADO + "\")||"
                        + "(th.fase==\"" + CFase.COS_ENTREGAR_ASOCIADOS + "\"))) && (solicitud.proceso.idProceso == "
                        + idRegistro + " || solicitud.proceso.idProceso== "
                        + idCorreccion + ") && folio.estado.idEstado!=\""
                        + CEstadoFolio.OBSOLETO + "\" ");

                Collection col = (Collection) query.execute(fol);

                Iterator iter = col.iterator();

                if (!iter.hasNext()) {
                    rta = false;
                } else {
                    rta = true;
                }

                query.closeAll();
            }
        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (Exception e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().commit();
            }

            pm.close();
        }

        return rta;
    }
    
    /**
     * Servicio utilizado para establecer si el folio con el número de matrícula
     * se encuentra en trámite. Si retorna null el folio NO está en trámite, si
     * returna una lista de Turnos el folio se encuentra en trámite por el turno
     * dado
     *
     * @param matricula
     * @return Turno
     * @throws DAOException
     */
    public List getTurnosTramiteFolio(String matricula)
            throws DAOException {
        List turnosEnhanced = new ArrayList();
        List turnos = new ArrayList();
        TurnoEnhanced aux = null;
        Turno def = null;
        PersistenceManager pm = AdministradorPM.getPM();

        String idRegistro = CProceso.PROCESO_REGISTRO;
        String idCorreccion = CProceso.PROCESO_CORRECCIONES;

        try {
            pm.currentTransaction().setOptimistic(false);
            pm.currentTransaction().begin();

            FolioEnhanced fol = this.getFolioByMatricula(matricula, pm);

            if (fol != null) {
                Query query = pm.newQuery(SolicitudFolioEnhanced.class);
                query.declareVariables("TurnoEnhanced turno");
                query.declareParameters("FolioEnhanced fol");
                query.setFilter(
                        "folio==fol && turno.solicitud == solicitud && "
                        + "turno.idCirculo==turno.solicitud.circulo && "
                        + "turno.fechaFin==null"
                        + "&& (solicitud.proceso.idProceso == "
                        + idRegistro + " || solicitud.proceso.idProceso== "
                        + idCorreccion + ") && folio.estado.idEstado!='"
                        + CEstadoFolio.OBSOLETO + "' ");

                Collection col = (Collection) query.execute(fol);

                Iterator iter = col.iterator();

                SolicitudFolioEnhanced sf;

                while (iter.hasNext()) {
                    sf = (SolicitudFolioEnhanced) iter.next();
                    aux = this.getTurnoBySolicitud(sf.getSolicitud(), pm);
                    turnosEnhanced.add(aux);
                    pm.makeTransient(aux);
                }
                
            
                query.closeAll();
            }
        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (Exception e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().commit();
            }

            pm.close();
        }

    
            TurnoEnhanced trno;
            if(!turnosEnhanced.isEmpty()){
            Iterator it = turnosEnhanced.iterator();
            while(it.hasNext()){
                trno = (TurnoEnhanced) it.next();
                if(trno != null 
                        && !trno.getIdFase().equals("REG_ENTREGA")
                        && !trno.getIdFase().equals("REG_FINALIZADO")
                        && !trno.getIdFase().equals("FINALIZADO")
                        && !trno.getAnulado().equals("S")){
                 turnos.add(trno.getIdWorkflow());
                }
            }
            
            }
        return turnos;
    }
    
    /**
     * Servicio utilizado para establecer si el folio con el número de matrícula
     * se encuentra en trámite. Si retorna null el folio NO está en trámite, si
     * returna un objeto Turno el folio se encuentra en trámite por el turno
     * dado
     *
     * @param matricula
     * @return Turno
     * @throws DAOException
     */
    public Turno getTurnoTramiteFolio(String matricula)
            throws DAOException {
        Turno rta = null;
        TurnoEnhanced aux = null;
        PersistenceManager pm = AdministradorPM.getPM();

        String idRegistro = CProceso.PROCESO_REGISTRO;
        String idCorreccion = CProceso.PROCESO_CORRECCIONES;

        try {
            pm.currentTransaction().setOptimistic(false);
            pm.currentTransaction().begin();

            FolioEnhanced fol = this.getFolioByMatricula(matricula, pm);

            if (fol != null) {
                Query query = pm.newQuery(SolicitudFolioEnhanced.class);
                query.declareVariables("TurnoEnhanced turno");
                query.declareParameters("FolioEnhanced fol");
                query.setFilter(
                        "folio==fol && turno.solicitud == solicitud && "
                        + "turno.idCirculo==turno.solicitud.circulo && "
                        + "turno.fechaFin==null && (solicitud.proceso.idProceso == "
                        + idRegistro + " || solicitud.proceso.idProceso== "
                        + idCorreccion + ") && folio.estado.idEstado!='"
                        + CEstadoFolio.OBSOLETO + "' ");

                Collection col = (Collection) query.execute(fol);

                Iterator iter = col.iterator();

                SolicitudFolioEnhanced sf;

                if (iter.hasNext()) {
                    sf = (SolicitudFolioEnhanced) iter.next();
                    aux = this.getTurnoBySolicitud(sf.getSolicitud(), pm);
                    pm.makeTransient(aux);
                }

                query.closeAll();
            }
        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (Exception e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().commit();
            }

            pm.close();
        }

        if (aux != null) {
            rta = (Turno) aux.toTransferObject();
        }

        return rta;
    }

    /**
     * Retorna una lista de las oficinas origen de la vereda especificada, las
     * oficinas origen tienen el objeto TipoOficina
     *
     * @param oid Identificador de la vereda
     * @return Lista de OficinaOrigen
     * @throws DAOException
     */
    public List getOficinasOrigenByVereda(VeredaPk oid)
            throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        List rta = null;
        List rta2 = new ArrayList();
        OficinaOrigenEnhanced of;

        //TipoOficina tipo;
        try {
            rta = this.getOficinasOrigenByVereda(new VeredaEnhancedPk(oid), pm);

            for (Iterator itr = rta.iterator(); itr.hasNext();) {
                of = (OficinaOrigenEnhanced) itr.next();
                pm.makeTransient(of.getTipoOficina());
                pm.makeTransient(of);
                //Se requiere en nombre de la oficina origen en mayúsculas
                of.setNombre(of.getNombre().trim().toUpperCase());
                rta2.add(of);
            }
        } catch (DAOException e) {
            throw e;
        } finally {
            pm.close();
        }

        rta2 = TransferUtils.makeTransferAll(rta2);

        return rta2;
    }

    /**
     * Retorna una oficina origen el id del departamento, municipio, vereda y
     * oficina origen
     *
     * @param idDepartamento, idMunicipio,idVereda,idOficinaOrigen
     * @return OficinaOrigen
     * @throws DAOException
     */
    /*
                 *  @author Carlos Torres
                 *  @chage   se agrega validacion de version diferente
                 *  @mantis 0013414: Acta - Requerimiento No 069_453_Código_Notaria_NC
     */
    public OficinaOrigenEnhanced getOficinaOrigenByIds(String idDepartamento, String idMunicipio, String idVereda, String idOficinaOrigen, Long version)
            throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        OficinaOrigenEnhanced oficinaorigenenhanced = null;

        //TipoOficina tipo;
        try {
            Query query = pm.newQuery(OficinaOrigenEnhanced.class);
            /**
             * @author Fernando Padilla Velez
             * @change Mantis 3447, Se modifica la consulta para que solo filtre
             * por idOficinaOrigen.
             *
             */
            /**
             * @author Carlos Torres
             * @chage se agrega validacion de version diferente
             * @mantis 0013414: Acta - Requerimiento No
             * 069_453_Código_Notaria_NC
             */
            query.declareParameters("String idOficinaOrigen,Long version");
            /*
                 *  @author Carlos Torres
                 *  @chage   se agrega validacion de version diferente
                 *  @mantis 0013414: Acta - Requerimiento No 069_453_Código_Notaria_NC
             */
            query.setFilter("this.idOficinaOrigen==idOficinaOrigen && this.version==version");
            Collection col = (Collection) query.executeWithArray(new Object[]{idOficinaOrigen, version});
            //query.declareParameters("String idDepartamento, String idMunicipio, String idVereda, String idOficinaOrigen");
            //query.setFilter("this.vereda.idVereda==idVereda && this.vereda.idMunicipio==idMunicipio" +
            //"&& this.vereda.idDepartamento == idDepartamento && this.idOficinaOrigen==idOficinaOrigen");
            //Collection col = (Collection)query.executeWithArray(new Object[]{idDepartamento, idMunicipio, idVereda, idOficinaOrigen});

            for (Iterator iter = col.iterator(); iter.hasNext();) {
                oficinaorigenenhanced = (OficinaOrigenEnhanced) iter.next();
                pm.makeTransient(oficinaorigenenhanced);
                break;
            }
            query.closeAll();
            //pm.makeTransientAll(rta);
        } catch (JDOException e) {
            throw e;
        } finally {
            pm.close();
        }

        //rta2 = TransferUtils.makeTransferAll(rta2);
        return oficinaorigenenhanced;
    }

    /**
     * Retorna una lista de las oficinas origen de la vereda especificada de
     * manera transaccional
     *
     * @param oid Identificador de la vereda
     * @return Lista de OficinaOrigen
     * @throws DAOException
     */
    protected List getOficinasOrigenByVereda(VeredaEnhancedPk oid,
            PersistenceManager pm) throws DAOException {
        try {
            JDOGenieZonaRegistralDAO zonaRegistralDAO = new JDOGenieZonaRegistralDAO();
            VeredaEnhanced v = zonaRegistralDAO.getVereda(oid, pm);
            Query query = pm.newQuery(OficinaOrigenEnhanced.class);
            query.setOrdering("tipoOficina.nombre ascending, numero ascending");
            query.declareParameters("VeredaEnhanced v");
            query.setFilter("vereda == v");

            List rta = (List) query.execute(v);

            return rta;
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }
    }

    /**
     * Retorna una lista de las oficinas origen del municipio especificado de
     * manera transaccional
     *
     * @param oid Identificador del municipio
     * @return Lista de OficinaOrigen
     * @throws DAOException
     */
    protected List getOficinasOrigenByMunicipio(MunicipioEnhancedPk oid,
            PersistenceManager pm) throws DAOException {
        try {

            MunicipioEnhanced m = (MunicipioEnhanced) pm.getObjectById(oid, true);

            Query query = pm.newQuery(OficinaOrigenEnhanced.class);
            query.declareVariables("VeredaEnhanced v;");
            query.setOrdering("tipoOficina.nombre ascending, numero ascending");
            query.declareParameters("MunicipioEnhanced m");
            query.setFilter(
                    "this.vereda == v"
                    + "&& v.municipio == m"
            );

            List rta = (List) query.execute(m);
            return rta;
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }
    }

    /**
     *
     * @param busqueda
     * @param pm
     * @throws DAOException
     */
    protected void makeTransientBusqueda(BusquedaEnhanced busqueda,
            PersistenceManager pm) throws DAOException {
        if (busqueda != null) {
            try {
                for (Iterator itr = busqueda.getResultadosFolios().iterator();
                        itr.hasNext();) {
                    this.makeTransientResultadoFolio((ResultadoFolioEnhanced) itr.next(),
                            pm);
                }

                pm.makeTransientAll(busqueda.getResultadosFolios());
                pm.makeTransient(busqueda);
            } catch (JDOException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                throw new DAOException(e.getMessage(), e);
            }
        }
    }

    /**
     *
     * @param resultadoFolio
     * @param pm
     * @throws DAOException
     */
    protected void makeTransientResultadoFolio(
            ResultadoFolioEnhanced resultadoFolio, PersistenceManager pm)
            throws DAOException {
        if (resultadoFolio != null) {
            try {
                //this.makeTransientFolio(resultadoFolio.getFolio(), pm);
                for (Iterator itr = resultadoFolio.getResultadosAnotacions()
                        .iterator(); itr.hasNext();) {
                    this.makeTransientResultadoAnotacion((ResultadoAnotacionEnhanced) itr.next(),
                            pm);
                }

                pm.makeTransient(resultadoFolio);
            } catch (JDOException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                throw new DAOException(e.getMessage(), e);
            }
        }
    }

    /**
     *
     * @param resultadoAnotacion
     * @param pm
     * @throws DAOException
     */
    protected void makeTransientResultadoAnotacion(
            ResultadoAnotacionEnhanced resultadoAnotacion, PersistenceManager pm)
            throws DAOException {
        if (resultadoAnotacion != null) {
            try {
                this.makeTransientAnotacionBasico(resultadoAnotacion.getAnotacion(),
                        pm);
                pm.makeTransient(resultadoAnotacion.getCiudadanoPropietario());
                pm.makeTransient(resultadoAnotacion);
            } catch (JDOException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                throw new DAOException(e.getMessage(), e);
            }
        }
    }

    /**
     * Atiende una consulta dado el ID de la búsqueda
     *
     * @throws DAOException
     */
    public Busqueda ejecutarConsulta(BusquedaPk bid) throws DAOException {
        ForsetiProperties fp = ForsetiProperties.getInstancia();
        int numMaxConsulta = Integer.parseInt(fp.getProperty(
                ForsetiProperties.MAXIMO_REGISTROS_CONSULTA));
        PersistenceManager pm = AdministradorPM.getPM();
        BusquedaEnhanced busqueda = null;
        boolean ordenar = false;

        try {
            //Seteamos la transacción en pesimista para que
            //bloquee el registro de la búsqueda
            //pm.currentTransaction().setOptimistic(false);
            pm.currentTransaction().begin();

            busqueda = this.getBusqueda(new BusquedaEnhancedPk(bid), pm);

            if (busqueda == null) {
                throw new DAOException(
                        "No encontró una búsqueda con el id especificado: idBusqueda="
                        + bid.idBusqueda + " idSolicitud=" + bid.idSolicitud);
            }

            //Determinamos el tipo de consulta que se va a ejecutar
            //dependiendo de los parámetros dados:
            if ((busqueda.getApellido1Ciudadano() != null)
                    || (busqueda.getApellido2Ciudadano() != null)
                    || (busqueda.getNombreCiudadano() != null)
                    || (busqueda.getNumeroDocCiudadano() != null)
                    || (busqueda.getTipoDocCiudadano() != null)) {
                //Se debe ejecutar una búsqueda partiendo de
                //los datos de ciudadanos en anotaciones
                this.atenderConsultaAnotacionCiudadano(busqueda, pm, true);
                ordenar = true;
            } else if (busqueda.getNombreNaturalezaJuridica() != null) {
                //Se debe ejecutar la consulta tomando sólo en cuenta
                //los datos de anotación y folio
                this.atenderConsultaAnotacion(busqueda, pm, true);
            } else if ((busqueda.getIdEje() != null) || (busqueda.getValorEje() != null) || (busqueda.getDireccion() != null)) {
                //Se debe ejecutar la consulta partiendo de los datos
                //de dirección y folio
                this.atenderConsultaDireccion(busqueda, pm, true);

            } else {
                //Se debe ejecutar la consulta tomando sólo en cuenta
                //los folios
                this.atenderConsultaFolio(busqueda, pm, true);
            }

            pm.currentTransaction().commit();
            pm.close();

            //Se tuvo que cerrar el PM por error de INSTANCE DIRTY
            pm = AdministradorPM.getPM();

            pm.currentTransaction().setOptimistic(false);
            pm.currentTransaction().begin();
            busqueda = this.getBusqueda(new BusquedaEnhancedPk(bid), pm);

            //pm.refresh(busqueda);
            this.makeTransientBusqueda(busqueda, pm);

            pm.currentTransaction().commit();
        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (DAOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw e;
        } catch (Exception e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        if (busqueda != null) {
            Busqueda busquedaTMP = (Busqueda) busqueda.toTransferObject();
            if (ordenar) {
                /**
                 * *Ordenar las consultas por tipo de propietario y luego por
                 * matricula
                 */

                List resultadosFolios = busquedaTMP.getResultadosFoliosModificable();
                try {
                    Collections.sort(resultadosFolios, new ResultadoFolioComparator());
                } catch (Exception e) {
                    System.out.print("No se pudieron arreglar las consultas");
                }
                busquedaTMP.setResultadosFolios(resultadosFolios);

            }
            return busquedaTMP;
        } else {
            return null;
        }
    }

    /**
     * Atiende una consulta dado el ID de la búsqueda
     *
     * @throws DAOException
     */
    public Busqueda ejecutarConsultaAdministracion(Busqueda busquedaConsulta) throws DAOException {
        ForsetiProperties fp = ForsetiProperties.getInstancia();
        int numMaxConsulta = Integer.parseInt(fp.getProperty(
                ForsetiProperties.MAXIMO_REGISTROS_CONSULTA));
        PersistenceManager pm = AdministradorPM.getPM();
        boolean ordenar = false;
        //Busqueda.ID bid = new Busqueda.ID();

        BusquedaEnhanced busqueda = BusquedaEnhanced.enhance(busquedaConsulta);

        try {
            //Seteamos la transacción en pesimista para que
            //bloquee el registro de la búsqueda
            //pm.currentTransaction().setOptimistic(false);
            pm.currentTransaction().begin();

            //busqueda = this.getBusqueda(new BusquedaEnhanced.ID(bid), pm);

            /*if (busqueda == null) {
                throw new DAOException(
                    "No encontró una búsqueda con el id especificado: idBusqueda=" +
                    bid.idBusqueda + " idSolicitud=" + bid.idSolicitud);
            }*/
            //Determinamos el tipo de consulta que se va a ejecutar
            //dependiendo de los parámetros dados:
            if ((busqueda.getApellido1Ciudadano() != null)
                    || (busqueda.getApellido2Ciudadano() != null)
                    || (busqueda.getNombreCiudadano() != null)
                    || (busqueda.getNumeroDocCiudadano() != null)
                    || (busqueda.getTipoDocCiudadano() != null)) {
                //Se debe ejecutar una búsqueda partiendo de
                //los datos de ciudadanos en anotaciones
                this.atenderConsultaAnotacionCiudadano(busqueda, pm, false);
                ordenar = true;
            } else if (busqueda.getNombreNaturalezaJuridica() != null) {
                //Se debe ejecutar la consulta tomando sólo en cuenta
                //los datos de anotación y folio
                this.atenderConsultaAnotacion(busqueda, pm, false);
            } else if ((busqueda.getIdEje() != null) || (busqueda.getValorEje() != null) || (busqueda.getDireccion() != null)) {
                //Se debe ejecutar la consulta partiendo de los datos
                //de dirección y folio
                this.atenderConsultaDireccion(busqueda, pm, false);

            } else {
                //Se debe ejecutar la consulta tomando sólo en cuenta
                //los folios
                this.atenderConsultaFolio(busqueda, pm, false);
            }

            //pm.currentTransaction().commit();
            //pm.close();
            //Se tuvo que cerrar el PM por error de INSTANCE DIRTY
            //pm = AdministradorPM.getPM();
            // pm.currentTransaction().setOptimistic(false);
            //pm.currentTransaction().begin();
            //busqueda = this.getBusqueda(new BusquedaEnhanced.ID(bid), pm);
            //pm.refresh(busqueda);
            this.makeTransientBusqueda(busqueda, pm);

            pm.currentTransaction().commit();
        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (DAOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw e;
        } catch (Exception e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        if (busqueda != null) {
            Busqueda busquedaTMP = (Busqueda) busqueda.toTransferObject();
            if (ordenar) {
                /**
                 * *Ordenar las consultas por tipo de propietario y luego por
                 * matricula
                 */

                List resultadosFolios = busquedaTMP.getResultadosFoliosModificable();
                try {
                    Collections.sort(resultadosFolios, new ResultadoFolioComparator());
                } catch (Exception e) {
                    System.out.print("No se pudieron arreglar las consultas");
                }
                busquedaTMP.setResultadosFolios(resultadosFolios);

            }
            return busquedaTMP;
        } else {
            return null;
        }
    }

    /**
     *
     * @param persistente TODO
     * @param bid
     * @throws DAOException
     */
    protected void atenderConsultaAnotacion(BusquedaEnhanced busqueda,
            PersistenceManager pm, boolean persistente) throws DAOException {
        String valorToLow;

        ForsetiProperties fp = ForsetiProperties.getInstancia();
        int numMaxConsulta = Integer.parseInt(fp.getProperty(
                ForsetiProperties.MAXIMO_REGISTROS_CONSULTA));

        int mayorExt = Integer.parseInt(fp.getProperty(
                ForsetiProperties.MAYOR_EXTENSION));

        try {

            StringBuffer filtro = new StringBuffer("(1==1) ");

            StringBuffer variables = new StringBuffer();

            if (busqueda.getIdCirculoBusqueda() != null) {
                filtro.append("&& (idMatricula.startsWith(\"" + busqueda.getIdCirculoBusqueda() + "\")) ");
            }

            //PARA ANOTACIONES:
            if (busqueda.getNombreNaturalezaJuridica() != null) {
                valorToLow = busqueda.getNombreNaturalezaJuridica().toUpperCase();
                filtro.append("&& (naturalezaJuridica.nombre.startsWith(\""
                        + valorToLow + "\")) ");
            }

            String consMatricula;

            if (busqueda.getMatricula() != null) {
                filtro.append("&& (folio.idMatricula==\""
                        + busqueda.getMatricula().toUpperCase() + "\") ");
            }

            if (busqueda.getNumeroCatastral() != null) {
                filtro.append("&& (folio.codCatastral==\""
                        + busqueda.getNumeroCatastral().toUpperCase() + "\") ");
            }

            if (busqueda.getIdTipoPredio() != null) {
                filtro.append("&& (folio.tipoPredio.idPredio==\""
                        + busqueda.getIdTipoPredio() + "\") ");
            }

            //Se pone filtro para que no busque en los folios obsoletos
            filtro.append("&& (folio.estado.idEstado!='" + CEstadoFolio.OBSOLETO
                    + "') && (folio.definitivo==true) ");

            /*
                         * @author      :   Julio Alcázar Rivas
                         * @change      :   Se filtran los folios que esten en estado Trasladado, para no obtenerlos.
                         * Caso Mantis  :   07123
             */
            filtro.append("&& (folio.estado.idEstado!='" + CEstadoFolio.TRASLADADO + "') ");

            /*
			filtro.append("(folio.estado.idEstado!='" +
					 CEstadoFolio.OBSOLETO + "') && (folio.definitivo==true) ");
			 filtro.append("&& (estado.idEstadoAn!='" +
				 CEstadoAnotacion.OBSOLETA + "') ");


            if (busqueda.getIdCirculoBusqueda() != null) {
                filtro.append("&& (folio.zonaRegistral.circulo.idCirculo==\"" +
                    busqueda.getIdCirculoBusqueda() + "\") ");
            }*/
            if ((busqueda.getDireccion() != null)
                    || (busqueda.getIdEje() != null)
                    || (busqueda.getValorEje() != null)) {
                filtro.append("&& (folio.direcciones.contains(dir)) ");
                variables.append("DireccionEnhanced dir; ");

                if (busqueda.getDireccion() != null) {
                    valorToLow = busqueda.getDireccion().toUpperCase();
                    filtro.append("&& (dir.especificacion.startsWith(\""
                            + valorToLow + "\") || dir.especificacion.endsWith(\""
                            + valorToLow + "\")) ");
                }

                if (busqueda.getIdEje() != null) {
                    filtro.append("&& (dir.eje.idEje==\""
                            + busqueda.getIdEje() + "\") ");
                }

                if (busqueda.getValorEje() != null) {
                    valorToLow = busqueda.getValorEje().toUpperCase();
                    filtro.append("&& (dir.valorEje.startsWith(\""
                            + valorToLow + "\") || dir.valorEje.endsWith(\""
                            + valorToLow + "\")) ");
                }
            }

            /*
            VersantQuery query = (VersantQuery) pm.newQuery(AnotacionEnhanced.class);
            query.declareVariables(variables.toString());
            query.setFilter(filtro.toString());
            query.setOrdering("folio.idMatricula ascending");
            query.setGrouping("folio.idMatricula");
            query.setResult("folio.idMatricula, count(idMatricula)");

            List res = (List) query.execute();

            long numeroResultadosFolios = res.size();
            query.closeAll();

            //Caso especial para anotaciones, dependen del número de folios
            //if(numeroResultados)
            int maximoAuxiliar = numMaxConsulta;

            if (numeroResultadosFolios > numMaxConsulta) {
                query = (VersantQuery) pm.newQuery(AnotacionEnhanced.class);
                query.declareVariables(variables.toString());
                query.setFilter(filtro.toString());
                query.setResult("count(this)");

                long numeroResultadosAnotaciones = ((Long) query.execute()).longValue();
                query.closeAll();

                int anotacionesXFolio = (int) ((int) numeroResultadosAnotaciones / numeroResultadosFolios);
                maximoAuxiliar = anotacionesXFolio * numMaxConsulta;
                logEstatico.info("numeroResultadosAnotaciones " +
                    numeroResultadosAnotaciones);
            }

            logEstatico.info("numeroResultadosFolios " +
                numeroResultadosFolios);
            logEstatico.info("maximoAuxiliar " + maximoAuxiliar);
             */
            VersantQuery query = (VersantQuery) pm.newQuery(AnotacionEnhanced.class);
            query.declareVariables(variables.toString());
            query.setFilter(filtro.toString());
            query.setOrdering("folio.idMatricula ascending");
            query.setMaxRows(numMaxConsulta);

            List rta = (List) query.execute();
            FolioEnhanced folio;
            ResultadoFolioEnhanced rf;
            ResultadoAnotacionEnhanced ra;

            List listToDelete = busqueda.getResultadosFolios();

            if (persistente) {
                pm.deletePersistentAll(busqueda.getResultadosFolios());

                //Ejecutamos el borrado de los resultados
                VersantPersistenceManager pm2 = (VersantPersistenceManager) pm;
                pm2.flush();
            }

            ResultadoFolioEnhanced currentResultadoFolio;
            AnotacionEnhanced anota;

            Iterator itr = rta.iterator();
            int numeroResultadosFolios = 0;
            /**
             * @author : Julio Alcazar
             * @change : Revision: Validacion bloqueo por traslado. Caso Mantis
             * : 0007676: Acta - Requerimiento No 247 - Traslado de Folios V2
             */
            TrasladoSIR trasladoSIR = new TrasladoSIR();

            if (itr.hasNext()) {
                anota = (AnotacionEnhanced) itr.next();
                rf = new ResultadoFolioEnhanced();
                rf.setFolio(anota.getFolio());
                rf.setBusqueda(busqueda);

                if (this.getCountAnotacionesFolio(anota.getFolio(), pm) > mayorExt) {
                    rf.setMayorExtension(true);
                } else {
                    rf.setMayorExtension(false);
                }

                FolioEnhancedPk fid = new FolioEnhancedPk();
                fid.idMatricula = anota.getIdMatricula();

                DireccionEnhanced dirAux = this.getUltimaDireccion(fid, pm);

                if (dirAux != null) {
                    rf.setLastDireccion(dirAux.getEspecificacion());
                }

                ra = new ResultadoAnotacionEnhanced();
                ra.setAnotacion(anota);
                ra.setResultadoFolio(rf);
                currentResultadoFolio = rf;
                rf.addResultadosAnotacion(ra);
                /**
                 * @author : Julio Alcazar
                 * @change : Revision: Validacion bloqueo por traslado. Caso
                 * Mantis : 0007676: Acta - Requerimiento No 247 - Traslado de
                 * Folios V2
                 */
                if (!trasladoSIR.isTrasladoSinConf(rf.getIdMatricula())) {
                    busqueda.addResultadosFolio(rf);
                }
                numeroResultadosFolios++;

                while (itr.hasNext()) {
                    anota = (AnotacionEnhanced) itr.next();

                    if (((FolioEnhancedPk) pm.getObjectId(rf.getFolio())).equals(
                            (FolioEnhancedPk) pm.getObjectId(
                                    anota.getFolio()))) {
                        ra = new ResultadoAnotacionEnhanced();
                        ra.setAnotacion(anota);
                        ra.setResultadoFolio(currentResultadoFolio);
                        currentResultadoFolio.addResultadosAnotacion(ra);
                    } else {
                        rf = new ResultadoFolioEnhanced();
                        rf.setFolio(anota.getFolio());
                        rf.setBusqueda(busqueda);

                        if (this.getCountAnotacionesFolio(anota.getFolio(), pm) > mayorExt) {
                            rf.setMayorExtension(true);
                        } else {
                            rf.setMayorExtension(false);
                        }

                        fid = new FolioEnhancedPk();
                        fid.idMatricula = anota.getIdMatricula();
                        dirAux = this.getUltimaDireccion(fid, pm);

                        if (dirAux != null) {
                            rf.setLastDireccion(dirAux.getEspecificacion());
                        }

                        ra = new ResultadoAnotacionEnhanced();
                        ra.setAnotacion(anota);
                        ra.setResultadoFolio(rf);
                        currentResultadoFolio = rf;
                        rf.addResultadosAnotacion(ra);
                        /**
                         * @author : Julio Alcazar
                         * @change : Revision: Validacion bloqueo por traslado.
                         * Caso Mantis : 0007676: Acta - Requerimiento No 247 -
                         * Traslado de Folios V2
                         */
                        if (!trasladoSIR.isTrasladoSinConf(rf.getIdMatricula())) {
                            busqueda.addResultadosFolio(rf);
                        }
                    }
                    numeroResultadosFolios++;
                }
            }

            busqueda.setNumeroResultados(numeroResultadosFolios);

            //busqueda.setNumeroIntento(busqueda.getNumeroIntento() + 1);
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } /**
         * @author : Julio Alcazar
         * @change : Revision: Validacion bloqueo por traslado. Caso Mantis :
         * 0007676: Acta - Requerimiento No 247 - Traslado de Folios V2
         */
        catch (GeneralSIRException ex) {
            Log.getInstance().error(JDOGenieFolioDAO.class, ex.getMessage());
            throw new DAOException(ex.getMessage(), ex);
        }
    }

    /**
     *
     * @param busqueda
     * @param pm
     * @param persistente TODO
     * @throws DAOException
     */
    protected void atenderConsultaAnotacionCiudadano(
            BusquedaEnhanced busqueda, PersistenceManager pm, boolean persistente)
            throws DAOException {
        String valorToLow;

        ForsetiProperties fp = ForsetiProperties.getInstancia();
        int numMaxConsulta = Integer.parseInt(fp.getProperty(
                ForsetiProperties.MAXIMO_REGISTROS_CONSULTA));

        int mayorExt = Integer.parseInt(fp.getProperty(
                ForsetiProperties.MAYOR_EXTENSION));

        try {
            StringBuffer filtro = new StringBuffer("(this.ciudadano.solicitante == '0') ");
            StringBuffer variables = new StringBuffer();
            StringBuffer parametrosDec = new StringBuffer();
            List parametros = new ArrayList();

            CiudadanoEnhanced ciudadanoEnh = null;

            if ((busqueda.getApellido1Ciudadano() != null)
                    || (busqueda.getApellido2Ciudadano() != null)
                    || (busqueda.getNombreCiudadano() != null)
                    || (busqueda.getTipoDocCiudadano() != null)
                    || (busqueda.getNumeroDocCiudadano() != null)) {

                /*				SE ELIMINA LA CONSULTA DE ESTA MANERA PORQUE AHORA EN LA TABLA DE CIUDADANOS SE ALMACENA EL CIRCULO DEL CUAL HACEN PARTE
				if (busqueda.getIdCirculoBusqueda() != null) {
					filtro.append("&& (anotacion.folio.zonaRegistral.circulo.idCirculo==\"" +busqueda.getIdCirculoBusqueda()+ "\") ");
				}
                 */
                if (busqueda.getIdCirculoBusqueda() != null) {
                    filtro.append("&& (this.ciudadano.idCirculo==\"" + busqueda.getIdCirculoBusqueda() + "\") ");
                }

                if (busqueda.getApellido1Ciudadano() != null) {
                    valorToLow = busqueda.getApellido1Ciudadano().toUpperCase();
                    filtro.append("&& this.ciudadano.apellido1.startsWith(\""
                            + valorToLow + "\") ");
                }

                if (busqueda.getApellido2Ciudadano() != null) {
                    valorToLow = busqueda.getApellido2Ciudadano().toUpperCase();
                    filtro.append("&& this.ciudadano.apellido2.startsWith(\""
                            + valorToLow + "\") ");
                }

                if (busqueda.getNombreCiudadano() != null) {
                    valorToLow = busqueda.getNombreCiudadano().toUpperCase();
                    filtro.append("&& this.ciudadano.nombre.startsWith(\""
                            + valorToLow + "\") ");
                }

                if (busqueda.getTipoDocCiudadano() != null) {
                    if (busqueda.getNumeroDocCiudadano() != null) {
                        valorToLow = busqueda.getTipoDocCiudadano().toUpperCase();
                        filtro.append("&& (this.ciudadano.tipoDoc==\""
                                + valorToLow + "\") ");
                    } //SE COLOCO LA CONDICION DE QUE COLOQUE EL TIPO DE DOCUMENTO
                    //SI VIENE SIN NOMBRE NI APELLIDO2, YA QUE EN ESTOS CASOS 
                    else if (busqueda.getApellido2Ciudadano() == null && busqueda.getNombreCiudadano() == null) {
                        valorToLow = busqueda.getTipoDocCiudadano().toUpperCase();
                        filtro.append("&& (this.ciudadano.tipoDoc==\""
                                + valorToLow + "\") ");
                    }
                } else if (busqueda.getApellido1Ciudadano() != null
                        && busqueda.getApellido2Ciudadano() == null
                        && busqueda.getNombreCiudadano() == null
                        && busqueda.getTipoDocCiudadano() == null
                        && busqueda.getNumeroDocCiudadano() == null) {
                    Collection col = new ArrayList();
                    col.add(CCiudadano.TIPO_DOC_ID_NIT);
                    col.add(CCiudadano.TIPO_DOC_ID_SECUENCIA);

                    filtro.append("&& tDocs.contains(this.ciudadano.tipoDoc)");
                    String p = parametrosDec.length() > 0 ? ", " : "";
                    parametrosDec.append(p);
                    parametrosDec.append("Collection tDocs");
                    parametros.add(col);
                    //filtro.append("&& (this.ciudadano.tipoDoc==\"" + CCiudadano.TIPO_DOC_ID_NIT + "\" || this.ciudadano.tipoDoc==\"" + CCiudadano.TIPO_DOC_ID_SECUENCIA + "\"  ) ");
                }

                if (busqueda.getNumeroDocCiudadano() != null) {
                    valorToLow = busqueda.getNumeroDocCiudadano().toUpperCase();
                    filtro.append("&& (this.ciudadano.documento==\""
                            + valorToLow + "\") ");
                }

                filtro.append("&& (this.rolPersona ==\"A\")");

            }

            //PARA ANOTACIONES:
            if (busqueda.getNombreNaturalezaJuridica() != null) {
                valorToLow = busqueda.getNombreNaturalezaJuridica().toUpperCase();
                filtro.append(
                        "&& (anotacion.naturalezaJuridica.nombre.startsWith(\""
                        + valorToLow
                        + "\") || anotacion.naturalezaJuridica.nombre.endsWith(\""
                        + valorToLow + "\")) ");
            }

            //Se pone filtro para que no busque en los folios obsoletos
            filtro.append("&& (anotacion.folio.estado.idEstado!='" + CEstadoFolio.OBSOLETO
                    + "') && (anotacion.folio.definitivo==true) ");

            /*
                         * @author      :   Julio Alcázar Rivas
                         * @change      :   Se filtran los folios que esten en estado Trasladado, para no obtenerlos.
                         * Caso Mantis  :   07123
             */
            filtro.append("&& (anotacion.folio.estado.idEstado!='" + CEstadoFolio.TRASLADADO + "') ");

            String consMatricula;

            if (busqueda.getMatricula() != null) {
                filtro.append("&& (anotacion.folio.idMatricula==\""
                        + busqueda.getMatricula().toUpperCase() + "\") ");
            }

            if (busqueda.getNumeroCatastral() != null) {
                filtro.append("&& (anotacion.folio.codCatastral==\""
                        + busqueda.getNumeroCatastral().toUpperCase() + "\") ");
            }

            if (busqueda.getIdTipoPredio() != null) {
                filtro.append("&& (anotacion.folio.tipoPredio.idPredio==\""
                        + busqueda.getIdTipoPredio() + "\") ");
            }

            if ((busqueda.getDireccion() != null)
                    || (busqueda.getIdEje() != null)
                    || (busqueda.getValorEje() != null)) {
                filtro.append("&& (anotacion.folio.direcciones.contains(dir)) ");
                variables.append("DireccionEnhanced dir; ");

                if (busqueda.getDireccion() != null) {
                    valorToLow = busqueda.getDireccion().toUpperCase();
                    filtro.append("&& (dir.especificacion.startsWith(\""
                            + valorToLow + "\") || dir.especificacion.endsWith(\""
                            + valorToLow + "\")) ");
                }

                if (busqueda.getIdEje() != null) {
                    filtro.append("&& (dir.eje.idEje==\""
                            + busqueda.getIdEje() + "\") ");
                }

                if (busqueda.getValorEje() != null) {
                    valorToLow = busqueda.getValorEje().toUpperCase();
                    filtro.append("&& (dir.valorEje.startsWith(\""
                            + valorToLow + "\") || dir.valorEje.endsWith(\""
                            + valorToLow + "\")) ");
                }
            }
            /*
             * @author      :   Ellery David Robles Gómez
             * @change      :   Se filtran las anotaciones que esten en estado INVALIDA, para no obtenerlas.
             * Caso Mantis  :   07228
             */
            filtro.append("&& (anotacion.estado.idEstadoAn!='" + CEstadoAnotacion.INVALIDO + "') ");

            if (busqueda.getIdCirculoBusqueda() != null) {
                filtro.append("&& (anotacion.folio.zonaRegistral.circulo.idCirculo==\"" + busqueda.getIdCirculoBusqueda() + "\") ");
            }

            //INCIDENCIA MANTIS 10707. UNICAMENTE TRAER ANOTACIONES DE MUTACION
            filtro.append(" && (this.anotacion.naturalezaJuridica.dominioNaturalezaJuridica.idDominioNatJur == \"" + CDominioNaturalezaJuridica.ID_MUTACION + "\" ) ");

            /*
            VersantQuery query = (VersantQuery) pm.newQuery(AnotacionCiudadanoEnhanced.class);
            query.declareVariables(variables.toString());
            query.setFilter(filtro.toString());

            query.setOrdering(
                "anotacion.folio.idMatricula ascending, anotacion.idAnotacion ascending");
            query.setGrouping("anotacion.folio.idMatricula");
            query.setResult("anotacion.folio.idMatricula, count(idMatricula)");

			//logEstatico.debug("\n*******************************************************");
			//logEstatico.debug("(CON) Comienza primera consulta: "+busqueda.getIdSolicitud()+"N"+busqueda.getIdBusqueda());
			//logEstatico.debug("*******************************************************\n");

			//logEstatico.debug("\n*******************************************************");
			//logEstatico.debug("(CON) QUERY1: "+filtro.toString());
			//logEstatico.debug("*******************************************************\n");

			//logEstatico.debug("\n*******************************************************");
			//logEstatico.debug("(CON) VARIABLES1: "+variables.toString());
            //logEstatico.debug("*******************************************************\n");

            List res = (List) query.execute();
            QueryLogger.debug(pm,query,new Object[]{});
            
            long numeroResultadosFolios = res.size();

            //logEstatico.debug("\n*******************************************************");
            //logEstatico.debug("(CON) Termina primera consulta: "+busqueda.getIdSolicitud()+"N"+busqueda.getIdBusqueda()+" (resultados): "+numeroResultadosFolios);
            //logEstatico.debug("*******************************************************\n");
            
            query.closeAll();

            //Caso especial para anotaciones, dependen del número de folios
            //if(numeroResultados)
            int maximoAuxiliar = numMaxConsulta;

            if (numeroResultadosFolios > numMaxConsulta) {
                query = (VersantQuery) pm.newQuery(AnotacionCiudadanoEnhanced.class);
                query.declareVariables(variables.toString());
                query.setFilter(filtro.toString());
                query.setResult("count(this)");

                //logEstatico.debug("\n*******************************************************");
                //logEstatico.debug("(CON) Comienza MITAD consulta: "+busqueda.getIdSolicitud()+"N"+busqueda.getIdBusqueda());
                //logEstatico.debug("*******************************************************\n");

                //logEstatico.debug("\n*******************************************************");
                //logEstatico.debug("(CON) QUERY1.5: "+filtro.toString());
                //logEstatico.debug("*******************************************************\n");

                //logEstatico.debug("\n*******************************************************");
                //logEstatico.debug("(CON) VARIABLES1.5: "+variables.toString());
                //logEstatico.debug("*******************************************************\n");

                long numeroResultadosAnotaciones = ((Long) query.execute()).longValue();
                QueryLogger.debug(pm, query, new Object[]{});
                
                query.closeAll();

                int anotacionesXFolio = (int) ((int) numeroResultadosAnotaciones / numeroResultadosFolios);
                maximoAuxiliar = anotacionesXFolio * numMaxConsulta;
                //logEstatico.debug("\n*******************************************************");
                //logEstatico.debug("(CON) Termina MITAD consulta: "+busqueda.getIdSolicitud()+"N"+busqueda.getIdBusqueda()+" (resultados): "+numeroResultadosAnotaciones);
                //logEstatico.debug("*******************************************************\n");

                logEstatico.info("numeroResultadosAnotaciones " +
                    numeroResultadosAnotaciones);
            }

            logEstatico.info("numeroResultadosFolios " +
                numeroResultadosFolios);
             */
            Log.getInstance().info(JDOGenieFolioDAO.class, "maximoAuxiliar " + numMaxConsulta);
            VersantQuery query = (VersantQuery) pm.newQuery(AnotacionCiudadanoEnhanced.class);
            query.declareParameters(parametrosDec.toString());
            query.declareVariables(variables.toString());
            query.setFilter(filtro.toString());
            query.setOrdering(
                    "anotacion.folio.idMatricula ascending, anotacion.idAnotacion ascending");
            query.setMaxRows(numMaxConsulta);

            //logEstatico.debug("\n*******************************************************");
            //logEstatico.debug("(CON) Comienza segunda consulta: "+busqueda.getIdSolicitud()+"N"+busqueda.getIdBusqueda());
            //logEstatico.debug("*******************************************************\n");
            //logEstatico.debug("\n*******************************************************");
            //logEstatico.debug("(CON) QUERY2: "+filtro.toString());
            //logEstatico.debug("*******************************************************\n");
            //logEstatico.debug("\n*******************************************************");
            //logEstatico.debug("(CON) VARIABLES2: "+variables.toString());
            //logEstatico.debug("*******************************************************\n");
            List rta = (List) query.executeWithArray(parametros.toArray());

            //logEstatico.debug("\n*******************************************************");
            //logEstatico.debug("(CON) Termina segunda consulta: "+busqueda.getIdSolicitud()+"N"+busqueda.getIdBusqueda());
            //logEstatico.debug("*******************************************************\n");
            FolioEnhanced folio;
            ResultadoFolioEnhanced rf;
            ResultadoAnotacionEnhanced ra;

            List listToDelete = busqueda.getResultadosFolios();

            if (persistente) {
                pm.deletePersistentAll(busqueda.getResultadosFolios());

                //Ejecutamos el borrado de los resultados
                VersantPersistenceManager pm2 = (VersantPersistenceManager) pm;
                pm2.flush();
            }

            ResultadoFolioEnhanced currentResultadoFolio;
            AnotacionCiudadanoEnhanced anota;

            int numeroResultadosFolios = 0;
            Iterator itr = rta.iterator();
            /**
             * @author : Julio Alcazar
             * @change : Revision: Validacion bloqueo por traslado. Caso Mantis
             * : 0007676: Acta - Requerimiento No 247 - Traslado de Folios V2
             */
            TrasladoSIR trasladoSIR = new TrasladoSIR();

            if (itr.hasNext()) {
                anota = (AnotacionCiudadanoEnhanced) itr.next();
                rf = new ResultadoFolioEnhanced();
                rf.setFolio(anota.getAnotacion().getFolio());
                rf.setEstadoFolio(anota.getAnotacion().getFolio().getEstado().getNombre());
                rf.setBusqueda(busqueda);

                if (this.getCountAnotacionesFolio(anota.getAnotacion().getFolio(),
                        pm) > mayorExt) {
                    rf.setMayorExtension(true);
                } else {
                    rf.setMayorExtension(false);
                }

                FolioEnhancedPk fid = new FolioEnhancedPk();
                fid.idMatricula = anota.getIdMatricula();

                DireccionEnhanced dirAux = this.getUltimaDireccion(fid, pm);

                if (dirAux != null) {
                    rf.setLastDireccion(dirAux.getEspecificacion());
                }

                ra = new ResultadoAnotacionEnhanced();
                ra.setAnotacion(anota.getAnotacion());

                //TODO CIUDADANO_TITULAR Cambiar la marca propietario del resultado anotación
                ra.setPropietario(this.isUltimoPropietario(anota, pm));
                ra.setCiudadanoPropietario(anota.getCiudadano());
                ra.setResultadoFolio(rf);
                currentResultadoFolio = rf;
                rf.addResultadosAnotacion(ra);
                /**
                 * @author : Julio Alcazar
                 * @change : Revision: Validacion bloqueo por traslado. Caso
                 * Mantis : 0007676: Acta - Requerimiento No 247 - Traslado de
                 * Folios V2
                 */
                if (!trasladoSIR.isTrasladoSinConf(rf.getIdMatricula())) {
                    busqueda.addResultadosFolio(rf);
                }
                numeroResultadosFolios++;

                while (itr.hasNext()) {
                    anota = (AnotacionCiudadanoEnhanced) itr.next();

                    if (((FolioEnhancedPk) pm.getObjectId(rf.getFolio())).equals(
                            (FolioEnhancedPk) pm.getObjectId(
                                    anota.getAnotacion().getFolio()))) {

                        if (!((AnotacionEnhancedPk) pm.getObjectId(
                                ra.getAnotacion())).equals(
                                (AnotacionEnhancedPk) pm.getObjectId(
                                        anota.getAnotacion()))) {

                            ra = new ResultadoAnotacionEnhanced();
                            ra.setAnotacion(anota.getAnotacion());
                            ra.setPropietario(this.isUltimoPropietario(anota, pm));
                            ra.setCiudadanoPropietario(anota.getCiudadano());
                            ra.setResultadoFolio(currentResultadoFolio);
                            currentResultadoFolio.addResultadosAnotacion(ra);
                        } else {
                            if (!ra.isPropietario()) {
                                rf.removeResultadosAnotacion(ra);
                                ra = new ResultadoAnotacionEnhanced();
                                ra.setAnotacion(anota.getAnotacion());
                                ra.setPropietario(this.isUltimoPropietario(anota, pm));
                                ra.setCiudadanoPropietario(anota.getCiudadano());
                                ra.setResultadoFolio(currentResultadoFolio);
                                rf.addResultadosAnotacion(ra);
                            }
                        }
                    } else {
                        rf = new ResultadoFolioEnhanced();
                        rf.setFolio(anota.getAnotacion().getFolio());
                        rf.setEstadoFolio(anota.getAnotacion().getFolio().getEstado().getNombre());
                        rf.setBusqueda(busqueda);

                        if (this.getCountAnotacionesFolio(
                                anota.getAnotacion().getFolio(), pm) > mayorExt) {
                            rf.setMayorExtension(true);
                        } else {
                            rf.setMayorExtension(false);
                        }

                        fid = new FolioEnhancedPk();
                        fid.idMatricula = anota.getIdMatricula();

                        dirAux = this.getUltimaDireccion(fid, pm);

                        if (dirAux != null) {
                            rf.setLastDireccion(dirAux.getEspecificacion());
                        }

                        ra = new ResultadoAnotacionEnhanced();
                        ra.setAnotacion(anota.getAnotacion());
                        ra.setResultadoFolio(rf);
                        ra.setPropietario(this.isUltimoPropietario(anota, pm));
                        ra.setCiudadanoPropietario(anota.getCiudadano());
                        currentResultadoFolio = rf;
                        rf.addResultadosAnotacion(ra);
                        /**
                         * @author : Julio Alcazar
                         * @change : Revision: Validacion bloqueo por traslado.
                         * Caso Mantis : 0007676: Acta - Requerimiento No 247 -
                         * Traslado de Folios V2
                         */
                        if (!trasladoSIR.isTrasladoSinConf(rf.getIdMatricula())) {
                            busqueda.addResultadosFolio(rf);
                        }
                    }
                    numeroResultadosFolios++;
                }
            }
            busqueda.setNumeroResultados(numeroResultadosFolios);

            //busqueda.setNumeroIntento(busqueda.getNumeroIntento() + 1);
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } /**
         * @author : Julio Alcazar
         * @change : Revision: Validacion bloqueo por traslado. Caso Mantis :
         * 0007676: Acta - Requerimiento No 247 - Traslado de Folios V2
         */
        catch (GeneralSIRException ex) {
            Log.getInstance().error(JDOGenieFolioDAO.class, ex.getMessage());
            throw new DAOException(ex.getMessage(), ex);
        }
    }

    /**
     *
     * @param busqueda
     * @param pm
     * @param persistente TODO
     * @throws DAOException
     */
    protected void atenderConsultaDireccion(
            BusquedaEnhanced busqueda, PersistenceManager pm, boolean persistente)
            throws DAOException {
        String valorToLow;

        ForsetiProperties fp = ForsetiProperties.getInstancia();
        int numMaxConsulta = Integer.parseInt(fp.getProperty(
                ForsetiProperties.MAXIMO_REGISTROS_CONSULTA));

        int mayorExt = Integer.parseInt(fp.getProperty(
                ForsetiProperties.MAYOR_EXTENSION));

        try {
            StringBuffer filtro = new StringBuffer("(1==1) ");

            String consMatricula;

            if (busqueda.getIdCirculoBusqueda() != null) {
                filtro.append("&& (folio.zonaRegistral.circulo.idCirculo==\"" + busqueda.getIdCirculoBusqueda() + "\") ");
            }

            if (busqueda.getDireccion() != null) {
                valorToLow = busqueda.getDireccion().toUpperCase();
                filtro.append("&& (especificacion.endsWith(\""
                        + valorToLow + "\") ) ");
            }

            if (busqueda.getIdEje() != null) {
                filtro.append("&& (eje.idEje==\""
                        + busqueda.getIdEje() + "\") ");
            }

            if (busqueda.getValorEje() != null) {
                valorToLow = busqueda.getValorEje().toUpperCase();
                filtro.append("&& (valorEje.startsWith(\""
                        + valorToLow + "\")) ");
            }

            //Se pone filtro para que no busque en los folios obsoletos
            filtro.append("&& (folio.estado.idEstado!='" + CEstadoFolio.OBSOLETO
                    + "') && (folio.definitivo==true) ");

            /*
                         * @author      :   Julio Alcázar Rivas
                         * @change      :   Se filtran los folios que esten en estado Trasladado, para no obtenerlos.
                         * Caso Mantis  :   07123
             */
            filtro.append("&& (folio.estado.idEstado!='" + CEstadoFolio.TRASLADADO + "') ");

            //Criterios de folio:
            if (busqueda.getMatricula() != null) {
                filtro.append("&& (folio.idMatricula==\""
                        + busqueda.getMatricula().toUpperCase() + "\") ");
            }

            if (busqueda.getNumeroCatastral() != null) {
                filtro.append("&& (folio.codCatastral==\""
                        + busqueda.getNumeroCatastral().toUpperCase() + "\") ");
            }

            if (busqueda.getIdTipoPredio() != null) {
                filtro.append("&& (folio.tipoPredio.idPredio==\""
                        + busqueda.getIdTipoPredio() + "\") ");
            }


            /*
			VersantQuery query = (VersantQuery) pm.newQuery(DireccionEnhanced.class);
			query.setFilter(filtro.toString());
			query.setResult("count(this)");


			//logEstatico.debug("\n*******************************************************");
			//logEstatico.debug("(CON) Comienza primera consulta direccion: "+busqueda.getIdSolicitud()+"N"+busqueda.getIdBusqueda());
			//logEstatico.debug("*******************************************************\n");

			//logEstatico.debug("\n*******************************************************");
			//logEstatico.debug("(CON) QUERY1_DIR: "+filtro.toString());
			//logEstatico.debug("*******************************************************\n");

			long numeroResultadosDirecciones = ((Long) query.execute()).longValue();
			query.closeAll();

			//logEstatico.debug("\n*******************************************************");
			//logEstatico.debug("(CON) Termina primera consulta direccion: "+busqueda.getIdSolicitud()+"N"+busqueda.getIdBusqueda());
			//logEstatico.debug("*******************************************************\n");

			logEstatico.info("numeroResultadosDirecciones " +
				numeroResultadosDirecciones);
			logEstatico.info("numMaxConsulta " + numMaxConsulta);
             */
            VersantQuery query = (VersantQuery) pm.newQuery(DireccionEnhanced.class);
            query.setFilter(filtro.toString());
            query.setOrdering("folio.idMatricula ascending, idDireccion ascending");
            query.setMaxRows(numMaxConsulta);

            //logEstatico.debug("\n*******************************************************");
            //logEstatico.debug("(CON) Comienza segunda consulta direccion: "+busqueda.getIdSolicitud()+"N"+busqueda.getIdBusqueda());
            //logEstatico.debug("*******************************************************\n");
            //logEstatico.debug("\n*******************************************************");
            //logEstatico.debug("(CON) QUERY2_DIR: "+filtro.toString());
            //logEstatico.debug("*******************************************************\n");
            List rta = (List) query.execute();

            //logEstatico.debug("\n*******************************************************");
            //logEstatico.debug("(CON) Termina segunda consulta direccion: "+busqueda.getIdSolicitud()+"N"+busqueda.getIdBusqueda());
            //logEstatico.debug("*******************************************************\n");
            FolioEnhanced folio;
            ResultadoFolioEnhanced rf;
            ResultadoAnotacionEnhanced ra;

            List listToDelete = busqueda.getResultadosFolios();

            if (persistente) {
                pm.deletePersistentAll(busqueda.getResultadosFolios());

                //Ejecutamos el borrado de los resultados
                VersantPersistenceManager pm2 = (VersantPersistenceManager) pm;
                pm2.flush();
            }

            DireccionEnhanced aux;
            FolioEnhanced folioAnterior = new FolioEnhanced();

            int numeroResultadosDirecciones = 0;
            /**
             * @author : Julio Alcazar
             * @change : Revision: Validacion bloqueo por traslado. Caso Mantis
             * : 0007676: Acta - Requerimiento No 247 - Traslado de Folios V2
             */
            TrasladoSIR trasladoSIR = new TrasladoSIR();

            for (Iterator itr = rta.iterator(); itr.hasNext();) {
                rf = new ResultadoFolioEnhanced();
                aux = (DireccionEnhanced) itr.next();

                if (this.getCountAnotacionesFolio(aux.getFolio(),
                        pm) > mayorExt) {
                    rf.setMayorExtension(true);
                } else {
                    rf.setMayorExtension(false);
                }

                FolioEnhancedPk fid = new FolioEnhancedPk();
                fid.idMatricula = aux.getIdMatricula();

                DireccionEnhanced dirAux = this.getUltimaDireccion(fid, pm);

                if (dirAux != null) {
                    rf.setLastDireccion(dirAux.getEspecificacion());
                }

                if (!aux.getFolio().getIdMatricula().equals(folioAnterior.getIdMatricula())) {
                    rf.setFolio(aux.getFolio());
                    rf.setBusqueda(busqueda);
                    /**
                     * @author : Julio Alcazar
                     * @change : Revision: Validacion bloqueo por traslado. Caso
                     * Mantis : 0007676: Acta - Requerimiento No 247 - Traslado
                     * de Folios V2
                     */
                    if (!trasladoSIR.isTrasladoSinConf(rf.getIdMatricula())) {
                        busqueda.addResultadosFolio(rf);
                    }
                    folioAnterior = aux.getFolio();
                }
                numeroResultadosDirecciones++;
            }

            busqueda.setNumeroResultados(numeroResultadosDirecciones);

            //busqueda.setNumeroIntento(busqueda.getNumeroIntento() + 1);
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } /**
         * @author : Julio Alcazar
         * @change : Revision: Validacion bloqueo por traslado. Caso Mantis :
         * 0007676: Acta - Requerimiento No 247 - Traslado de Folios V2
         */
        catch (GeneralSIRException ex) {
            Log.getInstance().error(JDOGenieFolioDAO.class, ex.getMessage());
            throw new DAOException(ex.getMessage(), ex);
        }
    }

    /**
     * @param ciudadanoEnh
     * @param anota
     * @param pm
     * @return
     */
    protected boolean isPropietario(CiudadanoEnhanced ciudadano,
            AnotacionEnhanced anota, PersistenceManager pm)
            throws DAOException {
        boolean rta = false;

        if (ciudadano == null) {
            return false;
        } else {
            try {
                VersantQuery query = (VersantQuery) pm.newQuery(AnotacionCiudadanoEnhanced.class);
                query.declareParameters("AnotacionEnhanced anota");

                StringBuffer filtro = new StringBuffer(
                        "(this.anotacion==anota) && (this.marcaPropietario==true) ");

                if (ciudadano.getApellido1() != null) {
                    filtro.append("&& (this.ciudadano.apellido1==\""
                            + ciudadano.getApellido1() + "\") ");
                }

                if (ciudadano.getApellido2() != null) {
                    filtro.append("&& (this.ciudadano.apellido2==\""
                            + ciudadano.getApellido2() + "\") ");
                }

                if (ciudadano.getDocumento() != null) {
                    filtro.append("&& (this.ciudadano.documento==\""
                            + ciudadano.getDocumento() + "\") ");
                }

                if (ciudadano.getTipoDoc() != null) {
                    filtro.append("&& (this.tipoDoc.apellido1==\""
                            + ciudadano.getApellido1() + "\") ");
                }

                query.setFilter(filtro.toString());

                Collection col = (Collection) query.execute(anota);
                Iterator iter = col.iterator();

                if (iter.hasNext()) {
                    rta = true;
                } else {
                    rta = false;
                }
            } catch (JDOObjectNotFoundException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
                rta = false;
            } catch (JDOException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
                throw new DAOException(e.getMessage(), e);
            }

            return rta;
        }
    }

    /**
     * Servicio utilizado para atender una consulta
     *
     * @param busqueda
     * @param persistente TODO
     * @return Objeto Busqueda con sus objetos respuesta
     * @throws ForsetiException
     */
    protected void atenderConsultaFolio(BusquedaEnhanced busqueda,
            PersistenceManager pm, boolean persistente) throws DAOException {
        ForsetiProperties fp = ForsetiProperties.getInstancia();
        int numMaxConsulta = Integer.parseInt(fp.getProperty(
                ForsetiProperties.MAXIMO_REGISTROS_CONSULTA));

        int mayorExt = Integer.parseInt(fp.getProperty(
                ForsetiProperties.MAYOR_EXTENSION));

        try {
            StringBuffer filtro = new StringBuffer("(1==1) ");

            StringBuffer variables = new StringBuffer();
            boolean flagConsulta = false;

            String consMatricula;

            if (busqueda.getIdCirculoBusqueda() != null) {
                filtro.append("&& (idMatricula.startsWith(\"" + busqueda.getIdCirculoBusqueda() + "\")) ");
            }

            if (busqueda.getMatricula() != null) {
                filtro.append("&& (idMatricula==\""
                        + busqueda.getMatricula().toUpperCase() + "\") ");
                flagConsulta = true;
            }

            if (busqueda.getNumeroCatastral() != null) {
                filtro.append("&& (codCatastral==\""
                        + busqueda.getNumeroCatastral().toUpperCase() + "\") ");
                flagConsulta = true;
            }

            if (busqueda.getIdTipoPredio() != null) {
                filtro.append("&& (tipoPredio.idPredio==\""
                        + busqueda.getIdTipoPredio() + "\") ");
            }

            //Se pone filtro para que no busque en los folios obsoletos
            filtro.append("&& (estado.idEstado!='" + CEstadoFolio.OBSOLETO
                    + "') && (definitivo==true) ");

            /*
            * @author      :   Julio Alcázar Rivas
            * @change      :   Se filtran los folios que esten en estado Trasladado, para no obtenerlos.
            * Caso Mantis  :   07123
             */
            filtro.append("&& (estado.idEstado!='" + CEstadoFolio.TRASLADADO + "') ");

            /*
            VersantQuery query = (VersantQuery) pm.newQuery(FolioEnhanced.class);
            query.declareVariables(variables.toString());
            query.setFilter(filtro.toString());
            query.setResult("count(this)");

            long numeroResultados = ((Long) query.execute()).longValue();
            query.closeAll();
             */
            VersantQuery query = (VersantQuery) pm.newQuery(FolioEnhanced.class);
            query.declareVariables(variables.toString());
            query.setFilter(filtro.toString());
            query.setMaxRows(numMaxConsulta);

            List rta = (List) query.execute();
            FolioEnhanced folio;
            ResultadoFolioEnhanced rf;

            List listToDelete = busqueda.getResultadosFolios();

            if (persistente) {
                pm.deletePersistentAll(busqueda.getResultadosFolios());

                //Ejecutamos el borrado de los resultados
                VersantPersistenceManager pm2 = (VersantPersistenceManager) pm;
                pm2.flush();
            }

            FolioEnhanced aux;
            int numeroResultados = 0;
            /**
             * @author : Julio Alcazar
             * @change : Revision: Validacion bloqueo por traslado. Caso Mantis
             * : 0007676: Acta - Requerimiento No 247 - Traslado de Folios V2
             */
            TrasladoSIR trasladoSIR = new TrasladoSIR();

            for (Iterator itr = rta.iterator(); itr.hasNext();) {
                rf = new ResultadoFolioEnhanced();
                aux = (FolioEnhanced) itr.next();

                if (this.getCountAnotacionesFolio(aux,
                        pm) > mayorExt) {
                    rf.setMayorExtension(true);
                } else {
                    rf.setMayorExtension(false);
                }

                FolioEnhancedPk fid = new FolioEnhancedPk();
                fid.idMatricula = aux.getIdMatricula();

                DireccionEnhanced dirAux = this.getUltimaDireccion(fid, pm);

                if (dirAux != null) {
                    rf.setLastDireccion(dirAux.getEspecificacion());
                }

                rf.setFolio(aux);
                rf.setBusqueda(busqueda);
                /**
                 * @author : Julio Alcazar
                 * @change : Revision: Validacion bloqueo por traslado. Caso
                 * Mantis : 0007676: Acta - Requerimiento No 247 - Traslado de
                 * Folios V2
                 */
                if (!trasladoSIR.isTrasladoSinConf(rf.getIdMatricula())) {
                    busqueda.addResultadosFolio(rf);
                }
                numeroResultados++;
            }

            busqueda.setNumeroResultados(numeroResultados);

            //busqueda.setNumeroIntento(busqueda.getNumeroIntento() + 1);
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } /**
         * @author : Julio Alcazar
         * @change : Revision: Validacion bloqueo por traslado. Caso Mantis :
         * 0007676: Acta - Requerimiento No 247 - Traslado de Folios V2
         */
        catch (GeneralSIRException ex) {
            Log.getInstance().error(JDOGenieFolioDAO.class, ex.getMessage());
            throw new DAOException(ex.getMessage(), ex);
        }
    }

    /**
     *
     * @param folio
     * @param pm
     * @throws DAOException
     */
    protected void makeTransientFolioSinAnotaciones(FolioEnhanced folio,
            PersistenceManager pm) throws DAOException {
        if (folio != null) {
            try {
                List cache;

                for (Iterator itr2 = folio.getDirecciones().iterator();
                        itr2.hasNext();) {
                    this.makeTransientDireccion((DireccionEnhanced) itr2.next(),
                            pm);
                }

                for (Iterator itr3 = folio.getSalvedades().iterator();
                        itr3.hasNext();) {
                    this.makeTransientSalvedadFolio((SalvedadFolioEnhanced) itr3.next(),
                            pm);
                }

                for (Iterator itr4 = folio.getTurnosFolios().iterator();
                        itr4.hasNext();) {
                    this.makeTransientTurnoFolio((TurnoFolioEnhanced) itr4.next(),
                            pm);
                }

                for (Iterator itr5 = folio.getHistorialEstados().iterator();
                        itr5.hasNext();) {
                    this.makeTransientEstadoHistoria((EstadoHistoriaEnhanced) itr5.next(),
                            pm);
                }

                this.makeTransientZonaRegistral(folio.getZonaRegistral(), pm);
                this.makeTransientDocumento(folio.getDocumento(), pm);

                pm.makeTransient(folio.getComplementacion());
                pm.makeTransient(folio.getEstado());
                pm.makeTransient(folio.getTipoPredio());
                pm.makeTransient(folio.getUsuarioCreacion());
                pm.makeTransient(folio);
            } catch (JDOException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                throw new DAOException(e.getMessage(), e);
            }
        }
    }

    /**
     *
     * @param folio
     * @param pm
     * @throws DAOException
     */
    protected void makeTransientFolio(FolioEnhanced folio, PersistenceManager pm)
            throws DAOException {
        if (folio != null) {
            try {
                List cache;
                List anotaciones = new ArrayList();
                AnotacionEnhanced anota;

                //Se obtienen solamente las anotaciones reales, es decir, las que
                //tengan estado diferente a obsoletas y las guardamos en una lista
                //temporal
                // Este método se elimina para evitar traer todas las
                // anotaciones involuntariamente. Si se necesitan las
                // anotaciones es necesario consultarlas explicitamente
                /*
                for (Iterator itr = this.getAnotacionesRealesFolio(folio, pm)
                                        .iterator(); itr.hasNext();) {
                    cache = new ArrayList();
                    anota = (AnotacionEnhanced) itr.next();
                    this.makeTransientAnotacion(anota, pm, cache);
                    anotaciones.add(anota);
                }
                 */
                for (Iterator itr2 = folio.getDirecciones().iterator();
                        itr2.hasNext();) {
                    this.makeTransientDireccion((DireccionEnhanced) itr2.next(),
                            pm);
                }

                for (Iterator itr3 = folio.getSalvedades().iterator();
                        itr3.hasNext();) {
                    this.makeTransientSalvedadFolio((SalvedadFolioEnhanced) itr3.next(),
                            pm);
                }

                for (Iterator itr4 = folio.getTurnosFolios().iterator();
                        itr4.hasNext();) {
                    this.makeTransientTurnoFolio((TurnoFolioEnhanced) itr4.next(),
                            pm);
                }

                for (Iterator itr5 = folio.getHistorialEstados().iterator();
                        itr5.hasNext();) {
                    this.makeTransientEstadoHistoria((EstadoHistoriaEnhanced) itr5.next(),
                            pm);
                }

                this.makeTransientZonaRegistral(folio.getZonaRegistral(), pm);
                this.makeTransientDocumento(folio.getDocumento(), pm);

                pm.makeTransient(folio.getComplementacion());
                pm.makeTransient(folio.getEstado());
                pm.makeTransient(folio.getTipoPredio());
                pm.makeTransient(folio.getUsuarioCreacion());
                pm.makeTransient(folio);

                //Una vez trasiente el folio seteamos la lista de anotaciones
                folio.setAnotaciones(anotaciones);
            } catch (JDOException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                throw new DAOException(e.getMessage(), e);
            }
        }
    }

    /**
     * Hace trasiente la información definitiva y temporal del folio
     *
     * @param folio
     * @param pm
     * @throws DAOException
     */
    protected void makeTransientFolioTMP(FolioEnhanced folio,
            PersistenceManager pm) throws DAOException {
        if (folio != null) {
            try {
                /*
                List cache;
                List anotaciones = new ArrayList();
                AnotacionEnhanced anota;

                //Se obtienen solamente las anotaciones reales, es decir, las que
                //tengan estado diferente a obsoletas y las guardamos en una lista
                //temporal
                
                for (Iterator itr = this.getAnotacionesRealesFolio(folio, pm)
                                        .iterator(); itr.hasNext();) {
                    cache = new ArrayList();
                    anota = (AnotacionEnhanced) itr.next();
                    this.makeTransientAnotacion(anota, pm, cache);
                    anotaciones.add(anota);
                }

                for (Iterator itr = folio.getAnotacionesTMPs().iterator();
                        itr.hasNext();) {
                    cache = new ArrayList();
                    this.makeTransientAnotacionTMP((AnotacionTMP) itr.next(),
                        pm, cache);
                }
                 */

                for (Iterator itr2 = folio.getDirecciones().iterator();
                        itr2.hasNext();) {
                    this.makeTransientDireccion((DireccionEnhanced) itr2.next(),
                            pm);
                }

                for (Iterator itr2 = folio.getDireccionesTMPs().iterator();
                        itr2.hasNext();) {
                    this.makeTransientDireccionTMP((DireccionTMP) itr2.next(),
                            pm);
                }

                for (Iterator itr3 = folio.getSalvedades().iterator();
                        itr3.hasNext();) {
                    this.makeTransientSalvedadFolio((SalvedadFolioEnhanced) itr3.next(),
                            pm);
                }

                for (Iterator itr3 = folio.getSalvedadesTMPs().iterator();
                        itr3.hasNext();) {
                    this.makeTransientSalvedadFolioTMP((SalvedadFolioTMP) itr3.next(),
                            pm);
                }

                for (Iterator itr4 = folio.getTurnosFolios().iterator();
                        itr4.hasNext();) {
                    this.makeTransientTurnoFolio((TurnoFolioEnhanced) itr4.next(),
                            pm);
                }

                for (Iterator itr5 = folio.getHistorialEstados().iterator();
                        itr5.hasNext();) {
                    this.makeTransientEstadoHistoria((EstadoHistoriaEnhanced) itr5.next(),
                            pm);
                }

                this.makeTransientZonaRegistral(folio.getZonaRegistral(), pm);
                this.makeTransientDocumento(folio.getDocumento(), pm);
                this.makeTransientDocumentoTMP(folio.getDocumentoTMP(), pm);

                FolioDatosTMP folioTMP;

                try {
                    FolioDatosTMP fdt = folio.getDatosTMP();
                    pm.makeTransient(fdt.getTipoPredio());
                    pm.makeTransient(fdt.getEstado());
                    this.makeTransientZonaRegistral(fdt.getZonaRegistral(), pm);
                    pm.makeTransient(fdt);
                } catch (JDOObjectNotFoundException e) {
                    //folio.setDatosTMP(null);
                }

                pm.makeTransient(folio.getComplementacionTMP());
                pm.makeTransient(folio.getComplementacion());
                pm.makeTransient(folio.getEstado());
                pm.makeTransient(folio.getTipoPredio());
                pm.makeTransient(folio);

                //Una vez trasiente el folio seteamos la lista de anotaciones
                folio.setAnotaciones(new ArrayList());
            } catch (JDOException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                throw new DAOException(e.getMessage(), e);
            }
        }
    }

    /**
     *
     * @param direccion
     * @param pm
     * @throws DAOException
     */
    protected void makeTransientDireccion(DireccionEnhanced direccion,
            PersistenceManager pm) throws DAOException {
        if (direccion != null) {
            try {
                pm.makeTransient(direccion.getEje());
                pm.makeTransient(direccion.getEje1());
                pm.makeTransient(direccion.getUsuarioCreacion());
                pm.makeTransient(direccion.getUsuarioCreacionTMP());
                pm.makeTransient(direccion);
            } catch (JDOException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                throw new DAOException(e.getMessage(), e);
            }
        }
    }

    /**
     *
     * @param direccion
     * @param pm
     * @throws DAOException
     */
    protected void makeTransientDireccionTMP(DireccionTMP direccion,
            PersistenceManager pm) throws DAOException {
        if (direccion != null) {
            try {
                pm.makeTransient(direccion.getEje());
                pm.makeTransient(direccion.getEje1());
                pm.makeTransient(direccion.getUsuario());
                pm.makeTransient(direccion);
            } catch (JDOException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                throw new DAOException(e.getMessage(), e);
            }
        }
    }

    /**
     *
     * @param salvedad
     * @param pm
     * @throws DAOException
     */
    protected void makeTransientSalvedadFolio(SalvedadFolioEnhanced salvedad,
            PersistenceManager pm) throws DAOException {
        if (salvedad != null) {
            try {
                pm.makeTransient(salvedad.getUsuarioCreacion());
                pm.makeTransient(salvedad.getUsuarioCreacionTMP());

                TurnoSalvedadFolioEnhanced aux;

                for (Iterator it = salvedad.getTurnoSalvedadFolios().iterator();
                        it.hasNext();) {
                    aux = (TurnoSalvedadFolioEnhanced) it.next();
                    pm.makeTransient(aux.getTurno());
                    pm.makeTransient(aux);
                }

                pm.makeTransient(salvedad);
            } catch (JDOException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                throw new DAOException(e.getMessage(), e);
            }
        }
    }

    /**
     * Hace trasiente una salvedad de folio
     *
     * @param salvedad
     * @param pm
     * @throws DAOException
     */
    protected void makeTransientSalvedadFolioTMP(SalvedadFolioTMP salvedad,
            PersistenceManager pm) throws DAOException {
        if (salvedad != null) {
            try {
                pm.makeTransient(salvedad.getUsuario());
                pm.makeTransient(salvedad);
            } catch (JDOException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                throw new DAOException(e.getMessage(), e);
            }
        }
    }

    /**
     *
     * @param turnoFolio
     * @param pm
     * @throws DAOException
     */
    protected void makeTransientTurnoFolio(TurnoFolioEnhanced turnoFolio,
            PersistenceManager pm) throws DAOException {
        if (turnoFolio != null) {
            try {
                this.makeTransientTurno(turnoFolio.getTurno(), pm);
                pm.makeTransient(turnoFolio);
            } catch (JDOException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                throw new DAOException(e.getMessage(), e);
            }
        }
    }

    /**
     *
     * @param estadoHistoria
     * @param pm
     * @throws DAOException
     */
    protected void makeTransientEstadoHistoria(
            EstadoHistoriaEnhanced estadoHistoria, PersistenceManager pm)
            throws DAOException {
        if (estadoHistoria != null) {
            try {
                pm.makeTransient(estadoHistoria.getEstadoDestino());
                pm.makeTransient(estadoHistoria.getEstadoOrigen());
                pm.makeTransient(estadoHistoria.getUsuario());
                pm.makeTransient(estadoHistoria);
            } catch (JDOException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                throw new DAOException(e.getMessage(), e);
            }
        }
    }

    /**
     *
     * @param turno
     * @param pm
     * @throws DAOException
     */
    protected void makeTransientTurno(TurnoEnhanced turno, PersistenceManager pm)
            throws DAOException {
        if (turno != null) {
            try {
                pm.makeTransient(turno);
            } catch (JDOException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                throw new DAOException(e.getMessage(), e);
            }
        }
    }

    /**
     *
     * @param zona
     * @param pm
     * @throws DAOException
     */
    protected void makeTransientZonaRegistral(ZonaRegistralEnhanced zona,
            PersistenceManager pm) throws DAOException {
        if (zona != null) {
            try {
                pm.makeTransient(zona.getCirculo());
                pm.makeTransient(zona.getVereda().getMunicipio()
                        .getDepartamento());
                pm.makeTransient(zona.getVereda().getMunicipio());
                pm.makeTransient(zona.getVereda());
                pm.makeTransient(zona);
            } catch (JDOException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                throw new DAOException(e.getMessage(), e);
            }
        }
    }

    /**
     *
     * @param doc
     * @param pm
     * @throws DAOException
     */
    protected void makeTransientDocumento(DocumentoEnhanced doc,
            PersistenceManager pm) throws DAOException {
        if (doc != null) {
            try {
                pm.makeTransient(doc.getTipoDocumento());
                this.makeTransientOficinaOrigen(doc.getOficinaOrigen(), pm);

                pm.makeTransient(doc);
            } catch (JDOException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                throw new DAOException(e.getMessage(), e);
            }
        }
    }

    /**
     *
     * @param doc
     * @param pm
     * @throws DAOException
     */
    protected void makeTransientDocumentoTMP(DocumentoTMP doc,
            PersistenceManager pm) throws DAOException {
        if (doc != null) {
            try {
                pm.makeTransient(doc.getTipoDocumento());
                this.makeTransientOficinaOrigen(doc.getOficinaOrigen(), pm);
                pm.makeTransient(doc);
            } catch (JDOException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                throw new DAOException(e.getMessage(), e);
            }
        }
    }

    /**
     * Hace transientes las oficinas origen
     *
     * @param oficina
     * @param pm
     * @throws DAOException
     */
    protected void makeTransientOficinaOrigen(OficinaOrigenEnhanced oficina,
            PersistenceManager pm) throws DAOException {
        if (oficina != null) {
            try {
                pm.makeTransient(oficina.getTipoOficina());

                if (oficina.getVereda() != null) {
                    pm.makeTransient(oficina.getVereda().getMunicipio()
                            .getDepartamento());
                    pm.makeTransient(oficina.getVereda().getMunicipio());
                    pm.makeTransient(oficina.getVereda());
                }

                for (Iterator it = oficina.getCategorias().iterator(); it.hasNext();) {
                    OficinaCategoriaEnhanced ofCat = (OficinaCategoriaEnhanced) it.next();
                    pm.makeTransient(ofCat.getCategoria());
                    pm.makeTransient(ofCat);
                }

                if (oficina.getCategoriaNotaria() != null) {
                    pm.makeTransient(oficina.getCategoriaNotaria());
                }

                pm.makeTransient(oficina);
            } catch (JDOException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                throw new DAOException(e.getMessage(), e);
            }
        }
    }

    /**
     *
     * @param canc
     * @param pm
     * @throws DAOException
     */
    protected void makeTransientAnotacionCancelacion(CancelacionEnhanced canc,
            PersistenceManager pm, List cache) throws DAOException {
        if (canc != null) {
            try {
                this.makeTransientAnotacion(canc.getCancelada(), pm, cache);
                pm.makeTransient(canc);
            } catch (JDOException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                throw new DAOException(e.getMessage(), e);
            }
        }
    }

    /**
     * Hace trasiente una cancelación temporal
     *
     * @param canc
     * @param pm
     * @throws DAOException
     */
    protected void makeTransientAnotacionCancelacionTMP(CancelacionTMP canc,
            PersistenceManager pm) throws DAOException {
        if (canc != null) {
            try {
                List cache = new ArrayList();
                this.makeTransientAnotacion(canc.getCanceladaDef(), pm, cache);
                cache = new ArrayList();
                this.makeTransientAnotacionTMP(canc.getCanceladaTmp(), pm, cache);
                pm.makeTransient(canc);
            } catch (JDOException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                throw new DAOException(e.getMessage(), e);
            }
        }
    }

    /**
     *
     * @param anotaCiud
     * @param pm
     * @throws DAOException
     */
    protected void makeTransientAnotacionCiudadano(
            AnotacionCiudadanoEnhanced anotaCiud, PersistenceManager pm)
            throws DAOException {
        JDOGenieCiudadanoDAO ciudDAO = new JDOGenieCiudadanoDAO();
        if (anotaCiud != null) {
            try {
                this.makeTransientCiudadano(anotaCiud.getCiudadano(), pm);
                pm.makeTransient(anotaCiud);

                //Se verifica si se debe reemplazar el ciudadano por el temporal
                ciudDAO.reemplazarCiudadanoPorTemporal(anotaCiud, pm);
            } catch (JDOException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                throw new DAOException(e.getMessage(), e);
            }
        }
    }

    /**
     * Hace trasiente una anotacion-ciudadano temporal
     *
     * @param anotaCiud
     * @param pm
     * @throws DAOException
     */
    protected void makeTransientAnotacionCiudadanoTMP(
            AnotacionCiudadanoTMP anotaCiud, PersistenceManager pm)
            throws DAOException {
        JDOGenieCiudadanoDAO ciudDAO = new JDOGenieCiudadanoDAO();
        if (anotaCiud != null) {
            try {
                this.makeTransientCiudadano(anotaCiud.getCiudadano(), pm);
                pm.makeTransient(anotaCiud);

                //Se verifica si se debe reemplazar el ciudadano por el temporal
                ciudDAO.reemplazarCiudadanoPorTemporal(anotaCiud, pm);
            } catch (JDOException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                throw new DAOException(e.getMessage(), e);
            }
        }
    }

    /**
     *
     * @param ciud
     * @param pm
     * @throws DAOException
     */
    protected void makeTransientCiudadano(CiudadanoEnhanced ciud,
            PersistenceManager pm) throws DAOException {
        if (ciud != null) {
            try {
                pm.makeTransient(ciud);
            } catch (JDOException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                throw new DAOException(e.getMessage(), e);
            }
        }
    }

    /**
     *
     * @param folDer
     * @param pm
     * @throws DAOException
     */
    protected void makeTransientAnotacionHijo(FolioDerivadoEnhanced folDer,
            PersistenceManager pm, List cache) throws DAOException {
        if (folDer != null) {
            try {
                //this.makeTransientAnotacion(folDer.getHijo(), pm, cache);
                pm.makeTransient(folDer.getHijo());
                pm.makeTransient(folDer);
            } catch (JDOException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                throw new DAOException(e.getMessage(), e);
            }
        }
    }

    /**
     * Hace trasiente un Folio Derivado Hijo temporal
     *
     * @param folDer
     * @param pm
     * @throws DAOException
     */
    protected void makeTransientAnotacionHijoTMP(FolioDerivadoTMP folDer,
            PersistenceManager pm, List cache) throws DAOException {
        if (folDer != null) {
            try {
                // this.makeTransientAnotacionTMP(folDer.getHijoTmp(), pm, cache);
                pm.makeTransient(folDer);
            } catch (JDOException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                throw new DAOException(e.getMessage(), e);
            }
        }
    }

    /**
     *
     * @param folDer
     * @param pm
     * @throws DAOException
     */
    protected void makeTransientAnotacionPadre(FolioDerivadoEnhanced folDer,
            PersistenceManager pm, List cache) throws DAOException {
        if (folDer != null) {
            try {
                //this.makeTransientAnotacion(folDer.getPadre(), pm, cache);
                pm.makeTransient(folDer.getPadre());
                pm.makeTransient(folDer);
            } catch (JDOException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                throw new DAOException(e.getMessage(), e);
            }
        }
    }

    /**
     *
     * @param folDer
     * @param pm
     * @param cache
     * @throws DAOException
     */
    protected void makeTransientAnotacionPadreTMP(FolioDerivadoTMP folDer,
            PersistenceManager pm, List cache) throws DAOException {
        if (folDer != null) {
            try {
                //this.makeTransientAnotacionTMP(folDer.getPadreTmp(), pm, cache);
                pm.makeTransient(folDer);
            } catch (JDOException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                throw new DAOException(e.getMessage(), e);
            }
        }
    }

    /**
     *
     * @param salvedad
     * @param pm
     * @throws DAOException
     */
    protected void makeTransientSalvedadAnotacion(
            SalvedadAnotacionEnhanced salvedad, PersistenceManager pm)
            throws DAOException {
        if (salvedad != null) {
            try {
                pm.makeTransient(salvedad.getUsuarioCreacion());
                pm.makeTransient(salvedad.getUsuarioCreacionTMP());

                TurnoSalvedadAnotacionEnhanced aux;

                for (Iterator it = salvedad.getTurnoSalvedadAnotacions()
                        .iterator(); it.hasNext();) {
                    aux = (TurnoSalvedadAnotacionEnhanced) it.next();
                    pm.makeTransient(aux.getTurno());
                    pm.makeTransient(aux);
                }

                pm.makeTransient(salvedad);
            } catch (JDOException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                throw new DAOException(e.getMessage(), e);
            }
        }
    }

    /**
     * Hace trasiente una salvedad de anotación temporal
     *
     * @param salvedad
     * @param pm
     * @throws DAOException
     */
    protected void makeTransientSalvedadAnotacionTMP(
            SalvedadAnotacionTMP salvedad, PersistenceManager pm)
            throws DAOException {
        if (salvedad != null) {
            try {
                pm.makeTransient(salvedad.getUsuario());
                pm.makeTransient(salvedad);
            } catch (JDOException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                throw new DAOException(e.getMessage(), e);
            }
        }
    }

    /**
     *
     * @param anota
     * @param pm
     * @throws DAOException
     */
    protected void makeTransientAnotacion(AnotacionEnhanced anota,
            PersistenceManager pm, List cache) throws DAOException {
        if ((anota != null) && (!cache.contains(anota))) {
            try {
                cache.add(anota);

                for (Iterator itr = anota.getAnotacionesCancelacions().iterator();
                        itr.hasNext();) {
                    this.makeTransientAnotacionCancelacion((CancelacionEnhanced) itr.next(),
                            pm, cache);
                }

                for (Iterator itr2 = anota.getAnotacionesCiudadanos().iterator();
                        itr2.hasNext();) {
                    this.makeTransientAnotacionCiudadano((AnotacionCiudadanoEnhanced) itr2.next(),
                            pm);
                }

                for (Iterator itr3 = anota.getAnotacionesHijos().iterator();
                        itr3.hasNext();) {
                    this.makeTransientAnotacionHijo((FolioDerivadoEnhanced) itr3.next(),
                            pm, cache);
                }

                for (Iterator itr4 = anota.getAnotacionesPadre().iterator();
                        itr4.hasNext();) {
                    this.makeTransientAnotacionPadre((FolioDerivadoEnhanced) itr4.next(),
                            pm, cache);
                }

                for (Iterator itr5 = anota.getSalvedades().iterator();
                        itr5.hasNext();) {
                    this.makeTransientSalvedadAnotacion((SalvedadAnotacionEnhanced) itr5.next(),
                            pm);
                }

                TurnoAnotacionEnhanced aux;

                for (Iterator it = anota.getTurnoAnotacions().iterator();
                        it.hasNext();) {
                    aux = (TurnoAnotacionEnhanced) it.next();
                    pm.makeTransient(aux.getTurno());
                    pm.makeTransient(aux);
                }

                this.makeTransientDocumento(anota.getDocumento(), pm);

                pm.makeTransient(anota.getEstado());

                if (anota.getNaturalezaJuridica() != null) {
                    pm.makeTransient(anota.getNaturalezaJuridica()
                            .getGrupoNaturalezaJuridica());
                    pm.makeTransient(anota.getNaturalezaJuridica()
                            .getDominioNaturalezaJuridica());
                    pm.makeTransient(anota.getNaturalezaJuridica());
                }

                pm.makeTransient(anota.getTipoAnotacion());
                pm.makeTransient(anota.getUsuarioCreacion());
                pm.makeTransient(anota.getUsuarioCreacionTMP());
                pm.makeTransient(anota.getDatosAntiguoSistema());
                pm.makeTransient(anota);
            } catch (JDOException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                throw new DAOException(e.getMessage(), e);
            }
        }
    }

    /**
     * Método utilizado en consultas, sólo vuelve trasiente los objetos básicos
     * de anotación.
     *
     * @param anota
     * @param pm
     * @throws DAOException
     */
    protected void makeTransientAnotacionBasico(AnotacionEnhanced anota,
            PersistenceManager pm) throws DAOException {
        try {
            pm.makeTransient(anota.getEstado());

            if (anota.getNaturalezaJuridica() != null) {
                pm.makeTransient(anota.getNaturalezaJuridica()
                        .getGrupoNaturalezaJuridica());
                pm.makeTransient(anota.getNaturalezaJuridica()
                        .getDominioNaturalezaJuridica());
                pm.makeTransient(anota.getNaturalezaJuridica());
            }

            pm.makeTransient(anota.getTipoAnotacion());
            pm.makeTransient(anota.getUsuarioCreacion());
            pm.makeTransient(anota.getUsuarioCreacionTMP());
            pm.makeTransient(anota.getDatosAntiguoSistema());
            pm.makeTransient(anota);
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }
    }

    /**
     * Hace trasiente una anotación temporal
     *
     * @param anota
     * @param pm
     * @throws DAOException
     */
    protected void makeTransientAnotacionTMP(AnotacionTMP anota,
            PersistenceManager pm, List cache) throws DAOException {
        if ((anota != null) && (!cache.contains(anota))) {
            try {
                cache.add(anota);

                for (Iterator itr = anota.getAnotacionesCancelacionTMPs()
                        .iterator(); itr.hasNext();) {
                    this.makeTransientAnotacionCancelacionTMP((CancelacionTMP) itr.next(),
                            pm);
                }

                for (Iterator itr2 = anota.getAnotacionesCiudadanoTMPs()
                        .iterator(); itr2.hasNext();) {
                    this.makeTransientAnotacionCiudadanoTMP((AnotacionCiudadanoTMP) itr2.next(),
                            pm);
                }

                for (Iterator itr3 = anota.getAnotacionesHijosTMPs().iterator();
                        itr3.hasNext();) {
                    this.makeTransientAnotacionHijoTMP((FolioDerivadoTMP) itr3.next(),
                            pm, cache);
                }

                for (Iterator itr4 = anota.getAnotacionesPadreTMPs().iterator();
                        itr4.hasNext();) {
                    this.makeTransientAnotacionPadreTMP((FolioDerivadoTMP) itr4.next(),
                            pm, cache);
                }

                for (Iterator itr5 = anota.getSalvedadesTMPs().iterator();
                        itr5.hasNext();) {
                    this.makeTransientSalvedadAnotacionTMP((SalvedadAnotacionTMP) itr5.next(),
                            pm);
                }

                this.makeTransientDocumento(anota.getDocumento(), pm);
                this.makeTransientDocumentoTMP(anota.getDocumentoTMP(), pm);

                pm.makeTransient(anota.getEstado());

                if (anota.getNaturalezaJuridica() != null) {
                    pm.makeTransient(anota.getNaturalezaJuridica()
                            .getGrupoNaturalezaJuridica());
                    pm.makeTransient(anota.getNaturalezaJuridica()
                            .getDominioNaturalezaJuridica());
                    pm.makeTransient(anota.getNaturalezaJuridica());
                }

                pm.makeTransient(anota.getTipoAnotacion());
                pm.makeTransient(anota.getUsuario());
                pm.makeTransient(anota.getDatosAntiguoSistema());
                pm.makeTransient(anota);
            } catch (JDOException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                throw new DAOException(e.getMessage(), e);
            }
        }
    }

    /**
     *
     * @param oid
     * @param pm
     * @return
     * @throws DAOException
     */
    protected BusquedaEnhanced getBusqueda(BusquedaEnhancedPk oid,
            PersistenceManager pm) throws DAOException {
        BusquedaEnhanced rta = null;

        if ((oid.idBusqueda != null) && (oid.idSolicitud != null)) {
            try {
                rta = (BusquedaEnhanced) pm.getObjectById(oid, true);
            } catch (JDOObjectNotFoundException e) {
                rta = null;
            } catch (JDOException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                throw new DAOException(e.getMessage(), e);
            }
        }

        return rta;
    }

    /**
     * Indica si el ciudadano es el último propietario del predio. Recibe una
     * AnotacionCiudadano
     *
     * @param oid
     * @param pm
     * @return
     * @throws DAOException
     */
    protected boolean isUltimoPropietario(AnotacionCiudadanoEnhanced anotaCiud,
            PersistenceManager pm) throws DAOException {
        boolean rta = false;
        String idMut = CDominioNaturalezaJuridica.ID_MUTACION;
        String numAnotaMax = null;
        try {

            Query query3 = pm.newQuery(AnotacionEnhanced.class);
            query3.declareParameters("String idMut, String idMat");
            query3.setFilter("this.idMatricula==idMat &&\n"
                    + "this.naturalezaJuridica.dominioNaturalezaJuridica.idDominioNatJur==idMut");
            Collection col3 = (Collection) query3.execute(idMut, anotaCiud.getIdMatricula());
            Iterator iter3 = col3.iterator();
            if (!iter3.hasNext()) {
                return false;
            }

            VersantQuery query = (VersantQuery) pm.newQuery(AnotacionEnhanced.class);
            query.declareParameters("String idMut, String idMat");
            query.setFilter("this.idMatricula==idMat &&\n"
                    + "this.naturalezaJuridica.dominioNaturalezaJuridica.idDominioNatJur==idMut");
            query.setResult("max(this.ordenLPAD)");
            numAnotaMax = (String) query.execute(idMut, anotaCiud.getIdMatricula());

            String rol = "A";

            Query query2 = pm.newQuery(AnotacionCiudadanoEnhanced.class);
            query2.declareParameters("CiudadanoEnhanced ciud, String rol, String ord, String idMat");
            query2.setFilter("this.ciudadano == ciud &&\n"
                    + "this.rolPersona == rol &&\n"
                    + "this.anotacion.ordenLPAD==ord &&\n"
                    + "this.idMatricula==idMat");
            Collection col = (Collection) query2.executeWithArray(new Object[]{anotaCiud.getCiudadano(), rol, numAnotaMax, anotaCiud.getIdMatricula()});
            Iterator iter = col.iterator();
            if (iter.hasNext()) {
                rta = true;
            }

        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }

        return rta;
    }

    /**
     *
     * @param oid
     * @param pm
     * @return
     * @throws DAOException
     */
    protected MatriculaNoGrabadaEnhanced getMatriculaNoGrabada(MatriculaNoGrabadaEnhancedPk oid,
            PersistenceManager pm) throws DAOException {
        MatriculaNoGrabadaEnhanced rta = null;

        if (oid.idCirculo != null) {
            try {
                rta = (MatriculaNoGrabadaEnhanced) pm.getObjectById(oid, true);
            } catch (JDOObjectNotFoundException e) {
                rta = null;
            } catch (JDOException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                throw new DAOException(e.getMessage(), e);
            }
        }

        return rta;
    }

    /**
     * Retorna los grupos de naturalezas jurídicas, cada uno con su lista de
     * naturalezas jurídicas
     *
     * @return Lista de GrupoNaturalezaJuridica
     * @see gov.sir.core.negocio.modelo.GrupoNaturalezaJuridica
     * @throws DAOException
     */
    public List getGruposNaturalezaJuridica() throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();

        List rta = null;
        GrupoNaturalezaJuridicaEnhanced grupo;
        NaturalezaJuridicaEnhanced nj;
        /*
            *  @author Carlos Torres
            *  @chage   se asigna valor a la propiedad version
            *  @mantis 12705: Acta - Requerimiento No 056_453_Modificiación_de_Naturaleza_Jurídica
         */
        List gruposN = new ArrayList();

        try {
            //pm.currentTransaction().setOptimistic(false);
            pm.currentTransaction().begin();
            rta = this.getGruposNaturalezaJuridica(pm);

            for (Iterator itr = rta.iterator(); itr.hasNext();) {
                grupo = (GrupoNaturalezaJuridicaEnhanced) itr.next();
                /*
            *  @author Carlos Torres
            *  @chage   se asigna valor a la propiedad version
            *  @mantis 12705: Acta - Requerimiento No 056_453_Modificiación_de_Naturaleza_Jurídica
                 */
                GrupoNaturalezaJuridicaEnhanced grupoTmp = copy(grupo);
                gruposN.add(grupoTmp);
                Map idsNaturaleza = new HashMap();
                for (Iterator itr2 = grupo.getNaturalezaJuridicas().iterator();
                        itr2.hasNext();) {
                    nj = (NaturalezaJuridicaEnhanced) itr2.next();
                    pm.makeTransient(nj.getDominioNaturalezaJuridica());
                    pm.makeTransient(nj);
                    if (idsNaturaleza.containsKey(nj.getIdNaturalezaJuridica())) {
                        NaturalezaJuridicaEnhanced njt = (NaturalezaJuridicaEnhanced) idsNaturaleza.get(nj.getIdNaturalezaJuridica());
                        if (nj.getVersion() > njt.getVersion()) {
                            idsNaturaleza.put(nj.getIdNaturalezaJuridica(), nj);
                            grupoTmp.removeNaturalezaJuridica(njt);
                            grupoTmp.addNaturalezaJuridica(nj);
                        }
                    } else {
                        idsNaturaleza.put(nj.getIdNaturalezaJuridica(), nj);
                        grupoTmp.addNaturalezaJuridica(nj);
                    }
                }
            }

            pm.makeTransientAll(rta);
            pm.currentTransaction().commit();
        } catch (DAOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            throw e;
        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (Exception e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        rta = TransferUtils.makeTransferAll(gruposN);

        return rta;
    }

    /*
        *  @author Carlos Torres
        *  @chage   nuevo metodo 
        *  @mantis 12705: Acta - Requerimiento No 056_453_Modificiación_de_Naturaleza_Jurídica
     */
    /**
     * Retorna los grupos de naturalezas jurídicas, cada uno con su lista de
     * naturalezas jurídicas
     *
     * @return Lista de GrupoNaturalezaJuridica sin filtrar por version
     * @see gov.sir.core.negocio.modelo.GrupoNaturalezaJuridica
     * @throws DAOException
     */
    public List getGruposNaturalezaJuridicaAll() throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();

        List rta = null;
        GrupoNaturalezaJuridicaEnhanced grupo;
        NaturalezaJuridicaEnhanced nj;

        List gruposN = new ArrayList();

        try {
            //pm.currentTransaction().setOptimistic(false);
            pm.currentTransaction().begin();
            rta = this.getGruposNaturalezaJuridica(pm);

            for (Iterator itr = rta.iterator(); itr.hasNext();) {
                grupo = (GrupoNaturalezaJuridicaEnhanced) itr.next();
                for (Iterator itr2 = grupo.getNaturalezaJuridicas().iterator();
                        itr2.hasNext();) {
                    nj = (NaturalezaJuridicaEnhanced) itr2.next();
                    pm.makeTransient(nj.getDominioNaturalezaJuridica());
                    pm.makeTransient(nj);
                }
            }

            pm.makeTransientAll(rta);
            pm.currentTransaction().commit();
        } catch (DAOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            throw e;
        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (Exception e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        rta = TransferUtils.makeTransferAll(rta);

        return rta;
    }

    /**
     *
     * @return @throws DAOException
     */
    public List getDominiosNaturalezaJuridica() throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        List rta = null;
        DominioNaturalezaJuridicaEnhanced dominio;
        NaturalezaJuridicaEnhanced nj;

        try {
            rta = this.getDominiosNaturalezaJuridica(pm);
            pm.makeTransientAll(rta);
        } catch (DAOException e) {
            throw e;
        } finally {
            pm.close();
        }

        rta = TransferUtils.makeTransferAll(rta);

        return rta;
    }

    /**
     * Retorna los grupos de naturalezas jurídicas de manera transaccional
     *
     * @param pm
     * @return Lista de GrupoNaturalezaJuridica
     * @see gov.sir.core.negocio.modelo.GrupoNaturalezaJuridica
     * @throws DAOException
     */
    protected List getGruposNaturalezaJuridica(PersistenceManager pm)
            throws DAOException {
        try {
            Query query = pm.newQuery(GrupoNaturalezaJuridicaEnhanced.class);

            query.setOrdering("nombre ascending");

            List rta = (List) query.execute();

            return rta;
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }
    }

    /**
     *
     * @param pm
     * @return
     * @throws DAOException
     */
    protected List getDominiosNaturalezaJuridica(PersistenceManager pm)
            throws DAOException {
        try {
            Query query = pm.newQuery(DominioNaturalezaJuridicaEnhanced.class);
            query.setOrdering("nombre ascending");

            List rta = (List) query.execute();

            return rta;
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }
    }

    /**
     * Obtiene un Turno dado su identificador, método utilizado para
     * transacciones
     *
     * @param tID identificador del Turno
     * @param pm PersistenceManager de la transaccion
     * @return Turno con sus atributos
     * @throws DAOException
     */
    protected TurnoEnhanced getTurnoByID(TurnoEnhancedPk tID,
            PersistenceManager pm) throws DAOException {
        TurnoEnhanced rta = null;

        if ((tID.idTurno != null) && (tID.idCirculo != null)
                && (String.valueOf(tID.idProceso) != null)) {
            try {
                rta = (TurnoEnhanced) pm.getObjectById(tID, true);
            } catch (JDOObjectNotFoundException e) {
                rta = null;
            } catch (JDOException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
                throw new DAOException(e.getMessage(), e);
            }
        }

        return rta;
    }

    /**
     * @see gov.sir.hermod.dao.TurnosDAO#getTurnoDependiente(TurnoPk)
     */
    protected TurnoEnhanced getTurnoDependiente(TurnoEnhancedPk id, PersistenceManager pm) throws DAOException {

        TurnoEnhanced turno = null;

        try {

            // Se debe obtener el turno que tenga como padre el id que se suministra como parámetro,
            // y cuyo estado no esté finalizado.
            Query query = pm.newQuery(TurnoDerivadoEnhanced.class);
            query.declareParameters("Long proceso, String anioTurno, String circulo, String turno");

            query.setFilter("this.idProcesoPadre == proceso && "
                    + "this.anioPadre == anioTurno && "
                    + "this.idCirculoPadre == circulo && "
                    + "this.idTurnoPadre == turno && "
                    + "turnoHijo.idFase != \"FINALIZADO\" && "
                    + "turnoHijo.idFase != \"" + CFase.COS_ENTREGAR_ASOCIADOS + "\"");

            Collection col = (Collection) query.executeWithArray(new Object[]{new Long(id.idProceso),
                id.anio, id.idCirculo, id.idTurno});

            TurnoDerivadoEnhanced turnoDerivado;
            for (Iterator itTurnos = col.iterator(); itTurnos.hasNext();) {
                turnoDerivado = (TurnoDerivadoEnhanced) itTurnos.next();
                turno = turnoDerivado.getTurnoHijo();
            }

            if (turno != null) {
                makeTransientTurno(turno, pm);
            }

            query.closeAll();
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (Throwable e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }

        if (turno == null) {
            return null;
        }

        return turno;
    }

    /**
     * @see gov.sir.hermod.dao.TurnosDAO#getTurnoDependiente(TurnoPk)
     */
    protected TurnoEnhanced getTurnoPadre(TurnoEnhancedPk id, PersistenceManager pm) throws DAOException {

        TurnoEnhanced turno = null;

        try {

            // Se debe obtener el turno que tenga como padre el id que se suministra como parámetro,
            // y cuyo estado no esté finalizado.
            Query query = pm.newQuery(TurnoDerivadoEnhanced.class);
            query.declareParameters("Long proceso, String anioTurno, String circulo, String turno");

            query.setFilter("this.idProcesoHijo == proceso && "
                    + "this.anioHijo == anioTurno && "
                    + "this.idCirculoHijo == circulo && "
                    + "this.idTurnoHijo == turno");

            Collection col = (Collection) query.executeWithArray(new Object[]{new Long(id.idProceso),
                id.anio, id.idCirculo, id.idTurno});

            TurnoDerivadoEnhanced turnoDerivado;
            for (Iterator itTurnos = col.iterator(); itTurnos.hasNext();) {
                turnoDerivado = (TurnoDerivadoEnhanced) itTurnos.next();
                turno = turnoDerivado.getTurnoPadre();
            }

            if (turno != null) {
                makeTransientTurno(turno, pm);
            }

            query.closeAll();
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (Throwable e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }

        if (turno == null) {
            return null;
        }

        return turno;
    }

    /**
     *
     * @param folio
     * @param datos
     * @param pm
     * @return
     * @throws DAOException
     */
    protected boolean addTurnoFolioToFolio(FolioEnhanced folio,
            TurnoFolioEnhanced datos, PersistenceManager pm)
            throws DAOException {
        boolean rta = false;

        try {
            if (datos == null) {
                throw new DAOException("El TurnoFolio de creación es nulo");
            } else {
                TurnoEnhanced t = datos.getTurno();

                if (t == null) {
                    throw new DAOException("El Turno de creación es nulo");
                }

                TurnoEnhanced aux;
                TurnoEnhancedPk tid = new TurnoEnhancedPk();
                tid.anio = t.getAnio();
                tid.idCirculo = t.getIdCirculo();
                tid.idProceso = t.getIdProceso();
                tid.idTurno = t.getIdTurno();
                aux = this.getTurnoByID(tid, pm);

                if (aux == null) {
                    throw new DAOException("El turno especificado no existe");
                }

                datos.setTurno(aux);
                folio.setRadicacion(aux.getIdWorkflow());
            }

            datos.setFolio(folio);
            rta = true;
        } catch (DAOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw e;
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }

        return rta;
    }

    /**
     * Finaliza el servicio Forseti
     */
    public void finalizar() throws DAOException {
        AdministradorPM.shutdown();
    }

    /**
     * Especifica si existe una matrícula en el sistema
     *
     * @param matricula
     * @return true: existe, false: No existe
     * @throws DAOException
     */
    public boolean existeMatricula(String matricula) throws DAOException {
        FolioEnhanced folio = null;
        boolean rta = false;
        PersistenceManager pm = AdministradorPM.getPM();

        try {
            folio = this.getFolioByMatricula(matricula, pm);

            if (folio != null) {
                if (folio.isDefinitivo()) {
                    rta = true;
                } else {
                    rta = false;
                }
            }
        } catch (DAOException e) {
            throw e;
        } finally {
            pm.close();
        }

        return rta;
    }

    /**
     * Servicio utilizado para establecer si el folio con el número de matrícula
     * especificado existe en el sistema, a difencia del método existeFolio,
     * éste tiene en cuenta los datos temporales
     *
     * @param matricula
     * @return true: existe, false: No existe
     * @throws DAOException
     */
    public boolean existeMatriculaIncluyendoTemporales(String matricula) throws DAOException {
        FolioEnhanced folio = null;
        boolean rta = false;
        PersistenceManager pm = AdministradorPM.getPM();

        try {
            folio = this.getFolioByMatricula(matricula, pm);

            if (folio != null) {
                rta = true;
            }
        } catch (DAOException e) {
            throw e;
        } finally {
            pm.close();
        }

        return rta;
    }

    /**
     * Especifica si existe una matrícula está marcada como inconsistente
     *
     * @param matricula
     * @return true: existe, false: No existe
     * @throws DAOException
     */
    public boolean inconsistenteMatricula(String matricula) throws DAOException {
        FolioEnhanced folio = null;
        boolean rta = false;
        PersistenceManager pm = AdministradorPM.getPM();

        try {
            folio = this.getFolioByMatricula(matricula, pm);

            if (folio != null) {
                if (folio.isInconsistente()) {
                    rta = true;
                } else {
                    rta = false;
                }
            }
        } catch (DAOException e) {
            throw e;
        } finally {
            pm.close();
        }

        return rta;
    }

    /**
     * Especifica el estado de un folio, si el folio no existe retorna null
     *
     * @param matricula
     * @return EstadoFolio
     * @throws DAOException
     */
    public EstadoFolio getEstadoFolioByMatricula(String matricula)
            throws DAOException {
        FolioEnhanced folio = null;
        EstadoFolioEnhanced rta = null;
        PersistenceManager pm = AdministradorPM.getPM();
        EstadoFolio aux = null;

        try {
            folio = this.getFolioByMatricula(matricula, pm);

            if (folio != null) {
                pm.makeTransient(folio.getEstado());
                rta = folio.getEstado();
            }
        } catch (DAOException e) {
            throw e;
        } finally {
            pm.close();
        }

        if (rta != null) {
            aux = (EstadoFolio) rta.toTransferObject();
        }

        return aux;
    }

    /**
     * Especifica el estado de un folio segun sus datos temporales, si el folio
     * no existe retorna null
     *
     * @param matricula
     * @return EstadoFolio
     * @throws DAOException
     */
    public EstadoFolio getEstadoFolioByMatriculaTMP(String matricula)
            throws DAOException {
        FolioEnhanced folio = null;
        EstadoFolioEnhanced rta = null;
        PersistenceManager pm = AdministradorPM.getPM();
        EstadoFolio aux = null;

        try {
            Query query = pm.newQuery(FolioDatosTMP.class);
            query.declareParameters("String matricula");
            query.setFilter("idMatricula == matricula");

            Collection col = (Collection) query.execute(matricula);
            Iterator iter = col.iterator();
            if (iter.hasNext()) {
                rta = ((FolioDatosTMP) iter.next()).getEstado();
                pm.makeTransient(rta);
            }
            query.closeAll();

        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        if (rta != null) {
            aux = (EstadoFolio) rta.toTransferObject();
        }

        return aux;
    }

    /**
     * Especifica el estado de un folio, si el folio no existe retorna null
     *
     * @param matricula
     * @return EstadoFolio
     * @throws DAOException
     */
    public EstadoFolio getEstadoFolioByMatricula(String matricula, Usuario usuario)
            throws DAOException {
        FolioEnhanced folio = null;
        EstadoFolioEnhanced rta = null;
        PersistenceManager pm = AdministradorPM.getPM();
        EstadoFolio aux = null;

        try {
            folio = this.getFolioByMatricula(matricula, pm);

            if (folio != null) {
                //Validar bloqueo del folio
                if (usuario != null) {
                    this.validarBloqueoFolio(folio, usuario, pm);
                }

                FolioDatosTMP datosTMP = null;
                try {
                    datosTMP = folio.getDatosTMP();
                } catch (JDOObjectNotFoundException e) {
                    datosTMP = null;
                }

                if (datosTMP != null) {
                    if (datosTMP.getEstado() != null) {
                        rta = datosTMP.getEstado();
                    } else {
                        rta = folio.getEstado();
                    }
                } else {
                    rta = folio.getEstado();
                }
                pm.makeTransient(rta);

            }
        } catch (DAOException e) {
            throw e;
        } finally {
            pm.close();
        }

        if (rta != null) {
            aux = (EstadoFolio) rta.toTransferObject();
        }

        return aux;
    }

    /**
     * Actualiza los datos temporales de un folio.
     *
     * @param matricula, datosTMP, eliminarDireccion
     * @return rta: true si se realizo la operacion correctamente false si hubo
     * algun error
     * @throws DAOException
     */
    public boolean actualizarFolioDatosTMP(String matricula, FolioDatosTMP datos, boolean eliminarDireccion)
            throws DAOException {
        FolioEnhanced folio = null;
        boolean rta = false;
        PersistenceManager pm = AdministradorPM.getPM();
        pm.currentTransaction().begin();

        try {
            FolioEnhancedPk folioPk = new FolioEnhancedPk();
            folioPk.idMatricula = matricula;
            folio = this.getFolioByID(folioPk, pm);

            if (folio != null) {
                FolioDatosTMP update = null;
                try {
                    FolioDatosTMPPk folioDatos = new FolioDatosTMPPk();
                    folioDatos.idMatricula = datos.getIdMatricula();
                    //update = this.getFolioDatosTMP(folioDatos);
                    //update = folio.getDatosTMP();
                    this.actualizarDatosTMP(folio, datos, eliminarDireccion, pm);
                } catch (JDOObjectNotFoundException e) {
                    update = null;
                }
            }
            rta = true;
            pm.currentTransaction().commit();
        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (DAOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            throw e;
        } catch (Throwable e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        return rta;
    }

    /**
     * Actualiza los datos temporales de un folio.
     *
     * @param matricula, datosTMP, eliminarDireccion
     * @return rta: true si se realizo la operacion correctamente false si hubo
     * algun error
     * @throws DAOException
     */
    protected boolean actualizarDatosTMP(FolioEnhanced folio, FolioDatosTMP datos,
            boolean eliminarDireccion, PersistenceManager pm) throws DAOException {
        boolean rta = false;
        FolioDatosTMP update = folio.getDatosTMP();
        try {
            if (update != null && datos != null) {
                if (datos.getCodCatastral() == null && datos.getCodCatastralAnterior() == null) {
                    update.setCodCatastral("");
                    update.setCodCatastralAnterior("");
                    update.setNumRadicaCodCatastral("");
                    update.setNumRadicaCodCatastralAnterior("");
                }
                if (datos.getLindero() == null) {
                    /*update.setLindero("");*/
                    if (folio.isDefinitivo()) {
                        update.setLindero(folio.getLindero());
                    }
                    update.setNumRadicaLindero("");
                }
            }
            if (eliminarDireccion) {
                for (Iterator iter = folio.getDireccionesTMPs().iterator(); iter.hasNext();) {
                    DireccionTMP direccion = (DireccionTMP) iter.next();
                    DireccionTMPPk direccionPk = new DireccionTMPPk();
                    direccionPk.idDireccionTmp = direccion.getIdDireccionTmp();
                    direccionPk.idMatricula = folio.getIdMatricula();
                    DireccionTMP dir = this.getDireccionTMP(direccionPk, pm);
                    pm.deletePersistent(dir);
                }
            }
            rta = true;
        } catch (DAOException e) {
            throw e;
        }
        return rta;
    }

    /**
     * Bloquea los folios especificados en una lista de matriculas a un usuario
     * determinado. Si en el bloqueo de algún folio se produce una excepción,
     * esta quedará registrada en la hastable de DAOException en donde la llave
     * es la matricula y el valor el mensaje de excepción. Si no se produce
     * ningún error no se lanza ninguna excepción y se crea una llave de bloqueo
     * al usuario y se le asocian los folios dados. Finalmente la LlaveBloquedo
     * es retornada
     *
     * @param matriculas
     * @param usuario
     * @return
     * @throws DAOException
     */
    public LlaveBloqueo bloquearFolios(List matriculas, Usuario usuario, TurnoPk turnoID)
            throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        EstadoFolio aux = null;
        LlaveBloqueoEnhanced llave = null;
        String matricula;
        Hashtable ht = new Hashtable();
        List matsToLock = new ArrayList();
        String idWorkflow = null;

        UsuarioEnhanced us = UsuarioEnhanced.enhance(usuario);
        UsuarioEnhancedPk usId = new UsuarioEnhancedPk();
        usId.idUsuario = us.getIdUsuario();

        LlaveBloqueoEnhancedPk rta = new LlaveBloqueoEnhancedPk();

        try {
            pm.currentTransaction().begin();
            us = this.getUsuarioByID(usId, pm);

            if (us == null) {
                throw new DAOException("El usuario especificado no existe");
            }

            if (turnoID != null) {
                TurnoEnhanced turno = this.getTurnoByID(new TurnoEnhancedPk(turnoID), pm);
                if (turno == null) {
                    throw new DAOException("El turno especificado NO existe");
                }
                idWorkflow = turno.getIdWorkflow();
            }

            for (Iterator itr = matriculas.iterator(); itr.hasNext();) {
                matricula = (String) itr.next();

                if (this.getFolioByMatricula(matricula, pm) == null) {
                    ht.put(matricula, "La matricula no existe");
                } else {
                    //Validamos si el folio está bloqueado
                    BloqueoFolioEnhanced bloqueo = this.getBloqueoFolio(matricula,
                            pm);

                    if (bloqueo != null) {
                        //La matricula esta bloqueada
                        //Validamos que el usuario sea dueño del bloqueo del folio
                        UsuarioEnhanced usuAux = this.getUsuarioByLlaveBloqueo(bloqueo.getLlaveBloqueo(),
                                pm);

                        if (usuAux == null) {
                            throw new DAOException(
                                    "Error en la obtención del usuario a partir de la llave de bloqueo");
                        }

                        //En caso que el usuario no sea el dueño del bloqueo actual se especifica
                        //que la matricula está bloqueada
                        if (usuAux.getIdUsuario() != us.getIdUsuario()) {
                            String msm = "";

                            if (bloqueo.getIdWorkflowBloqueo() != null) {
                                msm = " en el turno "
                                        + bloqueo.getIdWorkflowBloqueo();
                            }

                            ht.put(matricula,
                                    "La matricula se encuentra bloqueada por el usuario "
                                    + usuAux.getUsername() + msm);
                        }

                        //Si el usuario es el dueño del bloqueo actual no se agrega la matricula
                        //a la lista de matriculas para bloquear
                    } else {
                        //La matrícula no está bloqueada
                        matsToLock.add(matricula);
                    }
                }
            }

            if (ht.size() > 0) {
                if (pm.currentTransaction().isActive()) {
                    pm.currentTransaction().rollback();
                }
                DAOException exc = new DAOException(
                        "Error en validación de bloqueo de folios");
                exc.setHashErrores(ht);
                throw exc;
            }

            if (matsToLock.size() > 0) {
                llave = this.crearLlaveBloqueo(pm);
                us.addLlavesBloqueo(llave);

                for (Iterator itr2 = matsToLock.iterator(); itr2.hasNext();) {
                    matricula = (String) itr2.next();

                    FolioEnhanced folio = this.getFolioByMatricula(matricula, pm);
                    BloqueoFolioEnhanced bl = new BloqueoFolioEnhanced();
                    bl.setFechaBloqueo(new Date());
                    bl.setFolio(folio);
                    bl.setLlaveBloqueo(llave);
                    bl.setIdWorkflowBloqueo(idWorkflow);

                    //SE SETEAN LAS SECUENCIAS DE LAS LISTAS TEMPORALES:
                    this.resetSecuenciasTemporalesFolio(folio, pm);
                    pm.makePersistent(bl);
                }

                pm.currentTransaction().commit();
                rta = (LlaveBloqueoEnhancedPk) pm.getObjectId(llave);

                return this.getLlaveBloqueo(rta.getLlaveBloqueoID());
            } else {
                if (pm.currentTransaction().isActive()) {
                    pm.currentTransaction().rollback();
                }
                return null;
            }
        } catch (DAOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            throw e;
        } catch (Exception e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }
    }

    /**
     *
     * @param pm
     * @return
     * @throws DAOException
     */
    protected LlaveBloqueoEnhanced crearLlaveBloqueo(PersistenceManager pm)
            throws DAOException {
        LlaveBloqueoEnhanced llave = new LlaveBloqueoEnhanced();

        try {
            long id = this.getSecuencial(CSecuencias.SIR_OP_LLAVE_BLOQUEO, null);
            llave.setIdLlave(String.valueOf(id));
            pm.makePersistent(llave);
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }

        return llave;
    }

    /**
     * Obtiene un usuario dado su identificador, método utilizado para
     * transacciones
     *
     * @param uID identificador del usuario
     * @param pm PersistenceManager de la transaccion
     * @return Usuario con sus atributos
     * @throws DAOException
     */
    protected UsuarioEnhanced getUsuarioByID(UsuarioEnhancedPk uID,
            PersistenceManager pm) throws DAOException {
        UsuarioEnhanced rta = null;

        if (String.valueOf(uID.idUsuario) != null) {
            try {
                rta = (UsuarioEnhanced) pm.getObjectById(uID, true);
            } catch (JDOObjectNotFoundException e) {
                rta = null;
            } catch (JDOException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                throw new DAOException(e.getMessage(), e);
            }
        }

        return rta;
    }

    /**
     *
     * @param oid
     * @param pm
     * @return
     * @throws DAOException
     */
    protected LlaveBloqueoEnhanced getLlaveBloqueo(
            LlaveBloqueoEnhancedPk oid, PersistenceManager pm)
            throws DAOException {
        LlaveBloqueoEnhanced rta = null;

        if (oid.idLlave != null) {
            try {
                rta = (LlaveBloqueoEnhanced) pm.getObjectById(oid, true);
            } catch (JDOObjectNotFoundException e) {
                rta = null;
            } catch (JDOException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                throw new DAOException(e.getMessage(), e);
            }
        }

        return rta;
    }

    /**
     *
     * @param oid
     * @return
     * @throws DAOException
     */
    public LlaveBloqueo getLlaveBloqueo(LlaveBloqueoPk oid)
            throws DAOException {
        LlaveBloqueoEnhanced rta = null;
        LlaveBloqueo aux = null;
        PersistenceManager pm = AdministradorPM.getPM();

        try {
            rta = this.getLlaveBloqueo(new LlaveBloqueoEnhancedPk(oid), pm);

            if (rta != null) {
                this.makeTransientLlaveBloqueo(rta, pm);
            }

            VersantPersistenceManager pm2 = (VersantPersistenceManager) pm;

            //pm2.versantDetachCopy((Collection)(new ArrayList().add(rta)), "");
        } catch (DAOException e) {
            throw e;
        } catch (Exception e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e);
        } finally {
            pm.close();
        }

        if (rta != null) {
            aux = (LlaveBloqueo) rta.toTransferObject();
        }

        return aux;
    }

    /**
     *
     * @param llave
     * @param pm
     * @throws DAOException
     */
    protected void makeTransientLlaveBloqueo(LlaveBloqueoEnhanced llave,
            PersistenceManager pm) throws DAOException {
        if (llave != null) {
            try {
                for (Iterator itr = llave.getBloqueoFolios().iterator();
                        itr.hasNext();) {
                    pm.makeTransient((BloqueoFolioEnhanced) itr.next());
                }

                pm.makeTransient(llave);
            } catch (JDOException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                throw new DAOException(e.getMessage(), e);
            }
        }
    }

    /**
     * Adiciona un EstadoAnotacion a la configuración del sistema
     *
     * @param datos objeto EstadoAnotacion con sus atributos exceptuando su
     * identificador el cual es generado por el sistema
     * @return identificador de estadoFolio generado
     */
    public EstadoAnotacionPk addEstadoAnotacion(EstadoAnotacion datos)
            throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        EstadoAnotacionEnhanced estado = EstadoAnotacionEnhanced.enhance(datos);

        try {
            //Validación de identificador del EstadoAnotacion
            EstadoAnotacionEnhancedPk eid = new EstadoAnotacionEnhancedPk();
            eid.idEstadoAn = estado.getIdEstadoAn();

            EstadoAnotacionEnhanced vcir = this.getEstadoAnotacion(eid, pm);

            if (vcir != null) {
                throw new DAOException(
                        "Ya existe un estado anotacion con el identificador: "
                        + eid.idEstadoAn);
            }

            pm.currentTransaction().setOptimistic(false);
            pm.currentTransaction().begin();
            pm.makePersistent(estado);
            pm.currentTransaction().commit();

            EstadoAnotacionEnhancedPk rta = (EstadoAnotacionEnhancedPk) pm.getObjectId(estado);

            return rta.getEstadoAnotacionID();
        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (Exception e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }
    }

    /**
     * Obtiene una lista de estados anotacion de la configuración del sistema
     *
     * @return lista de objetos EstadoAnotacion
     * @see gov.sir.core.negocio.modelo.EstadoAnotacion
     * @throws DAOException
     */
    protected List getEstadosAnotacion(PersistenceManager pm)
            throws DAOException {
        try {
            Query query = pm.newQuery(EstadoAnotacionEnhanced.class);
            query.setOrdering("nombre ascending");

            List rta = (List) query.execute();

            return rta;
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }
    }

    /**
     * Obtiene una lista de estados anotacion de la configuración del sistema
     *
     * @return lista de objetos EstadoAnotacion
     * @see gov.sir.core.negocio.modelo.EstadoAnotacion
     * @throws DAOException
     */
    public List getEstadosAnotacion() throws DAOException {
        List rta = null;
        PersistenceManager pm = AdministradorPM.getPM();

        try {
            rta = this.getEstadosAnotacion(pm);
            pm.makeTransientAll(rta);
        } catch (DAOException e) {
            throw e;
        } finally {
            pm.close();
        }

        return TransferUtils.makeTransferAll(rta);
    }

    /**
     * Agrega un grupo de naturaleza juridica la configuración del sistema
     *
     * @param naturaleza GrupoNaturalezaJuridica con su nombre
     * @throws DAOException
     */
    public GrupoNaturalezaJuridicaPk addGrupoNaturalezaJuridica(
            GrupoNaturalezaJuridica naturaleza) throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        GrupoNaturalezaJuridicaEnhanced grupo = GrupoNaturalezaJuridicaEnhanced.enhance(naturaleza);

        try {
            //Validación de identificador del EstadoAnotacion
            GrupoNaturalezaJuridicaEnhancedPk eid = new GrupoNaturalezaJuridicaEnhancedPk();
            eid.idGrupoNatJuridica = grupo.getIdGrupoNatJuridica();

            GrupoNaturalezaJuridicaEnhanced vcir = this.getGrupoNaturalezaJuridica(eid,
                    pm);

            if (vcir != null) {
                throw new DAOException(
                        "Ya existe un grupo de naturaleza jurídica con el identificador: "
                        + eid.idGrupoNatJuridica);
            }

            pm.currentTransaction().setOptimistic(false);
            pm.currentTransaction().begin();
            pm.makePersistent(grupo);
            pm.currentTransaction().commit();

            GrupoNaturalezaJuridicaEnhancedPk rta = (GrupoNaturalezaJuridicaEnhancedPk) pm.getObjectId(grupo);

            return rta.getGrupoNaturalezaJuridicaID();
        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (Exception e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }
    }

    /**
     * Agrega un dominio de naturaleza jurídica
     *
     * @param naturaleza
     * @return
     * @throws DAOException
     */
    public DominioNaturalezaJuridicaPk addDominioNaturalezaJuridica(
            DominioNaturalezaJuridica naturaleza) throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        DominioNaturalezaJuridicaEnhanced dominio = DominioNaturalezaJuridicaEnhanced.enhance(naturaleza);

        try {
            //Validación de identificador del Dominio
            DominioNaturalezaJuridicaEnhancedPk eid = new DominioNaturalezaJuridicaEnhancedPk();
            eid.idDominioNatJur = dominio.getIdDominioNatJur();

            DominioNaturalezaJuridicaEnhanced vcir = this.getDominioNaturalezaJuridica(eid,
                    pm);

            if (vcir != null) {
                throw new DAOException(
                        "Ya existe un Dominio de naturaleza jurídica con el identificador: "
                        + eid.idDominioNatJur);
            }

            pm.currentTransaction().setOptimistic(false);
            pm.currentTransaction().begin();
            pm.makePersistent(dominio);
            pm.currentTransaction().commit();

            DominioNaturalezaJuridicaEnhancedPk rta = (DominioNaturalezaJuridicaEnhancedPk) pm.getObjectId(dominio);

            return rta.getDominioNaturalezaJuridicaID();
        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (Exception e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }
    }

    /**
     * Obtiene un EstadoFolio dado su identificador, método usado en
     * transacciones se debe dar el PersistenceManager
     *
     * @param oid
     * @return objeto EstadoFolio
     * @throws DAOException
     */
    protected GrupoNaturalezaJuridicaEnhanced getGrupoNaturalezaJuridica(
            GrupoNaturalezaJuridicaEnhancedPk oid, PersistenceManager pm)
            throws DAOException {
        GrupoNaturalezaJuridicaEnhanced rta = null;

        if (oid.idGrupoNatJuridica != null) {
            try {
                rta = (GrupoNaturalezaJuridicaEnhanced) pm.getObjectById(oid,
                        true);
            } catch (JDOObjectNotFoundException e) {
                rta = null;
            } catch (JDOException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                throw new DAOException(e.getMessage(), e);
            }
        }

        return rta;
    }

    /**
     *
     * @param oid
     * @param pm
     * @return
     * @throws DAOException
     */
    protected DominioNaturalezaJuridicaEnhanced getDominioNaturalezaJuridica(
            DominioNaturalezaJuridicaEnhancedPk oid, PersistenceManager pm)
            throws DAOException {
        DominioNaturalezaJuridicaEnhanced rta = null;

        if (oid.idDominioNatJur != null) {
            try {
                rta = (DominioNaturalezaJuridicaEnhanced) pm.getObjectById(oid,
                        true);
            } catch (JDOObjectNotFoundException e) {
                rta = null;
            } catch (JDOException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                throw new DAOException(e.getMessage(), e);
            }
        }

        return rta;
    }

    /**
     * Obtiene un EstadoFolio dado su identificador, método usado en
     * transacciones se debe dar el PersistenceManager
     *
     * @param oid
     * @return objeto EstadoFolio
     * @throws DAOException
     */
    public GrupoNaturalezaJuridica getGrupoNaturalezaJuridica(
            GrupoNaturalezaJuridicaPk oid) throws DAOException {
        GrupoNaturalezaJuridicaEnhanced ef = null;
        PersistenceManager pm = AdministradorPM.getPM();
        GrupoNaturalezaJuridica aux = null;

        try {
            ef = this.getGrupoNaturalezaJuridica(new GrupoNaturalezaJuridicaEnhancedPk(
                    oid), pm);
            pm.makeTransientAll(ef.getNaturalezaJuridicas());
            pm.makeTransient(ef);
        } catch (DAOException e) {
            throw e;
        } finally {
            pm.close();
        }

        if (ef != null) {
            aux = (GrupoNaturalezaJuridica) ef.toTransferObject();
        }

        return aux;
    }

    /**
     *
     * @param oid
     * @return
     * @throws DAOException
     */
    public DominioNaturalezaJuridica getDominioNaturalezaJuridica(
            DominioNaturalezaJuridicaPk oid) throws DAOException {
        DominioNaturalezaJuridicaEnhanced ef = null;
        PersistenceManager pm = AdministradorPM.getPM();
        DominioNaturalezaJuridica aux = null;

        try {
            ef = this.getDominioNaturalezaJuridica(new DominioNaturalezaJuridicaEnhancedPk(
                    oid), pm);
            pm.makeTransient(ef);
        } catch (DAOException e) {
            throw e;
        } finally {
            pm.close();
        }

        if (ef != null) {
            aux = (DominioNaturalezaJuridica) ef.toTransferObject();
        }

        return aux;
    }

    /**
     * @param notaria con su tipo, nombre, numero, departamento, municipio
     * @return
     * @throws DAOException
     */
    public OficinaOrigenPk addOficinaOrigen(OficinaOrigen oficina)
            throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        OficinaOrigenEnhanced of = OficinaOrigenEnhanced.enhance(oficina);
        JDOGenieZonaRegistralDAO zonaDAO = new JDOGenieZonaRegistralDAO();

        try {
            pm.currentTransaction().setOptimistic(false);
            pm.currentTransaction().begin();
            /*
             *  @author Carlos Torres
             *  @chage   se agrega validacion de version diferente
             *  @mantis 0013414: Acta - Requerimiento No 069_453_Código_Notaria_NC
             */
            if (of.getIdOficinaOrigen() == null) {
                //Obtención de posible llave primaria de oficina origen
                of.setIdOficinaOrigen(this.getSecuencial(
                        CSecuencias.OFICINA_ORIGEN, pm) + "");
                of.setVersion(1L);
            } else {
                Long l = this.getMaxOficinaOrigen(oficina);
                of.setVersion(l + 1);
            }

            //Validación y asociación del tipo de oficina
            TipoOficinaEnhanced tipo = of.getTipoOficina();

            if (tipo == null) {
                throw new DAOException("La oficina debe tener un tipo");
            }

            TipoOficinaEnhancedPk tId = new TipoOficinaEnhancedPk();
            tId.idTipoOficina = tipo.getIdTipoOficina();

            tipo = this.getTipoOficina(tId, pm);

            if (tipo == null) {
                throw new DAOException("El tipo de oficina no existe: "
                        + tId.idTipoOficina);
            }

            of.setTipoOficina(tipo);

            //Validación y asociación de la Categoría de la Notaría
            CategoriaNotariaEnhanced catNotaria = of.getCategoriaNotaria();

            //Este atributo solo aplica para las Notarías, por lo cual su valor puede
            //ser nulo.
            if (catNotaria != null) {

                CategoriaNotariaEnhancedPk catId = new CategoriaNotariaEnhancedPk();
                catId.idCategoria = catNotaria.getIdCategoria();

                catNotaria = this.getCategoriaNotaria(catId, pm);

                if (tipo == null) {
                    throw new DAOException("La Categoría de la notaría no existe: "
                            + catId.idCategoria);
                }

                of.setCategoriaNotaria(catNotaria);
            }

            //Validación y asociación de la vereda
            VeredaEnhanced ver = of.getVereda();

            if (ver == null) {
                throw new DAOException(
                        "La oficina debe tener una vereda asociada");
            }

            VeredaEnhancedPk vId = new VeredaEnhancedPk();
            vId.idDepartamento = ver.getIdDepartamento();
            vId.idMunicipio = ver.getIdMunicipio();
            vId.idVereda = ver.getIdVereda();

            ver = zonaDAO.getVereda(vId, pm);

            if (ver == null) {
                throw new DAOException(
                        "La vereda asociada a la oficina no existe");
            }

            of.setVereda(ver);

            //Validación de unicidad de la oficina origen
            OficinaOrigenEnhanced vcir = this.getOficinaOrigenByTipoVeredaNumero(of.getTipoOficina(),
                    of.getVereda(), of.getNombre(), null, pm);

            if (vcir != null) {
                throw new DAOException(
                        "Ya existe una oficina origen del mismo tipo, en la misma vereda y con el mismo nombre ");
            }

            //Asociación de zonas notariales en el caso que esten asociadas
            /*
            List zonas = of.getZonasNotariales();
            ZonaNotarialEnhanced zn;

            for (Iterator itr = zonas.iterator(); itr.hasNext();) {
                zn = (ZonaNotarialEnhanced) itr.next();
                this.addZonaNotarialToOficinaOrigen(of, zn, pm);
            }*/
            for (Iterator it = of.getCategorias().iterator(); it.hasNext();) {
                OficinaCategoriaEnhanced ofCatTr = (OficinaCategoriaEnhanced) it.next();
                getUltimaOficinaCategoria(of, ofCatTr);
                CategoriaEnhanced catVal = ofCatTr.getCategoria();

                if (catVal == null) {
                    throw new DAOException("Cada objeto asociación oficina-categoría debe tener la CATEGORIA");
                }

                CategoriaEnhancedPk carValID = new CategoriaEnhancedPk();
                carValID.idCategoria = catVal.getIdCategoria();
                CategoriaEnhanced catPr = this.getCategoriaById(carValID, pm);

                if (catPr == null) {
                    throw new DAOException("La categoría con el ID " + carValID.idCategoria + " no existe");
                }
                ofCatTr.setCategoria(catPr);
                ofCatTr.setOficinaOrigen(of);
            }

            pm.makePersistent(of);
            pm.currentTransaction().commit();

            OficinaOrigenEnhancedPk rta = (OficinaOrigenEnhancedPk) pm.getObjectId(of);

            return rta.getOficinaOrigenID();
        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (DAOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw e;
        } catch (Exception e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }
    }

    /*
             *  @author Carlos Torres
             *  @chage   se agrega validacion de version diferente
             *  @mantis 0013414: Acta - Requerimiento No 069_453_Código_Notaria_NC
     */
    public Long getMaxOficinaOrigen(OficinaOrigen oficina) throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        pm.currentTransaction().begin();
        VersantPersistenceManager jdoPM = (VersantPersistenceManager) pm;

        ResultSet rs = null;
        PreparedStatement pst = null;
        PreparedStatement pst1 = null;
        Connection connection = null;

        String sql = "select max(nvl(version,0)) from sir_ne_oficina_origen "
                + "where id_oficina_origen = ? ";

        try {
            connection = jdoPM.getJdbcConnection(null);
            pst = connection.prepareStatement(sql);
            pst.setString(1, oficina.getIdOficinaOrigen());

            rs = pst.executeQuery();
            while (rs.next()) {
                return rs.getLong(1);
            }

        } catch (SQLException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            throw new DAOException("Error SQL: " + e, e);
        } finally {
            if (connection != null) {
                try {
                    if (rs != null) {
                        rs.close();
                    }
                    if (pst != null) {
                        pst.close();
                    }
                    if (pst1 != null) {
                        pst1.close();
                    }
                    if (connection != null) {
                        connection.close();
                    }
                } catch (SQLException e1) {
                    Log.getInstance().error(JDOGenieFolioDAO.class, e1.getMessage());
                }
            }
        }
        return 0L;
    }

    /*
    *  @author Fernando Padilla Velez
    *  @chage  1203.AJUSTE.VERSION.CATEGORIA.REPARTO.NOTARIAL,
    *          actualiza la informacion del orden y peso de la ultima oficina categoria.
     */
    public void getUltimaOficinaCategoria(OficinaOrigenEnhanced of, OficinaCategoriaEnhanced oficina) throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        pm.currentTransaction().begin();
        VersantPersistenceManager jdoPM = (VersantPersistenceManager) pm;
        ResultSet rs = null;
        PreparedStatement pst = null;
        Connection connection = null;

        String sql = "select FRCT_ORDEN_INICIAL, FRCT_PESO_REPARTO from sir_op_of_origen_categoria where ID_OFICINA_ORIGEN = ? and ID_CATEGORIA = ? and VERSION = ( "
                + "select max(nvl(version,0)) from sir_op_of_origen_categoria "
                + "where ID_OFICINA_ORIGEN = ? and ID_CATEGORIA = ?) ";

        try {
            connection = jdoPM.getJdbcConnection(null);
            pst = connection.prepareStatement(sql);
            pst.setString(1, of.getIdOficinaOrigen());
            pst.setString(2, oficina.getIdCategoria());
            pst.setString(3, of.getIdOficinaOrigen());
            pst.setString(4, oficina.getIdCategoria());

            rs = pst.executeQuery();
            if (rs.next()) {
                oficina.setOrdenInicial(rs.getInt(1));
                oficina.setPesoReparto(rs.getInt(2));
            }

        } catch (SQLException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            throw new DAOException("Error SQL: " + e, e);
        } finally {
            if (connection != null) {
                try {
                    if (rs != null) {
                        rs.close();
                    }
                    if (pst != null) {
                        pst.close();
                    }
                    if (connection != null) {
                        connection.close();
                    }
                } catch (SQLException e1) {
                    Log.getInstance().error(JDOGenieFolioDAO.class, e1.getMessage());
                }
            }
        }
    }

    /**
     * Actualiza una oficina origen con TODOS los datos que llegan el en objeto.
     * El objeto debe tener su identificador.
     *
     * @param oficina
     * @return
     * @throws DAOException
     */
    public boolean updateOficinaOrigen(OficinaOrigen oficina)
            throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        OficinaOrigenEnhanced of = OficinaOrigenEnhanced.enhance(oficina);
        JDOGenieZonaRegistralDAO zonaDAO = new JDOGenieZonaRegistralDAO();

        try {
            pm.currentTransaction().begin();

            //Validación de la oficina origen a actualizar
            OficinaOrigenEnhancedPk oficinaID = new OficinaOrigenEnhancedPk();
            oficinaID.idOficinaOrigen = oficina.getIdOficinaOrigen();
            /*
                                  *  @author Carlos Torres
                                  *  @chage   se agrega validacion de version diferente
                                  *  @mantis 0013414: Acta - Requerimiento No 069_453_Código_Notaria_NC
             */
            oficinaID.version = oficina.getVersion();

            OficinaOrigenEnhanced toUpdate = this.getOficinaOrigen(oficinaID, pm);

            if (toUpdate == null) {
                throw new DAOException("La oficina origen no existe. ID: " + oficina.getIdOficinaOrigen());
            }

            //Validación y asociación del tipo de oficina
            TipoOficinaEnhanced tipo = of.getTipoOficina();

            if (tipo == null) {
                throw new DAOException("La oficina debe tener un tipo");
            }

            TipoOficinaEnhancedPk tId = new TipoOficinaEnhancedPk();
            tId.idTipoOficina = tipo.getIdTipoOficina();

            tipo = this.getTipoOficina(tId, pm);

            if (tipo == null) {
                throw new DAOException("El tipo de oficina no existe: "
                        + tId.idTipoOficina);
            }

            toUpdate.setTipoOficina(tipo);

            // Validación y asociación de la Categoría de la Notaría
            CategoriaNotariaEnhanced catNotaria = of.getCategoriaNotaria();

            //Este atributo solo aplica para las Notarías, por lo cual su valor puede
            //ser nulo.
            if (catNotaria != null) {

                CategoriaNotariaEnhancedPk catId = new CategoriaNotariaEnhancedPk();
                catId.idCategoria = catNotaria.getIdCategoria();

                catNotaria = this.getCategoriaNotaria(catId, pm);

                if (tipo == null) {
                    throw new DAOException("La Categoría de la notaría no existe: "
                            + catId.idCategoria);
                }

                toUpdate.setCategoriaNotaria(catNotaria);
            }

            //Validación y asociación de la vereda
            VeredaEnhanced ver = of.getVereda();

            if (ver == null) {
                throw new DAOException(
                        "La oficina debe tener una vereda asociada");
            }

            VeredaEnhancedPk vId = new VeredaEnhancedPk();
            vId.idDepartamento = ver.getIdDepartamento();
            vId.idMunicipio = ver.getIdMunicipio();
            vId.idVereda = ver.getIdVereda();

            ver = zonaDAO.getVereda(vId, pm);

            if (ver == null) {
                throw new DAOException(
                        "La vereda asociada a la oficina no existe");
            }

            toUpdate.setVereda(ver);

            toUpdate.setNumero(of.getNumero());
            toUpdate.setNombre(of.getNombre());
            toUpdate.setDireccion(of.getDireccion());
            toUpdate.setEmail(of.getEmail());
            toUpdate.setEncargado(of.getEncargado());
            toUpdate.setFax(of.getFax());
            toUpdate.setTelefono(of.getTelefono());

            //Validación de unicidad de la oficina origen
            OficinaOrigenEnhanced vcir = this.getOficinaOrigenByTipoVeredaNumero(toUpdate.getTipoOficina(),
                    toUpdate.getVereda(), toUpdate.getNombre(), toUpdate.getIdOficinaOrigen(), pm);

            if (vcir != null) {
                throw new DAOException(
                        "Ya existe una oficina origen del mismo tipo, en la misma vereda y con el mismo número ");
            }

            Iterator itCategoriasEnhNew = of.getCategorias().iterator();

            List catToAdd = new ArrayList();

            while (itCategoriasEnhNew.hasNext()) {
                OficinaCategoriaEnhanced ofCategEnh = (OficinaCategoriaEnhanced) itCategoriasEnhNew.next();
                boolean estaToAdd = false;
                Iterator itCategoriasEnhOld = toUpdate.getCategorias().iterator();
                while (itCategoriasEnhOld.hasNext() && !estaToAdd) {
                    OficinaCategoriaEnhanced ofCategOld = (OficinaCategoriaEnhanced) itCategoriasEnhOld.next();
                    if (ofCategOld.getIdCategoria().equals(ofCategEnh.getIdCategoria())) {
                        estaToAdd = true;
                    }
                }
                if (!estaToAdd) {
                    catToAdd.add(ofCategEnh);
                }
            }

            List catToDelete = new ArrayList();

            Iterator itCategoriasOld = toUpdate.getCategorias().iterator();

            while (itCategoriasOld.hasNext()) {
                OficinaCategoriaEnhanced ofCategOld = (OficinaCategoriaEnhanced) itCategoriasOld.next();
                boolean estaToDelete = false;
                Iterator itCategoriasNew = of.getCategorias().iterator();
                while (itCategoriasNew.hasNext() && !estaToDelete) {
                    OficinaCategoriaEnhanced ofCategEnh = (OficinaCategoriaEnhanced) itCategoriasNew.next();
                    if (ofCategOld.getIdCategoria().equals(ofCategEnh.getIdCategoria())) {
                        estaToDelete = true;
                    }
                }
                if (!estaToDelete) {
                    catToDelete.add(ofCategOld);
                }
            }

            //borra solo las que no aparecen en la nueva oficina
            pm.deletePersistentAll(catToDelete);

            //Se limpian las categorias:
            //pm.deletePersistentAll(toUpdate.getCategorias());
            //Ejecutamos el borrado de los resultados
            VersantPersistenceManager pm2 = (VersantPersistenceManager) pm;
            pm2.flush();

            for (Iterator it = catToAdd.iterator(); it.hasNext();) {
                OficinaCategoriaEnhanced ofCatTr = (OficinaCategoriaEnhanced) it.next();
                CategoriaEnhanced catVal = ofCatTr.getCategoria();

                if (catVal == null) {
                    throw new DAOException("Cada objeto asociación oficina-categoría debe tener la CATEGORIA");
                }

                CategoriaEnhancedPk carValID = new CategoriaEnhancedPk();
                carValID.idCategoria = catVal.getIdCategoria();
                CategoriaEnhanced catPr = this.getCategoriaById(carValID, pm);

                if (catPr == null) {
                    throw new DAOException("La categoría con el ID " + carValID.idCategoria + " no existe");
                }
                ofCatTr.setCategoria(catPr);
                ofCatTr.setOficinaOrigen(toUpdate);
                pm.makePersistent(ofCatTr);
            }

            pm.currentTransaction().commit();
            return true;
        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            String mensajeError = e.getMessage().lastIndexOf("Column:ID_CATEGORIA = ") != -1
                    ? "No se pudo desasociar la(s) categoria(s) porque ya pertenece(n) a una minuta: "
                    : e.getMessage();

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(mensajeError, e);
        } catch (DAOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw e;
        } catch (Exception e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }
    }

    /**
     * Obtiene un TipoPredio dado su identificador, usado para transacciones se
     * debe dar el PersistenceManager
     *
     * @param oid identificador del tipoPredio
     * @return objeto TipoPredio
     * @throws DAOException
     */
    protected OficinaOrigenEnhanced getOficinaOrigen(
            OficinaOrigenEnhancedPk oid, PersistenceManager pm)
            throws DAOException {
        OficinaOrigenEnhanced rta = null;

        if (oid.idOficinaOrigen != null) {
            try {
                rta = (OficinaOrigenEnhanced) pm.getObjectById(oid, true);
            } catch (JDOObjectNotFoundException e) {
                rta = null;
            } catch (JDOException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                throw new DAOException(e.getMessage(), e);
            }
        }

        return rta;
    }

    /**
     * Obtiene un Municipio dado su identificador, usado para transacciones se
     * debe dar el PersistenceManager
     *
     * @param oid identificador del tipoPredio
     * @return objeto TipoPredio
     * @throws DAOException
     */
    protected MunicipioEnhanced getMunicipio(
            MunicipioEnhancedPk oid, PersistenceManager pm)
            throws DAOException {
        MunicipioEnhanced rta = null;

        if (oid.idDepartamento != null && oid.idMunicipio != null) {
            try {
                rta = (MunicipioEnhanced) pm.getObjectById(oid, true);
            } catch (JDOObjectNotFoundException e) {
                rta = null;
            } catch (JDOException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                throw new DAOException(e.getMessage(), e);
            }
        }

        return rta;
    }

    /**
     * Obtiene una oficina origen por ID
     *
     * @param oid
     * @return
     * @throws DAOException
     */
    public OficinaOrigen getOficinaOrigen(OficinaOrigenPk oid)
            throws DAOException {
        OficinaOrigenEnhanced ef = null;
        PersistenceManager pm = AdministradorPM.getPM();
        OficinaOrigen aux = null;

        try {
            ef = this.getOficinaOrigen(new OficinaOrigenEnhancedPk(oid), pm);
            this.makeTransientOficinaOrigen(ef, pm);
        } catch (DAOException e) {
            throw e;
        } finally {
            pm.close();
        }

        if (ef != null) {
            aux = (OficinaOrigen) ef.toTransferObject();
        }

        return aux;
    }

    /**
     * Obtiene un TipoPredio dado su identificador, usado para transacciones se
     * debe dar el PersistenceManager
     *
     * @param oid identificador del tipoPredio
     * @return objeto TipoPredio
     * @throws DAOException
     */
    protected OficinaOrigenEnhanced getOficinaOrigenByTipoVeredaNumero(
            TipoOficinaEnhanced tipo, VeredaEnhanced v, String nom, String idOficinaNoValidar,
            PersistenceManager pm) throws DAOException {
        OficinaOrigenEnhanced rta = null;

        try {
            Query query = pm.newQuery(OficinaOrigenEnhanced.class);
            query.declareParameters(
                    "TipoOficinaEnhanced tipo, VeredaEnhanced v, String nom, String idOficinaNoValidar");
            query.setFilter("tipoOficina == tipo && vereda == v && this.nombre==nom && idOficinaOrigen!=idOficinaNoValidar");

            Collection col = (Collection) query.executeWithArray(new Object[]{tipo, v, nom, idOficinaNoValidar});
            Iterator iter = col.iterator();

            if (iter.hasNext()) {
                rta = (OficinaOrigenEnhanced) iter.next();

                //logEstatico.debug(oficinaorigenenhanced);
            } else {
                rta = null;
            }

            query.closeAll();
        } catch (JDOObjectNotFoundException e) {
            rta = null;
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }

        return rta;
    }

    /**
     * @author Carlos Torres
     * @mantis 0013414: Acta - Requerimiento No 069_453_Código_Notaria_NC
     * Obtiene un TipoPredio dado su identificador, usado para transacciones se
     * debe dar el PersistenceManager
     * @param oid identificador del tipoPredio
     * @return objeto TipoPredio
     * @throws DAOException
     */
    protected OficinaOrigenEnhanced getOficinaOrigenByTipoVeredaNumero(
            TipoOficinaEnhanced tipo, VeredaEnhanced v, String nom, String idOficinaNoValidar, Long verOficinaNoValidar,
            PersistenceManager pm) throws DAOException {
        OficinaOrigenEnhanced rta = null;

        try {
            Query query = pm.newQuery(OficinaOrigenEnhanced.class);
            query.declareParameters(
                    "TipoOficinaEnhanced tipo, VeredaEnhanced v, String nom, String idOficinaNoValidar,Long verOficinaNoValidar");
            query.setFilter("tipoOficina == tipo && vereda == v && this.nombre==nom && idOficinaOrigen!=idOficinaNoValidar && version == verOficinaNoValidar");

            Collection col = (Collection) query.executeWithArray(new Object[]{tipo, v, nom, idOficinaNoValidar, verOficinaNoValidar});
            Iterator iter = col.iterator();

            if (iter.hasNext()) {
                rta = (OficinaOrigenEnhanced) iter.next();

                //logEstatico.debug(oficinaorigenenhanced);
            } else {
                rta = null;
            }

            query.closeAll();
        } catch (JDOObjectNotFoundException e) {
            rta = null;
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }

        return rta;
    }

    /**
     *
     * @param oficina
     * @param zona
     * @param pm
     * @return
     * @throws DAOException
     */

    /*
        protected boolean addZonaNotarialToOficinaOrigen(
            OficinaOrigenEnhanced oficina, ZonaNotarialEnhanced zona,
            PersistenceManager pm) throws DAOException {
            JDOGenieZonaRegistralDAO zonaRegistralDAO = new JDOGenieZonaRegistralDAO();
            boolean rta = false;

            try {
                //Validación de círculo asociado
                CirculoEnhanced cir;
                CirculoEnhanced.ID cId = new CirculoEnhanced.ID();
                cir = zona.getCirculo();

                if (cir == null) {
                    throw new DAOException(
                        "La zona notarial no tiene circulo asociado");
                }

                cId.idCirculo = cir.getIdCirculo();
                cir = zonaRegistralDAO.getCirculo(cId, pm);

                if (cir == null) {
                    throw new DAOException(
                        "El círculo asociado de la zona notarial no existe: " +
                        cId.idCirculo);
                }

                zona.setCirculo(cir);
                zona.setOficinaOrigen(oficina);
                rta = true;
            } catch (DAOException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                throw e;
            } catch (JDOException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                throw new DAOException(e.getMessage(), e);
            }

            return rta;
        }
     */
    /**
     * Obtiene un objeto TipoOficina dado su identificador en una transacción
     *
     * @param oid identificador del Tipo de Oficina
     * @param pm PersistenceManager con la transacción
     * @return objeto TipoDocumento persistente
     * @throws DAOException
     */
    protected TipoOficinaEnhanced getTipoOficina(TipoOficinaEnhancedPk oid,
            PersistenceManager pm) throws DAOException {
        TipoOficinaEnhanced rta = null;

        if (oid.idTipoOficina != null) {
            try {
                rta = (TipoOficinaEnhanced) pm.getObjectById(oid, true);
            } catch (JDOObjectNotFoundException e) {
                rta = null;
            } catch (JDOException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                throw new DAOException(e.getMessage(), e);
            }
        }

        return rta;
    }

    /**
     * Obtiene un objeto CategoriaNotaria dado su identificador en una
     * transacción
     *
     * @param oid identificador categoria de la notaria
     * @param pm PersistenceManager con la transacción
     * @return objeto CategoriaNotaria persistente
     * @throws DAOException
     */
    protected CategoriaNotariaEnhanced getCategoriaNotaria(CategoriaNotariaEnhancedPk oid,
            PersistenceManager pm) throws DAOException {
        CategoriaNotariaEnhanced rta = null;

        if (oid.idCategoria != null) {
            try {
                rta = (CategoriaNotariaEnhanced) pm.getObjectById(oid, true);
            } catch (JDOObjectNotFoundException e) {
                rta = null;
            } catch (JDOException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                throw new DAOException(e.getMessage(), e);
            }
        }

        return rta;
    }

    /**
     *
     * @param tableName
     * @param pm
     * @return
     * @throws DAOException
     */
    protected long getAndUpdateLlavePrimaria(String tableName,
            PersistenceManager pm) throws DAOException {
        SecuenciasEnhanced rta = null;

        if (tableName != null) {
            try {
                SecuenciasEnhancedPk oid = new SecuenciasEnhancedPk();
                oid.tableName = tableName;
                rta = (SecuenciasEnhanced) pm.getObjectById(oid, true);
                rta.setLastUsedId(rta.getLastUsedId() + 1);
            } catch (JDOObjectNotFoundException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                throw new DAOException(
                        "No encontró la secuencia de la tabla especificada "
                        + tableName, e);
            } catch (JDOException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                throw new DAOException(e.getMessage(), e);
            }
        }

        return rta.getLastUsedId();
    }

    /**
     * Desbloquea los folios especificados de una lista de matriculas a un
     * usuario determinado. Si en el desbloqueo de algún folio se produce una
     * excepción, esta quedará registrada en la hastable de DAOException en
     * donde la llave es la matricula y el valor el mensaje de excepción. Si no
     * se produce ningún error no se lanza ninguna excepción
     *
     * @param matriculas
     * @param usuario
     * @return
     * @throws DAOException
     */
    public boolean desbloquearFolios(List matriculas, Usuario usuario)
            throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        EstadoFolio aux = null;
        LlaveBloqueoEnhanced llave = null;
        String matricula;
        Hashtable ht = new Hashtable();

        UsuarioEnhanced us = UsuarioEnhanced.enhance(usuario);
        UsuarioEnhancedPk usId = new UsuarioEnhancedPk();
        usId.idUsuario = us.getIdUsuario();

        boolean rta = false;
        BloqueoFolioEnhanced bloqueo = null;

        try {
            pm.currentTransaction().begin();

            //Validación del usuario
            us = this.getUsuarioByID(usId, pm);

            if (us == null) {
                throw new DAOException("El usuario especificado no existe");
            }

            //Se recorre la lista de matrículas, se hacen las validaciones para cada una
            for (Iterator itr = matriculas.iterator(); itr.hasNext();) {
                matricula = (String) itr.next();

                //Se valida que exista la matrícula
                if (this.getFolioByMatricula(matricula, pm) == null) {
                    ht.put(matricula, "La matricula no existe");
                } else {
                    //Se valida que la matrícula se encuentre bloqueada y se obtiene
                    //el objeto bloqueoFolio
                    bloqueo = this.getBloqueoFolio(matricula, pm);

                    if (bloqueo == null) {
                        ht.put(matricula,
                                "La matricula no se encuentra bloqueada");
                    } else {
                        UsuarioEnhanced usuAux = this.getUsuarioByLlaveBloqueo(bloqueo.getLlaveBloqueo(),
                                pm);

                        //Se valida que el usuario dado sea el que tenga bloqueado el folio
                        if (usuAux == null) {
                            ht.put(matricula,
                                    "Error en la obtención del usuario dueño del bloqueo");
                        } else if (usuAux.getIdUsuario() != us.getIdUsuario()) {
                            ht.put(matricula,
                                    "El usuario no es el dueño del bloqueo de la matrícula");
                        } else {
                            BloqueoFolioEnhanced viejo = (BloqueoFolioEnhanced) auditoria.clonarEnhanced(bloqueo);
                            bloqueo.setFechaDesbloqueo(new Date());
                        }
                    }
                }
            }

            if (ht.size() > 0) {
                if (pm.currentTransaction().isActive()) {
                    pm.currentTransaction().rollback();
                }
                DAOException exc = new DAOException(
                        "Error en validación de desbloqueo de folios");
                exc.setHashErrores(ht);
                throw exc;
            }

            pm.currentTransaction().commit();

            rta = true;
        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (DAOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            throw e;
        } catch (Exception e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        return rta;
    }

    /*
     * desbloquea los folios cuando van entrando a calificacion*/
    public boolean desbloquearFoliosEntradaCalificacion(List matriculas, Usuario usuario)
            throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        EstadoFolio aux = null;
        LlaveBloqueoEnhanced llave = null;
        String matricula;
        Hashtable ht = new Hashtable();

        UsuarioEnhanced us = UsuarioEnhanced.enhance(usuario);
        UsuarioEnhancedPk usId = new UsuarioEnhancedPk();
        usId.idUsuario = us.getIdUsuario();

        boolean rta = false;
        BloqueoFolioEnhanced bloqueo = null;

        try {
            pm.currentTransaction().begin();

            //Validación del usuario
            us = this.getUsuarioByID(usId, pm);

            if (us == null) {
                throw new DAOException("El usuario especificado no existe");
            }

            //Se recorre la lista de matrículas, se hacen las validaciones para cada una
            for (Iterator itr = matriculas.iterator(); itr.hasNext();) {
                matricula = (String) itr.next();

                //Se valida que exista la matrícula
                if (this.getFolioByMatricula(matricula, pm) == null) {
                    ht.put(matricula, "La matricula no existe");
                } else {
                    //Se valida que la matrícula se encuentre bloqueada y se obtiene
                    //el objeto bloqueoFolio
                    bloqueo = this.getBloqueoFolio(matricula, pm);

                    if (bloqueo != null) {
                        UsuarioEnhanced usuAux = this.getUsuarioByLlaveBloqueo(bloqueo.getLlaveBloqueo(),
                                pm);

                        //Se valida que el usuario dado sea el que tenga bloqueado el folio
                        if (usuAux == null) {
                            ht.put(matricula,
                                    "Error en la obtención del usuario dueño del bloqueo");
                        } else if (usuAux.getIdUsuario() != us.getIdUsuario()) {
                            ht.put(matricula,
                                    "El usuario no es el dueño del bloqueo de la matrícula");
                        } else {
                            BloqueoFolioEnhanced viejo = (BloqueoFolioEnhanced) auditoria.clonarEnhanced(bloqueo);
                            bloqueo.setFechaDesbloqueo(new Date());
                        }
                    }
                }
            }

            if (ht.size() > 0) {
                if (pm.currentTransaction().isActive()) {
                    pm.currentTransaction().rollback();
                }
                DAOException exc = new DAOException(
                        "Error en validación de desbloqueo de folios");
                exc.setHashErrores(ht);
                throw exc;
            }

            pm.currentTransaction().commit();

            rta = true;
        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (DAOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            throw e;
        } catch (Exception e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        return rta;
    }

    /**
     * Retorna el bloqueo de la matricula en caso que esté bloqueada, si no está
     * bloqueada retorna null
     *
     * @param matricula
     * @param pm
     * @return
     * @throws DAOException
     */
    protected BloqueoFolioEnhanced getBloqueoFolio(String matricula,
            PersistenceManager pm) throws DAOException {
        BloqueoFolioEnhanced rta = null;

        if (matricula != null) {
            try {
                Query query = pm.newQuery(BloqueoFolioEnhanced.class);
                query.declareParameters("String matricula");
                query.setFilter(
                        "this.idMatricula==matricula && this.fechaDesbloqueo==null");

                Collection col = (Collection) query.execute(matricula);

                Iterator iter = col.iterator();

                if (iter.hasNext()) {
                    rta = (BloqueoFolioEnhanced) iter.next();
                }
            } catch (JDOObjectNotFoundException e) {
                rta = null;
            } catch (JDOException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                throw new DAOException(e.getMessage(), e);
            }
        }
        return rta;
    }

    /**
     * Obtiene el usuario dueño de la llave de bloqueo,
     *
     * @param llave Objeto Persistente
     * @param pm
     * @return
     * @throws DAOException
     */
    protected UsuarioEnhanced getUsuarioByLlaveBloqueo(
            LlaveBloqueoEnhanced llave, PersistenceManager pm)
            throws DAOException {
        UsuarioEnhanced rta = null;

        try {
            Query query = pm.newQuery(UsuarioEnhanced.class);
            query.declareParameters("LlaveBloqueoEnhanced llave");
            query.setFilter("this.llavesBloqueo.contains(llave)");

            Collection col = (Collection) query.execute(llave);

            Iterator iter = col.iterator();

            if (iter.hasNext()) {
                rta = (UsuarioEnhanced) iter.next();
            }
        } catch (JDOObjectNotFoundException e) {
            rta = null;
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }

        return rta;
    }

    /**
     * Actualiza la información de un folio dependiendo de los cambios que
     * vienen en el objeto. El usuario debe tener bloqueado el folio para poder
     * afectar la información de éste, de lo contrario se genera un
     * ForsetiException. Los cambios quedan registrados en el esquema temporal.
     * Los cambios o actualizaciones de los objetos dependientes del folio se
     * comportan de la siguiente manera: (Se actualizan los que vienen
     * diferentes a null)
     *
     * Lindero: folio.getLindero() El lindero puede ser actualizado.
     *
     * Código catastral: folio.getCodCatastral() El código catastral puede ser
     * actualizado.
     *
     * Código catastral anterior: folio.getCodCatastralAnterior() El código
     * catastral anterior puede ser actualizado.
     *
     * Complementación: folio.getComplementacion() La complementación puede ser
     * actualizada. Si se afecta la complementación de un folio, se afectan la
     * de todos los folios que hagan referencia a la misma cuando se vuelva
     * definitivo
     *
     * Documento: folio.getDocumento() Los datos del documento del folio pueden
     * ser actualizados a añadidos. Si el documento actual del folio es nulo, el
     * documento es añadido. En caso que el folio tenga asociado un documento,
     * los datos que vengan diferentes a null en el objeto Documento
     * actualizarán los datos actuales de este
     *
     * Tipo de predio: folio.getTipoPredio() El tipo de predio puede ser
     * actualizado
     *
     * Estado de predio: folio.getEstado() El estado del predio puede ser
     * modificado
     *
     * Salvedades folio: folio.getSalvedades() Las salvedades sólo pueden ser
     * añadidas, por lo tanto no necesitan IdSalvedad
     *
     * Direcciones: (folio.getDirecciones()) Las direcciones nunca son
     * actualizadas, sólamente son insertadas. Por lo tanto toda dirección que
     * llegue será insertada dentro de las direcciones temporales del folio.
     * Cada dirección debe tener el primer eje asociado.
     *
     * PARA ANOTACIONES:
     *
     * Anotaciones: (folio.getAnotaciones()) Las anotaciones pueden ser
     * actualizadas o añadidas.
     *
     * 1. Adición de anotaciones:
     *
     * Una anotación siempre es añadida en las anotaciones temporales. Para
     * agregar una anotación, se debe crear un objeto Anotacion sin setearle
     * IdAnotacion y se tienen que asociar sus objetos básicos:
     * NaturalezaJuridica, TipoAnotacion y Estado. La anotación puede incluir
     * ciudadanos a través de la lista de getAnotacionesCiudadanos(). Cada
     * anotaciónCiudadano debe tener seteado el objeto ciudadano con el número y
     * tipo de documento del ciudadano. Si el ciudadano existe se asocia, si no
     * existe se crea y se asocia. La anotación también puede incluir
     * salvedades, las salvedades se agregan a través de la lista
     * getSalvedadesAnotacion(). También puede incluir cancelaciones a través de
     * la lista getAnotacionesCancelacion(). Cada Cancelación debe tener
     * asociado el objeto "cancelada" que es una anotación existente con el ID
     * seteado.
     *
     * 2. Borrar anotaciones temporales
     *
     * Una anotación temporal puede ser eliminada con todas sus dependencias
     * (salvedades, ciudadanos y cancelaciones). No se pueden eliminar
     * anotaciones que estén encadenando folios, es decir las de tipo
     * "GENERADORA" o "DERIVADA" Tampoco se pueden eliminar anotaciones
     * temporales canceladas por otra anotación. Para eliminar una anotación
     * temporal se debe pasar un objeto anotación dentro de la lista de
     * anotaciones de folio con el IdAnotacion seteado que se quiere eliminar y
     * con el atributo toDelete de anotación en true.
     *
     * 3. Actualizar anotaciones temporales
     *
     * Una anotación temporal puede ser actualizada. Se pueden actualizar datos
     * básicos como: comentario, especificación, orden, naturaleza jurídica y
     * estado. Se pueden eliminar y añadir ciudadanos de la anotación, eliminar,
     * actualizar y añadir salvedades.
     *
     * Para actualizar una anotación, se debe incluir en la lista de anotaciones
     * de folio un objeto anotación con el idAnotacion seteado, no se debe
     * setear el toDelete. Los datos básicos que se quieren actualizar deben ser
     * seteados en el objeto anotación.
     *
     * Los ciudadanos pueden ser añadidos de la misma manera en que se agregan
     * cuando se inserta una anotación. También pueden ser eliminados seteando
     * en la AnotacionCiudadano el rol, la propiedad toDelete a true, y el
     * objeto ciudadano con el idCiudadano seteado.
     *
     * Las salvedades pueden ser añadidas de la misma manera en que se agregan
     * cuando se inserta una anotación. También pueden ser eliminados seteando
     * el idSalvedad y la propiedad toDelete a true. Las salvedades pueden ser
     * actualizadas seteando el idSalvedad y seteando la nueva descripción.
     *
     * Las cancelaciones pueden ser añadidas de la misma manera en que se
     * agregan cuando se inserta una anotación. También pueden ser eliminadas
     * seteando el flag toDelete de la cancelación en true y asociando la
     * anotación cancelada con su respectivo idAnotacion
     *
     * 4. Actualizar anotaciones definitivas (Correccion)
     *
     * Una anotación definitiva puede ser actualizada. Se pueden actualizar
     * datos básicos como: comentario, especificación, orden, naturaleza
     * jurídica y estado. Se pueden eliminar y añadir ciudadanos de la
     * anotación, eliminar, actualizar y añadir salvedades.
     *
     * Para actualizar una anotación definitiva, se debe incluir en la lista de
     * anotaciones de folio un objeto anotación con el idAnotacion seteado. Los
     * datos básicos que se quieren actualizar deben ser seteados en el objeto
     * anotación.
     *
     * Los ciudadanos pueden ser añadidos de la misma manera en que se agregan
     * cuando se inserta una anotación. También pueden ser eliminados seteando
     * en la AnotacionCiudadano el rol, la propiedad toDelete a true, y el
     * objeto ciudadano con el idCiudadano seteado.
     *
     * Las salvedades pueden ser añadidas de la misma manera en que se agregan
     * cuando se inserta una anotación. También pueden ser eliminados seteando
     * el idSalvedad y la propiedad toDelete a true. Las salvedades pueden ser
     * actualizadas seteando el idSalvedad y seteando la nueva descripción.
     *
     * Cada vez que se actualice una anotación definitiva se guarda el registro
     * de su estado actual creando una nueva anotación y dejándola con estado
     * "OBSOLETA", esta anotacion no podrá ser accedida desde la aplicación,
     * estará guardada en la base de datos para propósitos de auditoría.
     *
     *
     * @param folio
     * @param usuario
     * @return
     * @throws DAOException
     */
    public boolean updateFolio(Folio datos, Usuario usuario, TurnoPk tid, boolean validarTurno)
            throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        boolean rta = false;

        FolioEnhanced folio;
        UsuarioEnhanced us;

        try {
            TurnoEnhanced turno = null;

            if (validarTurno) {
                if (tid != null) {
                    //Validamos que el turno exista:
                    TurnoEnhancedPk tenh = new TurnoEnhancedPk(tid);

                    turno = this.getTurnoByID(tenh, pm);

                    if (turno == null) {
                        throw new DAOException("El turno especificado no existe");
                    }
                }
            } else {
                if (tid != null) {
                    //Validamos que el turno exista:
                    TurnoEnhancedPk tenh = new TurnoEnhancedPk(tid);

                    turno = this.getTurnoByID(tenh, pm);
                }
            }

            pm.currentTransaction().setOptimistic(false);
            pm.currentTransaction().begin();

            //Obtenemos el folio persistente
            FolioEnhancedPk fid = new FolioEnhancedPk();
            fid.idMatricula = datos.getIdMatricula();

            folio = this.getFolioByID(fid, pm);

            if (folio == null) {
                throw new DAOException("El folio no existe");
            }

            /**
             * @author : Henry Gómez Rocha
             * @change : Permite validar si el usuario actual es en realidad
             * quien tiene el bloqueo del folio. Caso Mantis : 0004967
             */
            if (validarTurno) {
                this.validarBloqueoFolio(folio, usuario, pm);
            }

            //Se llama al método protegido que actualiza el folio
            //dados los datos
            UsuarioEnhancedPk uid = new UsuarioEnhancedPk();
            uid.idUsuario = usuario.getIdUsuario();

            us = this.getUsuarioByID(uid, pm);

            if (us == null) {
                throw new DAOException("El usuario especificado no existe: "
                        + uid.idUsuario);
            }
            tipoCambio = datos.getTipoCambio();/* Caso Mantis: 7275 Autor: Ellery Robles Funcion: Permite identificar si el cambio de la anotacion es de tipo individual o multiple*/

            boolean generarHistoria = false;
            if (folio.getHectareas() != null && folio.getMetros() != null && folio.getCentimetros() != null
                    && datos.getHectareas() != null && datos.getMetros() != null && datos.getCentimetros() != null) {

                if (!folio.getHectareas().equals(datos.getHectareas()) || !folio.getMetros().equals(datos.getMetros())
                        || !folio.getCentimetros().equals(datos.getCentimetros())) {
                    generarHistoria = true;
                }

            }

            if (datos.getNupre() != null && !datos.getNupre().isEmpty()) {
                folio.setNupre(datos.getNupre());
            }

            if (datos.getDeterminaInm() != null && !datos.getDeterminaInm().isEmpty()) {
                folio.setDeterminaInm(datos.getDeterminaInm());
            }

            if (datos.getCoeficiente() != null && !datos.getCoeficiente().isEmpty()) {
                folio.setCoeficiente(datos.getCoeficiente());
            }

            if (datos.getPrivMetros() != null && !datos.getPrivMetros().isEmpty()) {
                folio.setPrivMetros(datos.getPrivMetros());
            }

            if (datos.getPrivCentimetros() != null && !datos.getPrivCentimetros().isEmpty()) {
                folio.setPrivCentimetros(datos.getPrivCentimetros());
            }

            if (datos.getConsMetros() != null && !datos.getConsMetros().isEmpty()) {
                folio.setConsMetros(datos.getConsMetros());
            }

            if (datos.getConsCentimetros() != null && !datos.getConsCentimetros().isEmpty()) {
                folio.setConsCentimetros(datos.getConsCentimetros());
            }

            if (datos.getHectareas() != null && !datos.getHectareas().isEmpty()) {
                if (folio.getHectareas() != null) {
                    if (!folio.getHectareas().equals(datos.getHectareas())) {
                        generarHistoria = true;
                    }
                } else {
                    generarHistoria = true;
                }
                folio.setHectareas(datos.getHectareas());

            }

            if (datos.getMetros() != null && !datos.getMetros().isEmpty()) {
                if (folio.getMetros() != null) {
                    if (!folio.getMetros().equals(datos.getMetros())) {
                        generarHistoria = true;
                    }
                } else {
                    generarHistoria = true;
                }
                folio.setMetros(datos.getMetros());
            }

            if (datos.getCentimetros() != null && !datos.getCentimetros().isEmpty()) {
                if (folio.getCentimetros() != null) {
                    if (!folio.getCentimetros().equals(datos.getCentimetros())) {
                        generarHistoria = true;
                    }
                } else {
                    generarHistoria = true;
                }
                folio.setCentimetros(datos.getCentimetros());
            }

            if (datos.getLinderosDef() != null && !datos.getLinderosDef().isEmpty()) {
                folio.setLinderosDef(datos.getLinderosDef());
            }

            if (generarHistoria) {
                this.setHistorialAreaByEnhanced(folio, pm, usuario.getUsername());
            }

            if (datos.getIdMatricula() != null) {
                if (!this.existeFolioTMP(datos.getIdMatricula())) {
                    this.setFolioTMPVacio(datos.getIdMatricula(), pm);
                }
            }

            this.updateFolio(folio, datos, us, turno, validarTurno, pm);

            pm.currentTransaction().commit();
            rta = true;
        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (DAOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            throw e;
        } catch (Throwable e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        return rta;
    }

    public boolean updateFolioFD(Folio datos, Usuario usuario, TurnoPk tid, boolean validarTurno, List lstAnotaFolioHijo, List lstAnotaFolioPadre, String anotacionUpdate, String matriculaUpdate, List lstHijosRemove)
            throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        boolean rta = false;

        FolioEnhanced folio;
        UsuarioEnhanced us;

        try {
            TurnoEnhanced turno = null;

            if (validarTurno) {
                if (tid != null) {
                    //Validamos que el turno exista:
                    TurnoEnhancedPk tenh = new TurnoEnhancedPk(tid);

                    turno = this.getTurnoByID(tenh, pm);

                    if (turno == null) {
                        throw new DAOException("El turno especificado no existe");
                    }
                }
            } else {
                if (tid != null) {
                    //Validamos que el turno exista:
                    TurnoEnhancedPk tenh = new TurnoEnhancedPk(tid);

                    turno = this.getTurnoByID(tenh, pm);
                }
            }

            pm.currentTransaction().setOptimistic(false);
            pm.currentTransaction().begin();

            //Obtenemos el folio persistente
            FolioEnhancedPk fid = new FolioEnhancedPk();
            fid.idMatricula = datos.getIdMatricula();

            folio = this.getFolioByID(fid, pm);

            if (folio == null) {
                throw new DAOException("El folio no existe");
            }

            //Validar bloqueo del folio
            this.validarBloqueoFolio(folio, usuario, pm);

            //Se llama al método protegido que actualiza el folio
            //dados los datos
            UsuarioEnhancedPk uid = new UsuarioEnhancedPk();
            uid.idUsuario = usuario.getIdUsuario();

            us = this.getUsuarioByID(uid, pm);

            if (us == null) {
                throw new DAOException("El usuario especificado no existe: "
                        + uid.idUsuario);
            }

            this.updateFolioFD(folio, datos, us, turno, validarTurno, pm, lstAnotaFolioHijo, lstAnotaFolioPadre, anotacionUpdate, matriculaUpdate, lstHijosRemove);

            pm.currentTransaction().commit();
            rta = true;
        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (DAOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            throw e;
        } catch (Throwable e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        return rta;
    }

    /**
     * Acualiza la información de las matrículas dadas con los datos del folio.
     *
     * @param datos
     * @param ids Listas de objetos tipo Folio.ID
     * @param usuario
     * @return
     * @throws DAOException
     */
    public boolean updateFolios(Folio datos, List ids, Usuario usuario, boolean validarBloqueo)
            throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        JDOGenieFolioDerivadoDAO folioDerivadoDAO = new JDOGenieFolioDerivadoDAO();

        boolean rta = false;
        FolioPk fid;

        FolioEnhanced folio;
        UsuarioEnhanced us;

        try {
            UsuarioEnhancedPk uid = new UsuarioEnhancedPk();
            uid.idUsuario = usuario.getIdUsuario();

            us = this.getUsuarioByID(uid, pm);

            if (us == null) {
                throw new DAOException("El usuario especificado no existe: "
                        + uid.idUsuario);
            }

            //Una vez realizadas las validaciones se inicia la transacción
            pm.currentTransaction().setOptimistic(false);
            pm.currentTransaction().begin();

            Direccion direccion = null;
            Direccion direccionTemp = null;
            String especificacionDireccion = null;

            //se guarda en una variable temporal la dirección que desea agregarse a los folios.
            if (datos.getDirecciones().size() > 0) {
                direccion = (Direccion) datos.getDirecciones().get(0);

                direccionTemp = new Direccion();
                direccionTemp.setEje(direccion.getEje());
                direccionTemp.setEje1(direccion.getEje1());
                direccionTemp.setValorEje(direccion.getValorEje());
                direccionTemp.setValorEje1(direccion.getValorEje1());

                especificacionDireccion = direccion.getEspecificacion();

                datos.removeDireccione(direccion);
            }

            for (Iterator it = ids.iterator(); it.hasNext();) {
                fid = (FolioPk) it.next();
                folio = this.getFolioByID(new FolioEnhancedPk(fid), pm);

                if (direccionTemp != null) {
                    direccionTemp.setEspecificacion(especificacionDireccion);
                }

                if (folio == null) {
                    throw new DAOException("El folio no existe: "
                            + fid.idMatricula);
                }

                if (validarBloqueo) {
                    //Se valida el bloqueo
                    this.validarBloqueoFolio(folio, usuario, pm);
                }

                //Se le coloca al complemento de la dirección el nombre con el que quedo el folio derivado.
                if (direccionTemp != null) {

                    FolioDerivado folioDerivado = null;
                    if (validarBloqueo) {
                        folioDerivado = folioDerivadoDAO.getFolioDerivadoHijoDireccion(fid, usuario);
                    } else {
                        Usuario usuarioVacio = null;
                        folioDerivado = folioDerivadoDAO.getFolioDerivadoHijoDireccion(fid, usuarioVacio);
                    }

                    if (folioDerivado != null && folioDerivado.getLote() != null) {

                        /*No debe concatenar lo que se encuentra en el folio derivado en caso de que sea un englobe*/
                        if (!folio.isDefinitivo() && !(this.getFoliosPadre(fid, null).size() > 1)) {
                            direccionTemp.setEspecificacion(especificacionDireccion + " " + folioDerivado.getLote());
                        }
                    }

                    if (datos.getDirecciones().size() > 0) {
                        while (datos.getDirecciones().size() > 0) {
                            datos.removeDireccione((Direccion) datos.getDirecciones().get(0));
                        }
                    }

                    datos.addDireccione(direccionTemp);
                }

                //Bug 3434 - Al lindero actual se le agrega lo que se ingresa en el formulario
                if (datos.getLindero() != null) {

                    Folio folioTemp = null;
                    if (validarBloqueo) {
                        folioTemp = this.getFolioByID(fid, usuario);
//ok sin anotaciones; sólo se utiliza el lindero
                    } else {
                        folioTemp = this.getFolioByID(fid, null);
                    }

                    if (folioTemp != null && folioTemp.getLindero() != null) {

                        if (datos.getLindero().startsWith(folioTemp.getLindero())) {
                            datos.setLindero(datos.getLindero());
                        } else {
                            datos.setLindero(folioTemp.getLindero() + datos.getLindero());
                        }
                    } else if (folio.getLindero() != null) {
                        datos.setLindero(folio.getLindero() + datos.getLindero());
                    }
                }
                List salvedades = datos.getSalvedades();
                if (salvedades != null) {
                    for (Iterator salveItera = salvedades.iterator();
                            salveItera.hasNext();) {
                        SalvedadFolio salvedad = (SalvedadFolio) salveItera.next();
                        salvedad.setIdMatricula(fid.idMatricula);
                    }
                }

                //Se llama al método protegido que actualiza el folio
                //dados los datos
                this.updateFolio(folio, datos, us, null, false, pm);
            }

            pm.currentTransaction().commit();
            rta = true;
        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (DAOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            throw e;
        } catch (Exception e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        return rta;
    }

    /**
     * Método que actualiza los datos del folio persistente dados los datos
     * enviados en el objeto enhanced (Folio)
     *
     * @param folio
     * @param datos
     * @param pm
     * @return
     * @throws DAOException
     */
    protected boolean updateFolio(FolioEnhanced folio, Folio datos,
            UsuarioEnhanced usuario, TurnoEnhanced turno, boolean validarTurno, PersistenceManager pm)
            throws DAOException {
        JDOGenieCiudadanoDAO ciudDAO = new JDOGenieCiudadanoDAO();
        boolean rta = false;

        try {
            //Se busca en datos los valores a actualizar o añadir en Folio:

            /*
            * @author      :   Henry Gómez Rocha
            * @change      :   Se verifica que las variables tipo string no vengan con cadena vacía.
            * Caso Mantis  :   0004503
             */
            if ((datos.getLindero() != null)
                    || (datos.getCodCatastral() != null && !datos.getCodCatastral().isEmpty())
                    || (datos.getCodCatastralAnterior() != null && !datos.getCodCatastralAnterior().isEmpty())
                    || (datos.getTipoPredio() != null)
                    || (datos.getRadicacion() != null && !datos.getRadicacion().isEmpty())
                    || // bug 03580
                    (datos.getFechaApertura() != null)
                    || // bug 03580
                    (datos.getZonaRegistral() != null)
                    || // bug 03930
                    (datos.getEstado() != null)
                    || (datos.getNupre() != null)
                    || (datos.getDeterminaInm() != null)
                    || (datos.getCoeficiente() != null)
                    || (datos.getPrivMetros() != null)
                    || (datos.getPrivCentimetros() != null)
                    || (datos.getConsMetros() != null)
                    || (datos.getConsCentimetros() != null)
                    || (datos.getHectareas() != null)
                    || (datos.getMetros() != null)
                    || (datos.getCentimetros() != null)) {
                this.updateFolioDatos(folio, datos, turno, validarTurno, pm);
            }
            FolioDatosTMP datosTMP = null;

            try {
                datosTMP = folio.getDatosTMP();
            } catch (JDOObjectNotFoundException e) {
                datosTMP = null;
            }

            //TFS 4559: SI SE VAN A ACTUALIZAR LOS DATOS TEMPORALES DEL FOLIO
            //O REABRIR EL FOLIO, SE ELIMINAN LOS DATOS TEMPORALES
            //SI LOS DATOS DEL FOLIO SON NULOS
            if (datosTMP != null
                    && datosTMP.getFechaApertura() == null
                    && datosTMP.getCodCatastral() == null
                    && datosTMP.getCodCatastralAnterior() == null
                    && datosTMP.getComentarioCambioEstado() == null
                    && datosTMP.getEstado() == null
                    && datosTMP.getFechaApertura() == null
                    && datosTMP.getLindero() == null
                    && datosTMP.getNupre() == null
                    && datosTMP.getDeterminaInm() == null
                    && datosTMP.getPrivMetros() == null
                    && datosTMP.getPrivCentimetros() == null
                    && datosTMP.getConsMetros() == null
                    && datosTMP.getConsCentimetros() == null
                    && datosTMP.getCoeficiente() == null
                    && datosTMP.getHectareas() == null
                    && datosTMP.getMetros() == null
                    && datosTMP.getCentimetros() == null
                    && datosTMP.getNumRadicaCodCatastral() == null
                    && datosTMP.getNumRadicaCodCatastralAnterior() == null
                    && datosTMP.getNumRadicaEstado() == null
                    && datosTMP.getNumRadicaFechaApertura() == null
                    && datosTMP.getNumRadicaLindero() == null
                    && datosTMP.getNumRadicaNupre() == null
                    && datosTMP.getNumRadicaDeterminaInm() == null
                    && datosTMP.getNumRadicaPrivMetros() == null
                    && datosTMP.getNumRadicaPrivCentimetros() == null
                    && datosTMP.getNumRadicaConsMetros() == null
                    && datosTMP.getNumRadicaConsCentimetros() == null
                    && datosTMP.getNumRadicaHectareas() == null
                    && datosTMP.getNumRadicaMetros() == null
                    && datosTMP.getNumRadicaCentimetros() == null
                    && datosTMP.getNumRadicaTipoPredio() == null
                    && datosTMP.getNumRadicaZonaRegistral() == null
                    && datosTMP.getTipoPredio() == null
                    && this.getFolioDatosTMP(new FolioDatosTMPPk(folio.getIdMatricula())) != null) {
                pm.deletePersistent(datosTMP);
                return true;
            }

            //Se busca si se debe actualizar la complementación
            if (datos.getComplementacion() != null) {
                this.updateFolioComplementacion(folio, datos, pm);
            }

            //Se busca si se debe actualizar el documento
            if (datos.getDocumento() != null) {
                if (datos.getDocumento().getCirculo() == null) {
                    datos.getDocumento().setCirculo(folio.getCirculo());
                }
                this.updateFolioDocumento(folio, datos, pm);
            }

            //Se buscan las direcciones a añadir
            if (datos.getDirecciones().size() > 0) {
                this.updateFolioDirecciones(folio, datos, usuario, pm);
            }

            //Se buscan las salvedades a añadir
            if (datos.getSalvedades().size() > 0) {
                this.updateFolioSalvedades(folio, datos, usuario, pm);
            }

            //Se buscan las anotaciones a añadir o actualizar
            if (datos.getAnotaciones().size() > 0) {
                this.updateFolioAnotaciones(folio, datos, usuario, turno, pm);
            }

            /**
             * @author: Cesar Ramirez
             * @change: 1245.HABILITAR.TIPO.PREDIO Se busca si se debe
             * actualizar el tipo predio
             *
             */
            // Se busca si se debe actualizar el tipo predio
            if (datos.getTipoPredio() != null) {
                this.updateTipoPredio(folio, datos, usuario, (turno != null) ? turno.getIdWorkflow() : null, pm);
            }

            rta = true;
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }

        return rta;
    }

    /**
     * Método que actualiza los datos del folio persistente dados los datos
     * enviados en el objeto enhanced (Folio) y los folios derivados de las
     * anotaciones
     *
     * @param folio
     * @param datos
     * @param pm
     * @return
     * @throws DAOException
     */
    protected boolean updateFolioFD(FolioEnhanced folio, Folio datos,
            UsuarioEnhanced usuario, TurnoEnhanced turno, boolean validarTurno, PersistenceManager pm,
            List lstAnotaFolioHijo, List lstAnotaFolioPadre, String AnotacionUpdate, String matriculaUpdate, List lstHijosRemove)
            throws DAOException {
        JDOGenieCiudadanoDAO ciudDAO = new JDOGenieCiudadanoDAO();
        boolean rta = false;

        try {
            //Se busca en datos los valores a actualizar o añadir en Folio:
            if ((datos.getLindero() != null)
                    || (datos.getNupre() != null)
                    || (datos.getDeterminaInm() != null)
                    || (datos.getPrivMetros() != null)
                    || (datos.getPrivCentimetros() != null)
                    || (datos.getConsMetros() != null)
                    || (datos.getConsCentimetros() != null)
                    || (datos.getCoeficiente() != null)
                    || (datos.getHectareas() != null)
                    || (datos.getMetros() != null)
                    || (datos.getCentimetros() != null)
                    || (datos.getCodCatastral() != null)
                    || (datos.getCodCatastralAnterior() != null)
                    || (datos.getTipoPredio() != null)
                    || (datos.getRadicacion() != null)
                    || // bug 03580
                    (datos.getFechaApertura() != null)
                    || // bug 03580
                    (datos.getZonaRegistral() != null)
                    || // bug 03930
                    (datos.getEstado() != null)) {
                this.updateFolioDatos(folio, datos, turno, validarTurno, pm);
            }

            FolioDatosTMP datosTMP = null;

            try {
                datosTMP = folio.getDatosTMP();
            } catch (JDOObjectNotFoundException e) {
                datosTMP = null;
            }

            //TFS 4559: SI SE VAN A ACTUALIZAR LOS DATOS TEMPORALES DEL FOLIO
            //O REABRIR EL FOLIO, SE ELIMINAN LOS DATOS TEMPORALES
            //SI LOS DATOS DEL FOLIO SON NULOS
            if (datosTMP != null
                    && datosTMP.getFechaApertura() == null
                    && datosTMP.getCodCatastral() == null
                    && datosTMP.getCodCatastralAnterior() == null
                    && datosTMP.getComentarioCambioEstado() == null
                    && datosTMP.getEstado() == null
                    && datosTMP.getFechaApertura() == null
                    && datosTMP.getLindero() == null
                    && datosTMP.getNupre() == null
                    && datosTMP.getDeterminaInm() == null
                    && datosTMP.getPrivMetros() == null
                    && datosTMP.getPrivCentimetros() == null
                    && datosTMP.getConsMetros() == null
                    && datosTMP.getConsCentimetros() == null
                    && datosTMP.getCoeficiente() == null
                    && datosTMP.getHectareas() == null
                    && datosTMP.getMetros() == null
                    && datosTMP.getCentimetros() == null
                    && datosTMP.getNumRadicaCodCatastral() == null
                    && datosTMP.getNumRadicaCodCatastralAnterior() == null
                    && datosTMP.getNumRadicaEstado() == null
                    && datosTMP.getNumRadicaFechaApertura() == null
                    && datosTMP.getNumRadicaLindero() == null
                    && datosTMP.getNumRadicaTipoPredio() == null
                    && datosTMP.getNumRadicaZonaRegistral() == null
                    && datosTMP.getTipoPredio() == null
                    && this.getFolioDatosTMP(new FolioDatosTMPPk(folio.getIdMatricula())) != null) {
                pm.deletePersistent(datosTMP);
                return true;
            }

            //Se busca si se debe actualizar la complementación
            if (datos.getComplementacion() != null) {
                this.updateFolioComplementacion(folio, datos, pm);
            }

            //Se busca si se debe actualizar el documento
            if (datos.getDocumento() != null) {
                if (datos.getDocumento().getCirculo() == null) {
                    datos.getDocumento().setCirculo(folio.getCirculo());
                }
                this.updateFolioDocumento(folio, datos, pm);
            }

            //Se buscan las direcciones a añadir
            if (datos.getDirecciones().size() > 0) {
                this.updateFolioDirecciones(folio, datos, usuario, pm);
            }

            //Se buscan las salvedades a añadir
            if (datos.getSalvedades().size() > 0) {
                this.updateFolioSalvedades(folio, datos, usuario, pm);
            }

//          Se buscan las anotaciones a añadir o actualizar
            if (datos.getAnotaciones().size() > 0) {
                //this.updateFolioAnotacionesFD(folio, datos, usuario, turno, pm);
                this.updateFolioAnotaciones(folio, datos, usuario, turno, pm);
            }

            if (lstAnotaFolioHijo.size() == 0 && lstAnotaFolioHijo.size() == 0
                    && matriculaUpdate == null && (lstHijosRemove == null || lstHijosRemove.isEmpty())) {
                List lstAnota = datos.getAnotaciones();
                Iterator iterAnota = lstAnota.iterator();
                while (iterAnota.hasNext()) {
                    Anotacion anota = (Anotacion) iterAnota.next();
                    if (anota.getAnotacionesHijos() != null) {

                        //makeTransientAnotacionTMP(new AnotacionTMP(anota), pm, new ArrayList());
                        List lstAnotaHijos = anota.getAnotacionesHijos();
                        Iterator iterAnotaHijos = lstAnotaHijos.iterator();
                        while (iterAnotaHijos.hasNext()) {
                            FolioDerivado folioDeriveHijo = (FolioDerivado) iterAnotaHijos.next();

                            AnotacionPk anotaPk = new AnotacionPk();
                            anotaPk.idAnotacion = folioDeriveHijo.getIdAnotacion1();
                            anotaPk.idMatricula = folioDeriveHijo.getIdMatricula1();
                            Anotacion anotacionSir = this.getAnotacion(anotaPk);
                            AnotacionTMP anotaTMP = new AnotacionTMP(anotacionSir, new ArrayList());

                            //SE AGREGA LA NATURALEZA ENJANCED
                            NaturalezaJuridicaEnhancedPk njId = new NaturalezaJuridicaEnhancedPk();
                            njId.idNaturalezaJuridica = anotacionSir.getNaturalezaJuridica()
                                    .getIdNaturalezaJuridica();

                            NaturalezaJuridicaEnhanced naturaleza = this.getNaturalezaJuridica(njId,
                                    pm);
                            // validacion para el usuario
                            if (naturaleza.getUsuario() != null) {
                                naturaleza.setUsuario(usuario);
                            }
                            anotaTMP.setNaturalezaJuridica(naturaleza);

                            // se agragan los estados
                            EstadoAnotacionEnhancedPk estaAnotaPk = new EstadoAnotacionEnhancedPk();
                            estaAnotaPk.idEstadoAn = anotacionSir.getEstado().getIdEstadoAn();
                            EstadoAnotacionEnhanced estadoAnotaE = this.getEstadoAnotacion(estaAnotaPk, pm);
                            anotaTMP.setEstado(estadoAnotaE);

                            // se agragan los estados
                            TipoAnotacionEnhancedPk tipoAnotaPk = new TipoAnotacionEnhancedPk();
                            tipoAnotaPk.idTipoAnotacion = anotacionSir.getTipoAnotacion().getIdTipoAnotacion();
                            TipoAnotacionEnhanced tipoAnotaE = this.getTipoAnotacion(tipoAnotaPk, pm);
                            anotaTMP.setTipoAnotacion(tipoAnotaE);

                            // 	se agragan el tipo documento
                            DocumentoEnhancedPk documentoPk = new DocumentoEnhancedPk();
                            documentoPk.idDocumento = anotacionSir.getDocumento().getIdDocumento();
                            DocumentoEnhanced documentoE = this.getDocumento(documentoPk, pm);
                            anotaTMP.setDocumento(documentoE);

                            anotaTMP.setDatosAntiguoSistema(null);
//	        	        	la validacion del usuario para que despues no coloque problema
                            if (anotaTMP.getSalvedadesTMPs() != null && !anotaTMP.getSalvedadesTMPs().isEmpty()) {
                                Iterator iteraSavedades = anotaTMP.getSalvedadesTMPs().iterator();
                                while (iteraSavedades.hasNext()) {
                                    SalvedadAnotacionTMP salvedadAnotacionTMP = (SalvedadAnotacionTMP) iteraSavedades.next();
                                    if (salvedadAnotacionTMP != null && salvedadAnotacionTMP.getUsuario() != null) {
                                        salvedadAnotacionTMP.setUsuario(usuario);
                                    }
                                }
                            }
                            pm.makePersistent(anotaTMP);
                            pm.makePersistent(new FolioDerivadoTMP(folioDeriveHijo));
                        }
                    }
                    if (anota.getAnotacionesPadre() != null) {

                        //makeTransientAnotacionTMP(new AnotacionTMP(anota), pm, new ArrayList());
                        List lstAnotaPadre = anota.getAnotacionesPadre();
                        Iterator iterAnotaPadre = lstAnotaPadre.iterator();
                        while (iterAnotaPadre.hasNext()) {
                            FolioDerivado folioDerivePadre = (FolioDerivado) iterAnotaPadre.next();

                            AnotacionPk anotaPk = new AnotacionPk();
                            anotaPk.idAnotacion = folioDerivePadre.getIdAnotacion();
                            anotaPk.idMatricula = folioDerivePadre.getIdMatricula();
                            Anotacion anotacionSir = this.getAnotacionById(anotaPk);

                            //            			SE AGREGA LA NATURALEZA ENJANCED
                            NaturalezaJuridicaEnhancedPk njId = new NaturalezaJuridicaEnhancedPk();
                            njId.idNaturalezaJuridica = anotacionSir.getNaturalezaJuridica()
                                    .getIdNaturalezaJuridica();

                            NaturalezaJuridicaEnhanced naturaleza = this.getNaturalezaJuridica(njId,
                                    pm);
                            AnotacionTMP anotaTMP = new AnotacionTMP(anotacionSir, new ArrayList());
//	        	            validacion para el usuario
                            if (naturaleza.getUsuario() != null) {
                                naturaleza.setUsuario(usuario);
                            }
                            anotaTMP.setNaturalezaJuridica(naturaleza);

                            // se agragan los estados
                            EstadoAnotacionEnhancedPk estaAnotaPk = new EstadoAnotacionEnhancedPk();
                            estaAnotaPk.idEstadoAn = anotacionSir.getEstado().getIdEstadoAn();
                            EstadoAnotacionEnhanced estadoAnotaE = this.getEstadoAnotacion(estaAnotaPk, pm);
                            anotaTMP.setEstado(estadoAnotaE);

                            // se agragan los estados
                            TipoAnotacionEnhancedPk tipoAnotaPk = new TipoAnotacionEnhancedPk();
                            tipoAnotaPk.idTipoAnotacion = anotacionSir.getTipoAnotacion().getIdTipoAnotacion();
                            TipoAnotacionEnhanced tipoAnotaE = this.getTipoAnotacion(tipoAnotaPk, pm);
                            anotaTMP.setTipoAnotacion(tipoAnotaE);

                            // 	se agragan el tipo documento
                            DocumentoEnhancedPk documentoPk = new DocumentoEnhancedPk();
                            documentoPk.idDocumento = anotacionSir.getDocumento().getIdDocumento();
                            DocumentoEnhanced documentoE = this.getDocumento(documentoPk, pm);
                            anotaTMP.setDocumento(documentoE);

                            anotaTMP.setDatosAntiguoSistema(null);
//	        	        	la validacion del usuario para que despues no coloque problema
                            if (anotaTMP.getSalvedadesTMPs() != null && !anotaTMP.getSalvedadesTMPs().isEmpty()) {
                                Iterator iteraSavedades = anotaTMP.getSalvedadesTMPs().iterator();
                                while (iteraSavedades.hasNext()) {
                                    SalvedadAnotacionTMP salvedadAnotacionTMP = (SalvedadAnotacionTMP) iteraSavedades.next();
                                    if (salvedadAnotacionTMP != null && salvedadAnotacionTMP.getUsuario() != null) {
                                        salvedadAnotacionTMP.setUsuario(usuario);
                                    }
                                }
                            }
                            pm.makePersistent(anotaTMP);
                            pm.makePersistent(new FolioDerivadoTMP(folioDerivePadre));

                        }
                    }
                }
            } else if (lstHijosRemove == null || lstHijosRemove.isEmpty()) {

                List lstAnota = datos.getAnotaciones();
                Iterator iterAnota = lstAnota.iterator();
                while (iterAnota.hasNext()) {

                    Anotacion anota = (Anotacion) iterAnota.next();

                    AnotacionTMPPk anotacionTMPPk = new AnotacionTMPPk();
                    anotacionTMPPk.idAnotacionTmp = anota.getIdAnotacion();
                    anotacionTMPPk.idMatricula = matriculaUpdate;
                    //Anotacion anotacionSir = this.getAnotacion(anotaPk);
                    AnotacionTMP anotacionTMP = this.getAnotacionTMPByID(anotacionTMPPk, pm);
                    List listaAnotaHijos = anotacionTMP.getAnotacionesHijosTMPs();
                    if (matriculaUpdate != null && AnotacionUpdate != null
                            && anota.getIdAnotacion().equals(AnotacionUpdate)) {

                        if (listaAnotaHijos != null && listaAnotaHijos.size() > 0) {
                            // borrar persistencia y volver a agregar datos temporales
                            Iterator iterAnotaLst = listaAnotaHijos.iterator();
                            List lstAnotaB = new ArrayList();
                            List lstFolioDeriveB = new ArrayList();
                            while (iterAnotaLst.hasNext()) {
                                FolioDerivadoTMP folioDeriveHijoB = (FolioDerivadoTMP) iterAnotaLst.next();
                                /*pm.deletePersistent(folioDeriveHijoB);*/

                                lstFolioDeriveB.add(folioDeriveHijoB);
                                AnotacionTMPPk anotacionTMPPkFD = new AnotacionTMPPk();
                                anotacionTMPPkFD.idAnotacionTmp = folioDeriveHijoB.getIdAnotacion1Tmp();
                                anotacionTMPPkFD.idMatricula = folioDeriveHijoB.getIdMatricula1();
                                AnotacionTMP anotacionTMPFD = this.getAnotacionTMPByIDSinAnotaFolio(anotacionTMPPkFD, pm);
                                lstAnotaB.add(anotacionTMPFD);
                                /*pm.deletePersistent(anotacionTMPFD);*/

                            }
                            if (lstFolioDeriveB.size() > 0) {
                                pm.deletePersistentAll(lstFolioDeriveB);
                                pm.deletePersistentAll(lstAnotaB);
                                VersantPersistenceManager pm2 = (VersantPersistenceManager) pm;
                                pm2.flush();
                            }

                        }
                        Iterator iterAnotaHijoAuxIn = lstAnotaFolioHijo.iterator();
                        while (iterAnotaHijoAuxIn.hasNext()) {
                            FolioDerivado folioDeriveHijoIn = (FolioDerivado) iterAnotaHijoAuxIn.next();

                            AnotacionPk anotaPk = new AnotacionPk();
                            anotaPk.idAnotacion = folioDeriveHijoIn.getIdAnotacion1();
                            anotaPk.idMatricula = folioDeriveHijoIn.getIdMatricula1();
                            //Anotacion anotacionSir = this.getAnotacion(anotaPk);
                            Anotacion anotacionSir = this.getAnotacionByID(anotaPk);
                            AnotacionTMP anotaTMP = new AnotacionTMP(anotacionSir, new ArrayList());

                            //SE AGREGA LA NATURALEZA ENJANCED
                            NaturalezaJuridicaEnhancedPk njId = new NaturalezaJuridicaEnhancedPk();
                            njId.idNaturalezaJuridica = anotacionSir.getNaturalezaJuridica()
                                    .getIdNaturalezaJuridica();

                            NaturalezaJuridicaEnhanced naturaleza = this.getNaturalezaJuridica(njId,
                                    pm);
                            //validacion para el usuario
                            if (naturaleza.getUsuario() != null) {
                                naturaleza.setUsuario(usuario);
                            }
                            anotaTMP.setNaturalezaJuridica(naturaleza);

                            // se agragan los estados
                            EstadoAnotacionEnhancedPk estaAnotaPk = new EstadoAnotacionEnhancedPk();
                            estaAnotaPk.idEstadoAn = anotacionSir.getEstado().getIdEstadoAn();
                            EstadoAnotacionEnhanced estadoAnotaE = this.getEstadoAnotacion(estaAnotaPk, pm);
                            anotaTMP.setEstado(estadoAnotaE);

                            // se agragan los estados
                            TipoAnotacionEnhancedPk tipoAnotaPk = new TipoAnotacionEnhancedPk();
                            tipoAnotaPk.idTipoAnotacion = anotacionSir.getTipoAnotacion().getIdTipoAnotacion();
                            TipoAnotacionEnhanced tipoAnotaE = this.getTipoAnotacion(tipoAnotaPk, pm);
                            anotaTMP.setTipoAnotacion(tipoAnotaE);

                            // 	se agragan el tipo documento
                            DocumentoEnhancedPk documentoPk = new DocumentoEnhancedPk();
                            documentoPk.idDocumento = anotacionSir.getDocumento().getIdDocumento();
                            DocumentoEnhanced documentoE = this.getDocumento(documentoPk, pm);
                            anotaTMP.setDocumento(documentoE);

                            anotaTMP.setDatosAntiguoSistema(null);
                            //la validacion del usuario para que despues no coloque problema
                            if (anotaTMP.getSalvedadesTMPs() != null && !anotaTMP.getSalvedadesTMPs().isEmpty()) {
                                Iterator iteraSavedades = anotaTMP.getSalvedadesTMPs().iterator();
                                while (iteraSavedades.hasNext()) {
                                    SalvedadAnotacionTMP salvedadAnotacionTMP = (SalvedadAnotacionTMP) iteraSavedades.next();
                                    if (salvedadAnotacionTMP != null && salvedadAnotacionTMP.getUsuario() != null) {
                                        salvedadAnotacionTMP.setUsuario(usuario);
                                    }
                                }
                            }

                            pm.makePersistent(anotaTMP);

                            pm.makePersistent(new FolioDerivadoTMP(folioDeriveHijoIn));

                        }
                    }

                    List listaAnotaPadre = anotacionTMP.getAnotacionesPadreTMPs();
                    if (matriculaUpdate != null && AnotacionUpdate != null
                            && anota.getIdAnotacion().equals(AnotacionUpdate)) {

                        if (listaAnotaPadre != null && listaAnotaPadre.size() > 0) {
                            // borrar persistencia y volver a agregar datos temporales
                            Iterator iterAnotaLst = listaAnotaPadre.iterator();
                            List lstAnotaB = new ArrayList();
                            List lstFolioDeriveB = new ArrayList();
                            while (iterAnotaLst.hasNext()) {
                                FolioDerivadoTMP folioDerivePadreB = (FolioDerivadoTMP) iterAnotaLst.next();
                                lstFolioDeriveB.add(folioDerivePadreB);

                                AnotacionTMPPk anotacionTMPPkFD = new AnotacionTMPPk();
                                anotacionTMPPkFD.idAnotacionTmp = folioDerivePadreB.getIdAnotacionTmp();
                                anotacionTMPPkFD.idMatricula = folioDerivePadreB.getIdMatricula();
                                AnotacionTMP anotacionTMPFD = this.getAnotacionTMPByIDSinAnotaFolio(anotacionTMPPkFD, pm);

                                /*pm.deletePersistent(anotacionTMPFD);*/
                                lstAnotaB.add(anotacionTMPFD);

                            }
                            if (lstFolioDeriveB.size() > 0) {
                                pm.deletePersistentAll(lstFolioDeriveB);
                                pm.deletePersistentAll(lstAnotaB);
                                VersantPersistenceManager pm2 = (VersantPersistenceManager) pm;
                                pm2.flush();
                            }

                        }
                        Iterator iterAnotaPadreAuxIn = lstAnotaFolioPadre.iterator();
                        while (iterAnotaPadreAuxIn.hasNext()) {
                            FolioDerivado folioDerivePadreIn = (FolioDerivado) iterAnotaPadreAuxIn.next();

                            AnotacionPk anotaPk = new AnotacionPk();
                            anotaPk.idAnotacion = folioDerivePadreIn.getIdAnotacion();
                            anotaPk.idMatricula = folioDerivePadreIn.getIdMatricula();
                            //Anotacion anotacionSir = this.getAnotacion(anotaPk);
                            Anotacion anotacionSir = this.getAnotacionByID(anotaPk);
                            AnotacionTMP anotaTMP = new AnotacionTMP(anotacionSir, new ArrayList());

                            //SE AGREGA LA NATURALEZA ENJANCED
                            NaturalezaJuridicaEnhancedPk njId = new NaturalezaJuridicaEnhancedPk();
                            njId.idNaturalezaJuridica = anotacionSir.getNaturalezaJuridica()
                                    .getIdNaturalezaJuridica();

                            NaturalezaJuridicaEnhanced naturaleza = this.getNaturalezaJuridica(njId,
                                    pm);
//	        	          	validacion para el usuario
                            if (naturaleza.getUsuario() != null) {
                                naturaleza.setUsuario(usuario);
                            }
                            anotaTMP.setNaturalezaJuridica(naturaleza);

                            // se agragan los estados
                            EstadoAnotacionEnhancedPk estaAnotaPk = new EstadoAnotacionEnhancedPk();
                            estaAnotaPk.idEstadoAn = anotacionSir.getEstado().getIdEstadoAn();
                            EstadoAnotacionEnhanced estadoAnotaE = this.getEstadoAnotacion(estaAnotaPk, pm);
                            anotaTMP.setEstado(estadoAnotaE);

                            // se agragan los estados
                            TipoAnotacionEnhancedPk tipoAnotaPk = new TipoAnotacionEnhancedPk();
                            tipoAnotaPk.idTipoAnotacion = anotacionSir.getTipoAnotacion().getIdTipoAnotacion();
                            TipoAnotacionEnhanced tipoAnotaE = this.getTipoAnotacion(tipoAnotaPk, pm);
                            anotaTMP.setTipoAnotacion(tipoAnotaE);

                            // 	se agragan el tipo documento
                            DocumentoEnhancedPk documentoPk = new DocumentoEnhancedPk();
                            documentoPk.idDocumento = anotacionSir.getDocumento().getIdDocumento();
                            DocumentoEnhanced documentoE = this.getDocumento(documentoPk, pm);
                            anotaTMP.setDocumento(documentoE);

                            anotaTMP.setDatosAntiguoSistema(null);
                            //	la validacion del usuario para que despues no coloque problema
                            if (anotaTMP.getSalvedadesTMPs() != null && !anotaTMP.getSalvedadesTMPs().isEmpty()) {
                                Iterator iteraSavedades = anotaTMP.getSalvedadesTMPs().iterator();
                                while (iteraSavedades.hasNext()) {
                                    SalvedadAnotacionTMP salvedadAnotacionTMP = (SalvedadAnotacionTMP) iteraSavedades.next();
                                    if (salvedadAnotacionTMP != null && salvedadAnotacionTMP.getUsuario() != null) {
                                        salvedadAnotacionTMP.setUsuario(usuario);
                                    }
                                }
                            }
                            pm.makePersistent(anotaTMP);

                            pm.makePersistent(new FolioDerivadoTMP(folioDerivePadreIn));

                        }
                    }
                }
            }

            ///esto es un comentario
            if (lstHijosRemove != null && !lstHijosRemove.isEmpty()) {
                Iterator iteraHijoRemove = lstHijosRemove.iterator();
                while (iteraHijoRemove.hasNext()) {
                    FolioDerivado flioFD = (FolioDerivado) iteraHijoRemove.next();
                    FolioDerivadoTMP flioFDB = this.getFoliosDerivadosTMPByMatriculaPadre(flioFD.getIdMatricula(), flioFD.getIdMatricula1(), pm);
                    if (flioFD != null && flioFD.getIdAnotacion1() != null && flioFD.getIdMatricula1() != null) {
                        AnotacionTMPPk anotaTmpPk = new AnotacionTMPPk();
                        anotaTmpPk.idAnotacionTmp = flioFD.getIdAnotacion1();
                        anotaTmpPk.idMatricula = flioFD.getIdMatricula1();
                        AnotacionTMP anotaTmp = this.getAnotacionTMPByID(anotaTmpPk, pm);
                        if (flioFDB != null) {
                            pm.deletePersistent(flioFDB);
                        }
                        pm.deletePersistent(anotaTmp);
                        //VersantPersistenceManager pm2 = (VersantPersistenceManager) pm;
                        //pm2.flush();
                    }

                }

            }

            rta = true;
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }

        return rta;
    }
    
    public List getTurnsShareFolioNotaDev(String idMatricula) throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        List turnos = new ArrayList();
        Connection connection = null;
        PreparedStatement ps = null;
        ResultSet rs = null;

        VersantPersistenceManager jdoPM = null;

        String consulta = " SELECT TRNO_ID_WORKFLOW FROM SIR_OP_TURNO T "
        + " INNER JOIN SIR_OP_SOLICITUD_FOLIO S ON T.ID_SOLICITUD = S.ID_SOLICITUD "
        + " WHERE S.ID_MATRICULA = '"+idMatricula+"'AND T.TRNO_ID_FASE IN ('NOT_NOTA_NOTIFICADA','NOT_NOTA_DEVOLUTIVA','NOT_RECURSOS_NOTA')";
        try {

            jdoPM = (VersantPersistenceManager) AdministradorPM.getPM();

            jdoPM.currentTransaction().begin();

            connection = jdoPM.getJdbcConnection(null);
            ps = connection.prepareStatement(consulta);

            rs = ps.executeQuery();

            while (rs.next()) {
                turnos.add(rs.getString(1));
            }

            jdoPM.currentTransaction().commit();

        } catch (SQLException e) {
            if (jdoPM.currentTransaction().isActive()) {
                jdoPM.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        } catch (JDOObjectNotFoundException e) {
            if (jdoPM.currentTransaction().isActive()) {
                jdoPM.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        } catch (JDOException e) {
            if (jdoPM.currentTransaction().isActive()) {
                jdoPM.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        } catch (Throwable e) {
            if (jdoPM.currentTransaction().isActive()) {
                jdoPM.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        } finally {
            try {
                if (rs != null) {
                    rs.close();
                }
                if (ps != null) {
                    ps.close();
                }
                if (connection != null) {
                    connection.close();
                }

                if (jdoPM != null) {
                    jdoPM.close();
                }

            } catch (SQLException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e);
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
                throw new DAOException(e.getMessage(), e);
            }
        }
        return turnos;
    }
    
    
    public List validarPrincipioPrioridadNotNotaDev(String idMatricula) throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        List turnos = new ArrayList();
        Connection connection = null;
        PreparedStatement ps = null;
        ResultSet rs = null;

        VersantPersistenceManager jdoPM = null;

        String consulta = " SELECT TRNO_ID_WORKFLOW FROM SIR_OP_TURNO T "
        + " INNER JOIN SIR_OP_SOLICITUD_FOLIO S ON T.ID_SOLICITUD = S.ID_SOLICITUD "
        + " WHERE S.ID_MATRICULA = '"+idMatricula+"'AND T.TRNO_ID_FASE IN ('NOT_NOTA_DEVOLUTIVA')"
        + " ORDER BY T.TRNO_FECHA_CREACION DESC";
        try {

            jdoPM = (VersantPersistenceManager) AdministradorPM.getPM();

            jdoPM.currentTransaction().begin();

            connection = jdoPM.getJdbcConnection(null);
            ps = connection.prepareStatement(consulta);

            rs = ps.executeQuery();

            while (rs.next()) {
                turnos.add(rs.getString(1));
            }

            jdoPM.currentTransaction().commit();

        } catch (SQLException e) {
            if (jdoPM.currentTransaction().isActive()) {
                jdoPM.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        } catch (JDOObjectNotFoundException e) {
            if (jdoPM.currentTransaction().isActive()) {
                jdoPM.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        } catch (JDOException e) {
            if (jdoPM.currentTransaction().isActive()) {
                jdoPM.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        } catch (Throwable e) {
            if (jdoPM.currentTransaction().isActive()) {
                jdoPM.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        } finally {
            try {
                if (rs != null) {
                    rs.close();
                }
                if (ps != null) {
                    ps.close();
                }
                if (connection != null) {
                    connection.close();
                }

                if (jdoPM != null) {
                    jdoPM.close();
                }

            } catch (SQLException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e);
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
                throw new DAOException(e.getMessage(), e);
            }
        }
        return turnos;
    }
    
    public List validarPrincipioPrioridadNotNotaNot(String idMatricula) throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        List turnos = new ArrayList();
        Connection connection = null;
        PreparedStatement ps = null;
        ResultSet rs = null;

        VersantPersistenceManager jdoPM = null;

        String consulta = " SELECT TRNO_ID_WORKFLOW FROM SIR_OP_TURNO T "
        + " INNER JOIN SIR_OP_SOLICITUD_FOLIO S ON T.ID_SOLICITUD = S.ID_SOLICITUD "
        + " WHERE S.ID_MATRICULA = '"+idMatricula+"'AND T.TRNO_ID_FASE IN ('NOT_NOTA_NOTIFICADA')"
        + " ORDER BY T.TRNO_FECHA_CREACION";
        try {

            jdoPM = (VersantPersistenceManager) AdministradorPM.getPM();

            jdoPM.currentTransaction().begin();

            connection = jdoPM.getJdbcConnection(null);
            ps = connection.prepareStatement(consulta);

            rs = ps.executeQuery();

            while (rs.next()) {
                turnos.add(rs.getString(1));
            }

            jdoPM.currentTransaction().commit();

        } catch (SQLException e) {
            if (jdoPM.currentTransaction().isActive()) {
                jdoPM.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        } catch (JDOObjectNotFoundException e) {
            if (jdoPM.currentTransaction().isActive()) {
                jdoPM.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        } catch (JDOException e) {
            if (jdoPM.currentTransaction().isActive()) {
                jdoPM.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        } catch (Throwable e) {
            if (jdoPM.currentTransaction().isActive()) {
                jdoPM.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        } finally {
            try {
                if (rs != null) {
                    rs.close();
                }
                if (ps != null) {
                    ps.close();
                }
                if (connection != null) {
                    connection.close();
                }

                if (jdoPM != null) {
                    jdoPM.close();
                }

            } catch (SQLException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e);
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
                throw new DAOException(e.getMessage(), e);
            }
        }
        return turnos;
    }
    
    public List validarPrincipioPrioridadRecNot(String idMatricula) throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        List turnos = new ArrayList();
        Connection connection = null;
        PreparedStatement ps = null;
        ResultSet rs = null;

        VersantPersistenceManager jdoPM = null;

        String consulta = " SELECT TRNO_ID_WORKFLOW FROM SIR_OP_TURNO T "
        + " INNER JOIN SIR_OP_SOLICITUD_FOLIO S ON T.ID_SOLICITUD = S.ID_SOLICITUD "
        + " WHERE S.ID_MATRICULA = '"+idMatricula+"'AND T.TRNO_ID_FASE IN ('NOT_RECURSOS_NOTA')"
        + " ORDER BY T.TRNO_FECHA_CREACION";
        try {

            jdoPM = (VersantPersistenceManager) AdministradorPM.getPM();

            jdoPM.currentTransaction().begin();

            connection = jdoPM.getJdbcConnection(null);
            ps = connection.prepareStatement(consulta);

            rs = ps.executeQuery();

            while (rs.next()) {
                turnos.add(rs.getString(1));
            }

            jdoPM.currentTransaction().commit();

        } catch (SQLException e) {
            if (jdoPM.currentTransaction().isActive()) {
                jdoPM.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        } catch (JDOObjectNotFoundException e) {
            if (jdoPM.currentTransaction().isActive()) {
                jdoPM.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        } catch (JDOException e) {
            if (jdoPM.currentTransaction().isActive()) {
                jdoPM.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        } catch (Throwable e) {
            if (jdoPM.currentTransaction().isActive()) {
                jdoPM.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        } finally {
            try {
                if (rs != null) {
                    rs.close();
                }
                if (ps != null) {
                    ps.close();
                }
                if (connection != null) {
                    connection.close();
                }

                if (jdoPM != null) {
                    jdoPM.close();
                }

            } catch (SQLException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e);
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
                throw new DAOException(e.getMessage(), e);
            }
        }
        return turnos;
    }

    public List getHistorialArea(String idMatricula) throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        List historialA = new ArrayList();
        Connection connection = null;
        PreparedStatement ps = null;
        ResultSet rs = null;

        VersantPersistenceManager jdoPM = null;

        String consulta = "SELECT * FROM (SELECT HTRL_HECTAREAS, HTRL_METROS, HTRL_CENTIMETROS, HTRL_FECHA_ACTUALIZACION FROM SIR_NE_HISTORIAL_AREAS "
                + " WHERE ID_MATRICULA = '" + idMatricula + "' AND UPD_ID_HISTORIAL IS NULL"
                + " ORDER BY HTRL_FECHA_ACTUALIZACION DESC) "
                + " WHERE ROWNUM <= 3";
        try {

            jdoPM = (VersantPersistenceManager) AdministradorPM.getPM();

            jdoPM.currentTransaction().begin();

            connection = jdoPM.getJdbcConnection(null);
            ps = connection.prepareStatement(consulta);

            rs = ps.executeQuery();

            while (rs.next()) {
                HistorialAreas htrl = new HistorialAreas();

                htrl.setHectareas(rs.getString(1));
                htrl.setMetros(rs.getString(2));
                htrl.setCentimetros(rs.getString(3));
                htrl.setFechaActualizacion(rs.getDate(4));
                historialA.add(htrl);
            }

            jdoPM.currentTransaction().commit();

        } catch (SQLException e) {
            if (jdoPM.currentTransaction().isActive()) {
                jdoPM.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        } catch (JDOObjectNotFoundException e) {
            if (jdoPM.currentTransaction().isActive()) {
                jdoPM.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        } catch (JDOException e) {
            if (jdoPM.currentTransaction().isActive()) {
                jdoPM.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        } catch (Throwable e) {
            if (jdoPM.currentTransaction().isActive()) {
                jdoPM.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        } finally {
            try {
                if (rs != null) {
                    rs.close();
                }
                if (ps != null) {
                    ps.close();
                }
                if (connection != null) {
                    connection.close();
                }

                if (jdoPM != null) {
                    jdoPM.close();
                }

            } catch (SQLException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e);
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
                throw new DAOException(e.getMessage(), e);
            }
        }
        return historialA;
    }

    public void setHistorialAreaByEnhanced(FolioEnhanced folio, PersistenceManager pm, String usuario) throws DAOException {
        VersantPersistenceManager jdoPM = (VersantPersistenceManager) pm;
        Connection connection = null;
        connection = jdoPM.getJdbcConnection(null);

        String idMatricula = folio.getIdMatricula();
        String hectareas = folio.getHectareas();
        String metros = folio.getMetros();
        String centimetros = folio.getCentimetros();
        String sql = "INSERT INTO SIR_NE_HISTORIAL_AREAS (ID_MATRICULA,HTRL_HECTAREAS,HTRL_METROS,HTRL_CENTIMETROS,HTRL_FECHA_ACTUALIZACION,USUARIO_ID,HTRL_ACCION) "
                + " VALUES('" + idMatricula + "','" + hectareas + "','" + metros + "','" + centimetros + "',SYSDATE,'"+ usuario+ "','INSERT')";

        Statement s = null;
        try {
            s = connection.createStatement();
            s.executeUpdate(sql);
        } catch (SQLException e) {
            throw new DAOException("Error SQL: " + e, e);
        } finally {

            try {
                if (s != null) {
                    s.close();
                }
                if (connection != null) {
                    connection.close();
                }
            } catch (SQLException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e);
            }

        }
    }

    public void setHistorialArea(Folio folio, PersistenceManager pm) throws DAOException {
        VersantPersistenceManager jdoPM = (VersantPersistenceManager) pm;
        Connection connection = null;
        connection = jdoPM.getJdbcConnection(null);

        String idMatricula = folio.getIdMatricula();
        String hectareas = folio.getHectareas();
        String metros = folio.getMetros();
        String centimetros = folio.getCentimetros();
        String sql = "INSERT INTO SIR_NE_HISTORIAL_AREAS (ID_MATRICULA,HTRL_HECTAREAS,HTRL_METROS,HTRL_CENTIMETROS,HTRL_FECHA_ACTUALIZACION) "
                + " VALUES('" + idMatricula + "','" + hectareas + "','" + metros + "','" + centimetros + "',SYSDATE)";

        Statement s = null;
        try {
            s = connection.createStatement();
            s.executeUpdate(sql);
        } catch (SQLException e) {
            throw new DAOException("Error SQL: " + e, e);
        } finally {

            try {
                if (s != null) {
                    s.close();
                }
                if (connection != null) {
                    connection.close();
                }
            } catch (SQLException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e);
            }

        }
    }

    public void setFolioTMPVacio(String idMatricula, PersistenceManager pm) throws DAOException {
        VersantPersistenceManager jdoPM = (VersantPersistenceManager) pm;
        Connection connection = null;
        connection = jdoPM.getJdbcConnection(null);

        String sql = "INSERT INTO SIR_NE_FOLIO_DATOS_TMP (ID_MATRICULA) "
                + " VALUES('" + idMatricula + "')";

        Statement s = null;
        try {
            s = connection.createStatement();
            s.executeUpdate(sql);
        } catch (SQLException e) {
            throw new DAOException("Error SQL: " + e, e);
        } finally {

            try {
                if (s != null) {
                    s.close();
                }
                if (connection != null) {
                    connection.close();
                }
            } catch (SQLException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e);
            }

        }
    }

    public boolean existeFolioTMP(String idMatricula) throws DAOException {

        PersistenceManager pm = AdministradorPM.getPM();
        boolean existe = false;
        Connection connection = null;
        PreparedStatement ps = null;
        ResultSet rs = null;

        VersantPersistenceManager jdoPM = null;

        String consulta = "SELECT * FROM SIR_NE_FOLIO_DATOS_TMP "
                + " WHERE ID_MATRICULA = '" + idMatricula + "'";
        try {

            jdoPM = (VersantPersistenceManager) AdministradorPM.getPM();

            jdoPM.currentTransaction().begin();

            connection = jdoPM.getJdbcConnection(null);
            ps = connection.prepareStatement(consulta);

            rs = ps.executeQuery();

            if (rs.next()) {
                existe = true;
            }

            jdoPM.currentTransaction().commit();

            return existe;

        } catch (SQLException e) {
            if (jdoPM.currentTransaction().isActive()) {
                jdoPM.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        } catch (JDOObjectNotFoundException e) {
            if (jdoPM.currentTransaction().isActive()) {
                jdoPM.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        } catch (JDOException e) {
            if (jdoPM.currentTransaction().isActive()) {
                jdoPM.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        } catch (Throwable e) {
            if (jdoPM.currentTransaction().isActive()) {
                jdoPM.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        } finally {
            try {
                if (rs != null) {
                    rs.close();
                }
                if (ps != null) {
                    ps.close();
                }
                if (connection != null) {
                    connection.close();
                }

                if (jdoPM != null) {
                    jdoPM.close();
                }

            } catch (SQLException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e);
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
                throw new DAOException(e.getMessage(), e);
            }
        }
    }

    /**
     * Actualiza los datos del folio a nivel temporal
     *
     * @param folio Objeto persistente
     * @param datos datos a actualizar
     * @return
     * @throws DAOException
     */
    protected boolean updateFolioDatos(FolioEnhanced folio, Folio datos,
            TurnoEnhanced turno, boolean validarTurno,
            PersistenceManager pm) throws DAOException {
        boolean rta = false;

        try {
            // Se valida si ya se tiene un FolioDatosTMP asociado al folio
            FolioDatosTMP folioTMP;

            try {
                folioTMP = folio.getDatosTMP();
            } catch (JDOObjectNotFoundException e) {
                folioTMP = null;
            }

            //Se crea o se actualiza según lo encontrado
            if (folioTMP == null) {

                folioTMP = new FolioDatosTMP(datos);
                folioTMP.setIdMatricula(folio.getIdMatricula());
                folio.setDatosTMP(folioTMP);

                if (folioTMP.getNupre() != null) {
                    if (validarTurno) {
                        folioTMP.setNumRadicaNupre(turno.getIdWorkflow());
                    }
                }

                if (folioTMP.getDeterminaInm() != null) {
                    if (validarTurno) {
                        folioTMP.setNumRadicaDeterminaInm(turno.getIdWorkflow());
                    }
                }

                if (folioTMP.getPrivMetros() != null) {
                    if (validarTurno) {
                        folioTMP.setNumRadicaPrivMetros(turno.getIdWorkflow());
                    }
                }

                if (folioTMP.getPrivCentimetros() != null) {
                    if (validarTurno) {
                        folioTMP.setNumRadicaPrivCentimetros(turno.getIdWorkflow());
                    }
                }

                if (folioTMP.getConsMetros() != null) {
                    if (validarTurno) {
                        folioTMP.setNumRadicaConsMetros(turno.getIdWorkflow());
                    }
                }

                if (folioTMP.getConsCentimetros() != null) {
                    if (validarTurno) {
                        folioTMP.setNumRadicaConsCentimetros(turno.getIdWorkflow());
                    }
                }

                if (folioTMP.getCoeficiente() != null) {
                    if (validarTurno) {
                        folioTMP.setNumRadicaCoeficiente(turno.getIdWorkflow());
                    }
                }

                if (folioTMP.getHectareas() != null) {
                    if (validarTurno) {
                        folioTMP.setNumRadicaHectareas(turno.getIdWorkflow());
                    }
                }

                if (folioTMP.getMetros() != null) {
                    if (validarTurno) {
                        folioTMP.setNumRadicaMetros(turno.getIdWorkflow());
                    }
                }

                if (folioTMP.getCentimetros() != null) {
                    if (validarTurno) {
                        folioTMP.setNumRadicaCentimetros(turno.getIdWorkflow());
                    }
                }

                if (folioTMP.getLindero() != null) {
                    if (validarTurno) {
                        folioTMP.setNumRadicaLindero(turno.getIdWorkflow());
                    }
                }

                if (folioTMP.getCodCatastral() != null) {
                    if (validarTurno) {
                        folioTMP.setNumRadicaCodCatastral(turno.getIdWorkflow());
                    }
                }

                if (folioTMP.getCodCatastralAnterior() != null) {
                    if (validarTurno) {
                        folioTMP.setNumRadicaCodCatastralAnterior(turno.getIdWorkflow());
                    }
                }

                // bug 3580
                if (folioTMP.getRadicacion() != null) {
                    if (validarTurno) {
                        folioTMP.setNumRadicaRadicacion(turno.getIdWorkflow());
                    }
                }
                if (folioTMP.getFechaApertura() != null) {
                    if (validarTurno) {
                        folioTMP.setNumRadicaFechaApertura(turno.getIdWorkflow());
                    }
                }
            } else {
                if (datos.getNupre() != null) {
                    folioTMP.setNupre(datos.getNupre());
                    if (validarTurno) {
                        folioTMP.setNumRadicaNupre(turno.getIdWorkflow());
                    }
                }

                if (datos.getDeterminaInm() != null) {
                    folioTMP.setDeterminaInm(datos.getDeterminaInm());
                    if (validarTurno) {
                        folioTMP.setNumRadicaDeterminaInm(turno.getIdWorkflow());
                    }
                }

                if (datos.getPrivMetros() != null) {
                    folioTMP.setPrivMetros(datos.getPrivMetros());
                    if (validarTurno) {
                        folioTMP.setNumRadicaPrivMetros(turno.getIdWorkflow());
                    }
                }

                if (datos.getPrivCentimetros() != null) {
                    folioTMP.setPrivCentimetros(datos.getPrivCentimetros());
                    if (validarTurno) {
                        folioTMP.setNumRadicaPrivCentimetros(turno.getIdWorkflow());
                    }
                }

                if (datos.getConsMetros() != null) {
                    folioTMP.setConsMetros(datos.getConsMetros());
                    if (validarTurno) {
                        folioTMP.setNumRadicaConsMetros(turno.getIdWorkflow());
                    }
                }

                if (datos.getConsCentimetros() != null) {
                    folioTMP.setConsCentimetros(datos.getConsCentimetros());
                    if (validarTurno) {
                        folioTMP.setNumRadicaConsCentimetros(turno.getIdWorkflow());
                    }
                }

                if (datos.getCoeficiente() != null) {
                    folioTMP.setCoeficiente(datos.getCoeficiente());
                    if (validarTurno) {
                        folioTMP.setNumRadicaCoeficiente(turno.getIdWorkflow());
                    }
                }

                if (datos.getHectareas() != null) {
                    folioTMP.setHectareas(datos.getHectareas());
                    if (validarTurno) {
                        folioTMP.setNumRadicaHectareas(turno.getIdWorkflow());
                    }
                }

                if (datos.getMetros() != null) {
                    folioTMP.setMetros(datos.getMetros());
                    if (validarTurno) {
                        folioTMP.setNumRadicaMetros(turno.getIdWorkflow());
                    }
                }

                if (datos.getCentimetros() != null) {
                    folioTMP.setCentimetros(datos.getCentimetros());
                    if (validarTurno) {
                        folioTMP.setNumRadicaCentimetros(turno.getIdWorkflow());
                    }
                }

                if (datos.getLindero() != null) {
                    folioTMP.setLindero(datos.getLindero());
                    if (validarTurno) {
                        folioTMP.setNumRadicaLindero(turno.getIdWorkflow());
                    }
                }

                if (datos.getCodCatastral() != null) {
                    folioTMP.setCodCatastral(datos.getCodCatastral());
                    if (validarTurno) {
                        folioTMP.setNumRadicaCodCatastral(turno.getIdWorkflow());
                    }
                }

                if (datos.getCodCatastralAnterior() != null) {
                    folioTMP.setCodCatastralAnterior(datos.getCodCatastralAnterior());
                    if (validarTurno) {
                        folioTMP.setNumRadicaCodCatastralAnterior(turno.getIdWorkflow());
                    }
                }

                // bug 3580
                if (datos.getRadicacion() != null) {
                    folioTMP.setRadicacion(datos.getRadicacion());
                    if (validarTurno) {
                        folioTMP.setNumRadicaRadicacion(turno.getIdWorkflow());
                    }
                }
                if (datos.getFechaApertura() != null) {
                    folioTMP.setFechaApertura(datos.getFechaApertura());
                    if (validarTurno) {
                        folioTMP.setNumRadicaFechaApertura(turno.getIdWorkflow());
                    }
                }
            }

            //Se validan y se asocian los objetos
            if (datos.getZonaRegistral() != null) {
                ZonaRegistralEnhanced zr;
                JDOGenieZonaRegistralDAO zonaRegistralDAO = new JDOGenieZonaRegistralDAO();
                //Se valida y asocia la zona registral, si existe un ID de zona
                //registral se busca por el id, en caso que no exista se busca
                //la zona registral por el círculo y la vereda
                if (datos.getZonaRegistral().getIdZonaRegistral() != null) {
                    ZonaRegistralEnhancedPk zrId = new ZonaRegistralEnhancedPk();
                    zrId.idZonaRegistral = datos.getZonaRegistral()
                            .getIdZonaRegistral();
                    zr = zonaRegistralDAO.getZonaRegistral(zrId, pm);

                    if (zr == null) {
                        throw new DAOException(
                                "No encontró la zona registral con el ID: "
                                + zrId.idZonaRegistral);
                    }
                } else {
                    VeredaEnhanced verEnh = VeredaEnhanced.enhance(datos.getZonaRegistral().getVereda());
                    Vereda vereda = datos.getZonaRegistral().getVereda();
                    verEnh.setIdDepartamento(vereda.getIdDepartamento());
                    verEnh.setIdMunicipio(vereda.getIdMunicipio());
                    verEnh.setIdVereda(vereda.getIdVereda());
                    zr = zonaRegistralDAO.getZonaRegistralByCirculoVereda(folio.getZonaRegistral().getCirculo(), verEnh, pm);

                    if (zr == null) {
                        throw new DAOException(
                                "No encontró la zona registral del circulo y vereda especificados");
                    }
                }
                folioTMP.setZonaRegistral(zr);
                if (validarTurno) {
                    folioTMP.setNumRadicaZonaRegistral(turno.getIdWorkflow());
                }
            }

            if (datos.getEstado() != null) {
                //Se valida que el estado que llega sea diferente al actual
                if (!folio.getEstado().getIdEstado().equals(datos.getEstado().getIdEstado())) {
                    //Se valida y asocia el estado:
                    EstadoFolioEnhanced estado = EstadoFolioEnhanced.enhance(datos.getEstado());

                    //Se valida que el cambio de estado tenga un comentario:
                    String comentario = estado.getComentario();
                    if (comentario == null) {
                        throw new DAOException("Debe tener un comentario si se desea cambiar el estado del folio");
                    }

                    EstadoFolioEnhancedPk eid = new EstadoFolioEnhancedPk();
                    eid.idEstado = estado.getIdEstado();
                    estado = this.getEstadoFolio(eid, pm);

                    if (estado == null) {
                        throw new DAOException("El estado especificado no existe: "
                                + eid.idEstado);
                    }

                    folioTMP.setEstado(estado);
                    folioTMP.setComentarioCambioEstado(comentario);
                    if (validarTurno) {
                        folioTMP.setNumRadicaEstado(turno.getIdWorkflow());
                    }
                } else {
                    folioTMP.setEstado(null);
                    folioTMP.setComentarioCambioEstado(null);
                    folioTMP.setNumRadicaEstado(null);
                }
            }

            if (datos.getTipoPredio() != null) {
                //Se valida y asocia el tipo de predio
                TipoPredioEnhanced tipo = TipoPredioEnhanced.enhance(datos.getTipoPredio());
                TipoPredioEnhancedPk tid = new TipoPredioEnhancedPk();
                tid.idPredio = tipo.getIdPredio();
                tipo = this.getTipoPredio(tid, pm);

                if (tipo == null) {
                    throw new DAOException(
                            "El tipo de predio especificado no existe: "
                            + tid.idPredio);
                }

                folioTMP.setTipoPredio(tipo);
                if (validarTurno) {
                    folioTMP.setNumRadicaTipoPredio(turno.getIdWorkflow());
                }
            }

            rta = true;
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }

        return rta;
    }

    /**
     *
     * @param folio
     * @return
     * @throws DAOException
     */
    public FolioDatosTMP getFolioDatosTMP(FolioDatosTMPPk oid) throws DAOException {
        FolioDatosTMP rta = null;
        PersistenceManager pm = AdministradorPM.getPM();

        if ((oid.idMatricula != null)) {
            try {
                rta = (FolioDatosTMP) pm.getObjectById(oid, true);
                pm.makeTransient(rta.getEstado());
            } catch (JDOObjectNotFoundException e) {
                rta = null;
            } catch (JDOException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                throw new DAOException(e.getMessage(), e);
            }
        }

        return rta;
    }

    /**
     *
     * @param folio
     * @param datos
     * @param pm
     * @return
     * @throws DAOException
     */
    protected boolean updateFolioDirecciones(FolioEnhanced folio, Folio datos,
            UsuarioEnhanced usuario, PersistenceManager pm)
            throws DAOException {
        boolean rta = false;

        try {
            List direcciones = datos.getDirecciones();
            DireccionTMP direccion;

            for (Iterator itr = direcciones.iterator(); itr.hasNext();) {
                Direccion dirAux = (Direccion) itr.next();
                direccion = new DireccionTMP(dirAux);
                direccion.setOrden(dirAux.getOrden());
                //Se revisa si la dirección se tiene que insertar o se tiene que eliminar
                if (direccion.getIdDireccionTmp() != null) {
                    //La dirección se tiene que eliminar si el flag toDelete está en true

                    //Se valida que la dirección que se está intentando borrar exista:
                    DireccionEnhancedPk dirID = new DireccionEnhancedPk();
                    dirID.idMatricula = folio.getIdMatricula();
                    dirID.idDireccion = direccion.getIdDireccionTmp();

                    DireccionEnhanced dirToDel = this.getDireccion(dirID, pm);

                    if (dirToDel != null) {
                        if (direccion.isToDelete()) {
                            //Se valida si ya existe una dirección que esté eliminando a la dirección
                            //definitiva:
                            DireccionTMPPk dirTMPID = new DireccionTMPPk();
                            dirTMPID.idDireccionTmp = direccion.getIdDireccionTmp();
                            dirTMPID.idMatricula = folio.getIdMatricula();

                            DireccionTMP dirTMPToVal = this.getDireccionTMP(dirTMPID, pm);

                            if (dirTMPToVal != null) {
                                if (dirTMPToVal.isToDelete()) {
                                    throw new DAOException("La dirección que se quiere eliminar NO existe");
                                }
                            }
                            //La dirección temporal se inserta indicando que se debe eliminar cuando se haga definitivo
                            this.addDireccionTMPToFolio(folio, direccion, usuario, pm);
                            pm.makePersistent(direccion);
                        }
                    } else {
                        //Se busca entre las anotaciones temporales
                        DireccionTMPPk dirTMPID = new DireccionTMPPk();
                        dirTMPID.idDireccionTmp = direccion.getIdDireccionTmp();
                        dirTMPID.idMatricula = folio.getIdMatricula();

                        DireccionTMP dirTMPToDel = this.getDireccionTMP(dirTMPID, pm);

                        if (dirTMPToDel == null) {
                            throw new DAOException("No se encontró la dirección que se quiere actualizar");
                        }

                        if (direccion.isToDelete()) {
                            //Se mira si la dirección ya está configurada para eliminarla
                            if (dirTMPToDel.isToDelete()) {
                                throw new DAOException("La dirección que se quiere eliminar NO existe");
                            }
                            pm.deletePersistent(dirTMPToDel);
                        }
                    }

                } else {
                    //La dirección se inserta
                    this.addDireccionTMPToFolio(folio, direccion, usuario, pm);
                    pm.makePersistent(direccion);
                }

            }

            rta = true;
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }

        return rta;
    }

    /**
     * Actualiza las salvedades del folio. Por cada salvedad si existe, la
     * actualiza, de lo contrario la inserta
     *
     * @param folio
     * @param usuario
     * @return
     * @throws DAOException
     */
    public boolean updateFolioSalvedades(Folio folio, Usuario usuario) throws DAOException {
        boolean rta = false;
        PersistenceManager pm = AdministradorPM.getPM();
        pm.currentTransaction().begin();
        UsuarioEnhanced us;

        try {

            //Se llama al método protegido que actualiza el folio
            //dados los datos
            UsuarioEnhancedPk uid = new UsuarioEnhancedPk();
            uid.idUsuario = usuario.getIdUsuario();

            uid.idUsuario = usuario.getIdUsuario();

            us = this.getUsuarioByID(uid, pm);

            if (us == null) {
                throw new DAOException("El usuario especificado no existe: "
                        + uid.idUsuario);
            }

            if ((folio.getIdMatricula() != null)) {
                FolioEnhancedPk oid = new FolioEnhancedPk();
                oid.idMatricula = folio.getIdMatricula();
                FolioEnhanced folioEn = this.getFolioByID(oid, pm);
                if (folio.getSalvedades() != null && !folio.getSalvedades().isEmpty()) {
                    rta = this.updateFolioSalvedades(folioEn, folio, us, pm);
                    pm.currentTransaction().commit();
                }
            }
        } catch (DAOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            throw e;
        } catch (Exception e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            pm.close();
        }

        return rta;
    }

    /**
     *
     * @param folio
     * @param datos
     * @param pm
     * @return
     * @throws DAOException
     */
    protected boolean updateFolioSalvedades(FolioEnhanced folio, Folio datos,
            UsuarioEnhanced usuario, PersistenceManager pm)
            throws DAOException {
        boolean rta = false;

        try {
            List salvedades = datos.getSalvedades();
            SalvedadFolioTMP salvedad;

            for (Iterator itr = salvedades.iterator(); itr.hasNext();) {

                // se revisa si la salvedad en los objetos planos tiene
                // su id;
                salvedad = new SalvedadFolioTMP((SalvedadFolio) itr.next());

                // Bug 5160
                SalvedadFolioTMP salvedadTemporal = null;
                SalvedadFolioTMPPk salvedadTemporalId;
                salvedadTemporalId = new SalvedadFolioTMPPk();

                salvedadTemporalId.idMatricula = salvedad.getIdMatricula();
                salvedadTemporalId.idSalvedadFoTmp = salvedad.getIdSalvedadFoTmp();

                if (salvedadTemporalId.idMatricula != null && salvedadTemporalId.idSalvedadFoTmp != null) {
                    salvedadTemporal = (SalvedadFolioTMP) getSalvedadFolioTMP(salvedadTemporalId, pm);
                } else if (salvedad.getNumRadicacion() != null) {
                    List salvedadesTmpAux = folio.getSalvedadesTMPs();
                    if (salvedadesTmpAux != null) {

                    }
                }

                // si no existe la salvedad se adiciona
                if (null == salvedadTemporal) {
                    this.addSalvedadTMPToFolio(folio, salvedad, usuario, pm);
                    pm.makePersistent(salvedad);
                } else {
                    this.updateSalvedadTMPToFolio(folio, salvedad, usuario, pm);
                }

            }

            rta = true;
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }

        return rta;
    }

    /**
     *
     * @param folio
     * @param datos
     * @param pm
     * @return
     * @throws DAOException
     */
    protected boolean updateFolioSalvedadesCreacionDirecta(FolioEnhanced folio, Folio datos,
            UsuarioEnhanced usuario, PersistenceManager pm)
            throws DAOException {
        boolean rta = false;

        try {
            List salvedades = datos.getSalvedades();
            SalvedadFolioTMP salvedad;

            pm.deletePersistentAll(folio.getSalvedadesTMPs());

            for (Iterator itr = salvedades.iterator(); itr.hasNext();) {

                // se revisa si la salvedad en los objetos planos tiene
                // su id;
                salvedad = new SalvedadFolioTMP((SalvedadFolio) itr.next());

                // Bug 5160
                SalvedadFolioTMP salvedadTemporal;
                SalvedadFolioTMPPk salvedadTemporalId;
                salvedadTemporalId = new SalvedadFolioTMPPk();

                salvedadTemporalId.idMatricula = salvedad.getIdMatricula();
                salvedadTemporalId.idSalvedadFoTmp = salvedad.getIdSalvedadFoTmp();

                //salvedadTemporal = (SalvedadFolioTMP)getSalvedadFolioTMP( salvedadTemporalId, pm );
                // si no existe la salvedad se adiciona
                //if( null == salvedadTemporal ) {
                this.addSalvedadTMPToFolio(folio, salvedad, usuario, pm);
                pm.makePersistent(salvedad);
                //}
                //else {
                //  this.updateSalvedadTMPToFolio(folio, salvedad, usuario, pm);
                //}

            }

            rta = true;
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }

        return rta;
    }

    /**
     *
     * @param folio
     * @param datos
     * @param pm
     * @return
     * @throws DAOException
     */
    protected boolean updateFolioComplementacion(FolioEnhanced folio,
            Folio datos, PersistenceManager pm) throws DAOException {
        boolean rta = false;

        try {
            Complementacion com = datos.getComplementacion();

            // Se valida si ya se tiene una ComplementacionTMP asociado al folio
            ComplementacionTMP complementacion = folio.getComplementacionTMP();

            //Si no existe se crea
            if (complementacion == null) {
                //Se obtiene la complementacion actual
                ComplementacionEnhanced aux = folio.getComplementacion();

                //Si existe una complementación actual
                //se revisa si ya existe un registro temporal
                //para la misma complementacion
                if (aux != null) {
                    ComplementacionTMPPk auxId = new ComplementacionTMPPk();
                    auxId.idComplementacionTmp = aux.getIdComplementacion();

                    ComplementacionTMP auxTMP = this.getComplementacionTMP(auxId,
                            pm);

                    //Si existe una complementación temporal actual
                    //asociada modificamos su registro
                    // El folio tiene complementacion defitiva, pero esta complementación
                    // tiene cambios temporales
                    if (auxTMP != null) {
                        //TODO HACER LO DEL NUMERO DE FOLIOS ASOCIADOS A LA COMPLEMENTACION
                        //TEMPORAL
                        auxTMP.setComplementacion(com.getComplementacion());
                        folio.setComplementacionTMP(auxTMP);
                    } else {
                        com.setIdComplementacion(aux.getIdComplementacion());
                        complementacion = new ComplementacionTMP(com);
                        pm.makePersistent(complementacion);
                        folio.setComplementacionTMP(complementacion);
                    }
                } //Si no existe una complementación actual ni temporale se debe asignar un ID de la secuencia de complementaciones
                //definitivas
                else {
                    //SI SE QUIERE ASOCIAR A UNA COMPLEMENTACIÓN EXISTENTE
                    //SE INTENTA ENCONTRAR PARA ASOCIARLA.
                    if (datos.getComplementacion().getIdComplementacion() != null) {
                        ComplementacionTMPPk comTMPID = new ComplementacionTMPPk();
                        comTMPID.idComplementacionTmp = datos.getComplementacion().getIdComplementacion();

                        ComplementacionTMP complementacionTMP = this.getComplementacionTMP(comTMPID, pm);

                        if (complementacionTMP != null) {
                            folio.setComplementacionTMP(complementacionTMP);
                        } else {
                            ComplementacionEnhancedPk comID = new ComplementacionEnhancedPk();
                            comID.idComplementacion = datos.getComplementacion().getIdComplementacion();

                            ComplementacionEnhanced complementacionDef = this.getComplementacion(comID, pm);
                            if (complementacionDef == null) {
                                throw new DAOException("No se encontró la complementación a asociar con ID: " + comID.idComplementacion);
                            }
                            ComplementacionTMP complementacionTMPToInsert = new ComplementacionTMP(complementacionDef);
                            pm.makePersistent(complementacionTMPToInsert);
                            folio.setComplementacionTMP(complementacionTMPToInsert);
                        }

                    } else {
                        //SI SE QUIERE CREAR UNA NUEVA COMPLEMENTACIÓN
                        com.setIdComplementacion(String.valueOf(this.getSecuencial(CComplementacion.TABLE_NAME, null)));
                        complementacion = new ComplementacionTMP(com);
                        pm.makePersistent(complementacion);
                        folio.setComplementacionTMP(complementacion);
                    }

                }
            } //Si tiene una complementación asociada símplemente se actualiza
            else {
                complementacion.setComplementacion(com.getComplementacion());
            }

            rta = true;
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }

        return rta;
    }

    /**
     *
     * @param anota
     * @param datos
     * @param pm
     * @return
     * @throws DAOException
     */
    protected boolean addSalvedadTMPToFolio(FolioEnhanced folio,
            SalvedadFolioTMP datos, UsuarioEnhanced usuario, PersistenceManager pm)
            throws DAOException {
        boolean rta = false;

        try {
            //Se setea el usuario creador
            datos.setUsuario(usuario);

            datos.setIdSalvedadFoTmp(String.valueOf(folio.getLastIdSalvedadTMP()
                    + 1));
            folio.setLastIdSalvedadTMP(folio.getLastIdSalvedadTMP() + 1);
            datos.setFolio(folio);
            datos.setFechaCreacion(new Date());
            rta = true;
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }

        return rta;
    }

    /**
     *
     * @param anota
     * @param datos
     * @param pm
     * @return
     * @throws DAOException
     */
    protected boolean updateSalvedadTMPToFolio(FolioEnhanced folio,
            SalvedadFolioTMP datos, UsuarioEnhanced usuario, PersistenceManager pm)
            throws DAOException {
        boolean rta = false;

        try {

            // tratar de obtener la salvedad por el identificador
            SalvedadFolioTMPPk salvedadFolioTmp_Id;
            salvedadFolioTmp_Id = new SalvedadFolioTMPPk();

            SalvedadFolioTMP salvedadFolioTmp = null;

            // se asume que los datos de salvedad distintos a salvedad.id
            // se asumen del folio
            salvedadFolioTmp_Id.idMatricula = folio.getIdMatricula();
            salvedadFolioTmp_Id.idSalvedadFoTmp = datos.getIdSalvedadFoTmp();

            salvedadFolioTmp = getSalvedadFolioTMP(salvedadFolioTmp_Id, pm);

            if (salvedadFolioTmp != null) {
                //Se setea el usuario que actualiza
                salvedadFolioTmp.setDescripcion(datos.getDescripcion());
                salvedadFolioTmp.setUsuario(usuario);
            }

            rta = true;
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }

        return rta;
    }

    /**
     * Obtiene una secuencia dado su identificador, método utilizado para
     * transacciones
     *
     * @param sID identificador de la secuencia
     * @param pm PersistenceManager de la transaccion
     * @return Secuencia con sus atributos
     * @throws DAOException
     */
    protected SecuenciasEnhanced getSecuenciaByID(SecuenciasEnhancedPk sID,
            PersistenceManager pm) throws DAOException {
        SecuenciasEnhanced rta = null;

        if (sID.tableName != null) {
            try {
                rta = (SecuenciasEnhanced) pm.getObjectById(sID, true);
            } catch (JDOObjectNotFoundException e) {
                rta = null;
            } catch (JDOException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                throw new DAOException(e.getMessage(), e);
            }
        }

        return rta;
    }

    /**
     *
     * @param oid
     * @param pm
     * @return
     * @throws DAOException
     */
    protected ComplementacionTMP getComplementacionTMP(
            ComplementacionTMPPk oid, PersistenceManager pm)
            throws DAOException {
        ComplementacionTMP rta = null;

        if (oid.idComplementacionTmp != null) {
            try {
                rta = (ComplementacionTMP) pm.getObjectById(oid, true);
            } catch (JDOObjectNotFoundException e) {
                rta = null;
            } catch (JDOException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                throw new DAOException(e.getMessage(), e);
            }
        }

        return rta;
    }

    /**
     *
     * @param folio
     * @param datos
     * @param pm
     * @return
     * @throws DAOException
     */
    protected boolean updateFolioAnotaciones(FolioEnhanced folio, Folio datos,
            UsuarioEnhanced usuario, TurnoEnhanced turno, PersistenceManager pm)
            throws DAOException {
        boolean rta = false;

        try {
            List anotaciones = datos.getAnotaciones();
            AnotacionTMP anotacion;
            /**/
            List anotacionLista = anotaciones;
            Iterator itera = anotacionLista.iterator();
            TipoAnotacionEnhanced tipoAnotacionEnhanced = null;

            for (Iterator itr = anotaciones.iterator(); itr.hasNext();) {

                /**
                 * En caso de que cambie el tipo de Anotacion
                 */
                try {
                    if (itera.hasNext()) {
                        TipoAnotacionEnhancedPk taid = new TipoAnotacionEnhancedPk();
                        taid.idTipoAnotacion = (((Anotacion) itera.next()).getTipoAnotacion()).getIdTipoAnotacion();
                        tipoAnotacionEnhanced = this.getTipoAnotacion(taid, pm);

                    }
                } catch (Exception e) {
                }

                Anotacion anotacionTemp = (Anotacion) itr.next();
                anotacion = new AnotacionTMP(anotacionTemp);
                // se agrega esta linea, ya que, no se estaban borrando las anotaciones
                //temporalorales dado que no existia el id de workflow en el objeto.

                if (turno != null) {
                    anotacion.setIdWorkflow(turno.getIdWorkflow());
                }
                /**
                 * @author: Ellery David Robles Gómez.
                 * @change: Condición que verifica si se encuentra lleno el
                 * documento de la anotacion. Mantis : 08411. Acta :
                 * Requerimiento No 021_151 - Error en anotaciones - ciudadanos.
                 */
                if (anotacion.getDocumento() != null) {
                    if (anotacion.getDocumento().getOficinaOrigen() != null) {
                        try {
                            VeredaEnhanced veredaTemp = anotacion.getDocumento().getOficinaOrigen().getVereda();

                            //Verificar que el id del municipio y departamento no sea nulo
                            if (veredaTemp.getIdMunicipio() == null || veredaTemp.getIdMunicipio().equals("")) {
                                veredaTemp.setIdMunicipio(anotacionTemp.getDocumento().getOficinaOrigen().getVereda().getIdMunicipio());
                                anotacion.getDocumento().getOficinaOrigen().setVereda(veredaTemp);
                            }
                            if (veredaTemp.getIdDepartamento() == null || veredaTemp.getIdDepartamento().equals("")) {
                                veredaTemp.setIdDepartamento(anotacionTemp.getDocumento().getOficinaOrigen().getVereda().getIdDepartamento());
                                anotacion.getDocumento().getOficinaOrigen().setVereda(veredaTemp);
                            }
                        } catch (Exception e) {
                        }
                    }
                }
                //Se revisa si la anotacion tiene llave y en ese caso si existe
                if (anotacion.getIdAnotacionTmp() != null) {
                    //Se desea actualizar o borrar una anotación temporal o definitiva
                    //Se revisa si la anotación que se quiere actualizar es definitiva
                    AnotacionEnhancedPk vid = new AnotacionEnhancedPk();
                    vid.idAnotacion = anotacion.getIdAnotacionTmp();
                    vid.idMatricula = folio.getIdMatricula();

                    AnotacionEnhanced auxAn = this.getAnotacionByID(vid, pm);

                    if (auxAn != null) {
                        /**
                         * Cuando se va a convertir una anotacion en canceladora
                         * se debe cambiar el tipo de anotacion por "2"
                         * (Cancelacion)
                         */
                        if (tipoAnotacionEnhanced != null) {
                            auxAn.setTipoAnotacion(tipoAnotacionEnhanced);
                        }
                        //Se debe actualizar la anotación definitiva
                        // this.actualizarAnotacion(folio, auxAn, anotacion, usuario, true, pm);

                        // :: Bug XXXX: no reordenar
                        if(anotacion.getModalidad() != null){
                            auxAn.setModalidad(anotacion.getModalidad());
                        }
                        
                        this.actualizarAnotacion(folio, auxAn, anotacion, usuario, false, turno, pm);
                    } else {
                        //Se revisa si la anotación que se quiere actualizar es temporal
                        AnotacionTMPPk tid = new AnotacionTMPPk();
                        tid.idAnotacionTmp = anotacion.getIdAnotacionTmp();
                        tid.idMatricula = folio.getIdMatricula();

                        AnotacionTMP auxTMP = this.getAnotacionTMPByID(tid, pm);

                        if (auxTMP != null) {
                            //Se debe actualizar la anotación temporal
                            /**
                             * Cuando se va a convertir una anotacion en
                             * canceladora se debe cambiar el tipo de anotacion
                             * por "2" (Cancelacion)
                             */
                            if (tipoAnotacionEnhanced != null) {
                                auxTMP.setTipoAnotacion(tipoAnotacionEnhanced);
                            }

                            this.actualizarAnotacionTMP(folio, auxTMP,
                                    anotacion, usuario, false, turno, pm);
                        } else {
                            throw new DAOException(
                                    "No se encontró una anotación dentro del folio con el ID: "
                                    + vid.idAnotacion);
                        }
                    }
                } else {
                    //Se le quita el ID para que se asigne un ID automático
                    anotacion.setIdAnotacionTmp(null);
                    anotacion.setFecha(new Date());

                    //Si es una anotación nueva se asigna el orden:
                    anotacion.setOrden(String.valueOf(
                            this.getNextOrdenAnotacion(folio, pm)));

                    this.addAnotacionTMPToFolio(folio, anotacion, usuario, turno, pm);
                    pm.makePersistent(anotacion);
                }
                tipoAnotacionEnhanced = null;
            }

            rta = true;
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }

        return rta;
    }

    /**
     * para grabar los folios derivados
     *
     * @param folio
     * @param datos
     * @param pm
     * @return
     * @throws DAOException
     */
    protected boolean updateFolioAnotacionesFD(FolioEnhanced folio, Folio datos,
            UsuarioEnhanced usuario, TurnoEnhanced turno, PersistenceManager pm)
            throws DAOException {
        boolean rta = false;

        try {
            List anotaciones = datos.getAnotaciones();
            AnotacionTMP anotacion;
            /**/
            List anotacionLista = anotaciones;
            Iterator itera = anotacionLista.iterator();
            TipoAnotacionEnhanced tipoAnotacionEnhanced = null;

            for (Iterator itr = anotaciones.iterator(); itr.hasNext();) {

                /**
                 * En caso de que cambie el tipo de Anotacion
                 */
                try {
                    if (itera.hasNext()) {
                        TipoAnotacionEnhancedPk taid = new TipoAnotacionEnhancedPk();
                        taid.idTipoAnotacion = (((Anotacion) itera.next()).getTipoAnotacion()).getIdTipoAnotacion();
                        tipoAnotacionEnhanced = this.getTipoAnotacion(taid, pm);

                    }
                } catch (Exception e) {
                }

                Anotacion anotacionTemp = (Anotacion) itr.next();
                anotacion = new AnotacionTMP(anotacionTemp, new ArrayList());

                try {
                    VeredaEnhanced veredaTemp = anotacion.getDocumento().getOficinaOrigen().getVereda();

                    //Verificar que el id del municipio y departamento no sea nulo
                    if (veredaTemp.getIdMunicipio() == null || veredaTemp.getIdMunicipio().equals("")) {
                        veredaTemp.setIdMunicipio(anotacionTemp.getDocumento().getOficinaOrigen().getVereda().getIdMunicipio());
                        anotacion.getDocumento().getOficinaOrigen().setVereda(veredaTemp);
                    }
                    if (veredaTemp.getIdDepartamento() == null || veredaTemp.getIdDepartamento().equals("")) {
                        veredaTemp.setIdDepartamento(anotacionTemp.getDocumento().getOficinaOrigen().getVereda().getIdDepartamento());
                        anotacion.getDocumento().getOficinaOrigen().setVereda(veredaTemp);
                    }
                } catch (Exception e) {
                }
                //Se revisa si la anotacion tiene llave y en ese caso si existe
                if (anotacion.getIdAnotacionTmp() != null) {
                    //Se desea actualizar o borrar una anotación temporal o definitiva
                    //Se revisa si la anotación que se quiere actualizar es definitiva
                    AnotacionEnhancedPk vid = new AnotacionEnhancedPk();
                    vid.idAnotacion = anotacion.getIdAnotacionTmp();
                    vid.idMatricula = folio.getIdMatricula();

                    AnotacionEnhanced auxAn = this.getAnotacionByID(vid, pm);

                    if (auxAn != null) {
                        /**
                         * Cuando se va a convertir una anotacion en canceladora
                         * se debe cambiar el tipo de anotacion por "2"
                         * (Cancelacion)
                         */
                        if (tipoAnotacionEnhanced != null) {
                            auxAn.setTipoAnotacion(tipoAnotacionEnhanced);
                        }
                        //Se debe actualizar la anotación definitiva
                        // this.actualizarAnotacion(folio, auxAn, anotacion, usuario, true, pm);

                        // :: Bug XXXX: no reordenar
                        this.actualizarAnotacion(folio, auxAn, anotacion, usuario, false, turno, pm);
                    } else {
                        //Se revisa si la anotación que se quiere actualizar es temporal
                        AnotacionTMPPk tid = new AnotacionTMPPk();
                        tid.idAnotacionTmp = anotacion.getIdAnotacionTmp();
                        tid.idMatricula = folio.getIdMatricula();

                        AnotacionTMP auxTMP = this.getAnotacionTMPByID(tid, pm);

                        if (auxTMP != null) {
                            //Se debe actualizar la anotación temporal
                            /**
                             * Cuando se va a convertir una anotacion en
                             * canceladora se debe cambiar el tipo de anotacion
                             * por "2" (Cancelacion)
                             */
                            if (tipoAnotacionEnhanced != null) {
                                auxTMP.setTipoAnotacion(tipoAnotacionEnhanced);
                            }

                            this.actualizarAnotacionTMP(folio, auxTMP,
                                    anotacion, usuario, false, turno, pm);
                        } else {
                            throw new DAOException(
                                    "No se encontró una anotación dentro del folio con el ID: "
                                    + vid.idAnotacion);
                        }
                    }
                } else {
                    //Se le quita el ID para que se asigne un ID automático
                    anotacion.setIdAnotacionTmp(null);
                    anotacion.setFecha(new Date());

                    //Si es una anotación nueva se asigna el orden:
                    anotacion.setOrden(String.valueOf(
                            this.getNextOrdenAnotacion(folio, pm)));

                    this.addAnotacionTMPToFolio(folio, anotacion, usuario, turno, pm);
                    pm.makePersistent(anotacion);
                }
                tipoAnotacionEnhanced = null;
            }

            rta = true;
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }

        return rta;
    }

    /**
     * @param folio
     * @param anotacion
     * @param pm
     */
    protected boolean validarNaturalezaJuridicaAnotacion(FolioEnhanced fol,
            AnotacionTMP anotacion, PersistenceManager pm)
            throws DAOException {
        boolean rta = true;
        String idDoc = null;

        try {
            //Validación de la existencia del folio
            FolioEnhancedPk vid = new FolioEnhancedPk();
            vid.idMatricula = fol.getIdMatricula();

            fol = this.getFolioByID(vid, pm);

            if (fol != null) {
                if (anotacion.getNaturalezaJuridica() == null) {
                    throw new DAOException(
                            "La anotación NO tiene naturaleza jurídica");
                }

                if (anotacion.getDocumento() != null) {
                    idDoc = anotacion.getDocumento().getIdDocumento();
                }

                //*String obsoleto = CEstadoAnotacion.OBSOLETA;
                String idNatJuridica = anotacion.getNaturalezaJuridica()
                        .getIdNaturalezaJuridica();
                Query query = pm.newQuery(AnotacionTMP.class);

                //El query debe tener en cuenta lo que hay en cache
                query.setIgnoreCache(false);
                query.declareVariables("AnotacionEnhanced anotaDef");
                query.declareParameters(
                        "FolioEnhanced fol, String idNatJuridica, String idDoc, String idAnota");
                //*"FolioEnhanced fol, String idNatJuridica, String obsoleto, String idDoc, String idAnota");
                query.setFilter("this.folio==fol && \n"
                        + "this.naturalezaJuridica.idNaturalezaJuridica==idNatJuridica &&\n"
                        + "this.documento.idDocumento == idDoc &&\n"
                        + //*"this.estado.idEstadoAn != obsoleto &&\n" +
                        "this.idAnotacionTmp != idAnota &&\n"
                        + "!(anotaDef.folio == folio &&\n"
                        + "anotaDef.idAnotacion==this.idAnotacionTmp)");

                Collection col = (Collection) query.executeWithArray(new Object[]{
                    fol, idNatJuridica, idDoc, anotacion.getIdAnotacionTmp()
                //*Collection col = (Collection) query.executeWithArray(new Object[] {
                //*            fol, idNatJuridica, obsoleto, idDoc, anotacion.getIdAnotacionTmp()

                });

                if (col.size() > 0) {
                    rta = false;
                }

                query.closeAll();

                if (rta) {
                    //Se busca ahora entre las anotaciones definitivas, se descarta la validación
                    //en las anotaciones definitivas que se estén actualizando con el delta que se
                    //está insertando
                    query = pm.newQuery(AnotacionEnhanced.class);
                    query.declareParameters(
                            "FolioEnhanced fol, String idNatJuridica, String idDoc, String idAnota");
                    //*"FolioEnhanced fol, String idNatJuridica, String obsoleto, String idDoc, String idAnota");
                    query.setFilter("this.folio==fol && \n"
                            + "this.naturalezaJuridica.idNaturalezaJuridica==idNatJuridica &&\n"
                            + "this.documento.idDocumento == idDoc &&\n"
                            + //*"this.estado.idEstadoAn != obsoleto &&\n" +
                            "this.idAnotacion != idAnota");
                    col = (Collection) query.executeWithArray(new Object[]{
                        fol, idNatJuridica, idDoc, anotacion.getIdAnotacionTmp()
                    //*fol, idNatJuridica, obsoleto, idDoc, anotacion.getIdAnotacionTmp()
                    });

                    if (col.size() > 0) {
                        rta = false;
                    }

                    query.closeAll();
                }
            }
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        }

        return rta;
    }

    /**
     *
     * @param folio
     * @param datos
     * @param pm
     * @return
     * @throws DAOException
     */
    protected boolean addAnotacionTMPToFolio(FolioEnhanced folio,
            AnotacionTMP datos, UsuarioEnhanced usuario, TurnoEnhanced turno, PersistenceManager pm)
            throws DAOException {
        JDOGenieZonaRegistralDAO zonaRegistralDAO = new JDOGenieZonaRegistralDAO();
        boolean rta = false;

        try {
            //Se revisa primero se se debe crear anotaciones canceladas, con
            //el fin de hacerlas persistentes antes de las canceladoras
            for (Iterator itr = datos.getAnotacionesCancelacionTMPs().iterator(); itr.hasNext();) {
                CancelacionTMP cancelacion = (CancelacionTMP) itr.next();
                this.checkCreacionCanceladaAnotacionTMP(folio, datos, cancelacion, usuario, turno,
                        pm);
            }

            //Se valida el estado de la anotacion, si no tiene
            //se pone por defecto Activa
            EstadoAnotacionEnhanced estado;

            if (datos.getEstado() != null) {
                EstadoAnotacionEnhancedPk eId = new EstadoAnotacionEnhancedPk();
                eId.idEstadoAn = datos.getEstado().getIdEstadoAn();

                estado = this.getEstadoAnotacion(eId, pm);

                if (estado == null) {
                    throw new DAOException(
                            "No encontró el estado de la anotación con el ID: "
                            + eId.idEstadoAn);
                }
            } else {
                EstadoAnotacionEnhancedPk eId = new EstadoAnotacionEnhancedPk();
                eId.idEstadoAn = CEstadoAnotacion.ACTIVO;

                estado = this.getEstadoAnotacion(eId, pm);

                if (estado == null) {
                    throw new DAOException(
                            "No encontró el estado de la anotación con el ID: "
                            + eId.idEstadoAn);
                }
            }
            //Se valida que no exista una anotación temporal ya insertada
            //con la misma naturaleza jurídica y con el mismo documento

            //SEGUN REQUERIMIENTO DE SNR SE QUITA ESTA VALIDACION
            /*
            if (!estado.getIdEstadoAn().equals(CEstadoAnotacion.OBSOLETA)) {

                if (!this.validarNaturalezaJuridicaAnotacion(folio, datos, pm)) {
                    throw new DAOException(
                        "No puede inscribir 2 veces una anotación con la misma naturaleza jurídica y el mismo documento");
                }

            }*/
            //Se valida la naturaleza jurídica de la anotacion
            if (datos.getNaturalezaJuridica() == null) {
                throw new DAOException(
                        "La anotación debe tener naturaleza jurídica");
            }

            if (datos.getTipoAnotacion() == null) {
                throw new DAOException(
                        "La anotación debe tener tipo de anotación");
            }

            NaturalezaJuridicaEnhancedPk njId = new NaturalezaJuridicaEnhancedPk();
            njId.idNaturalezaJuridica = datos.getNaturalezaJuridica()
                    .getIdNaturalezaJuridica();
            /*
        *  @author Carlos Torres
        *  @chage   se asigna valor a la propiedad version
        *  @mantis 12705: Acta - Requerimiento No 056_453_Modificiación_de_Naturaleza_Jurídica
             */
            njId.version = datos.getNaturalezaJuridica().getVersion();

            NaturalezaJuridicaEnhanced naturaleza = this.getNaturalezaJuridica(njId,
                    pm);

            if (naturaleza == null) {
                throw new DAOException(
                        "No encontró la naturaleza jurídica de la anotación con el ID: "
                        + njId.idNaturalezaJuridica);
            }

            //Se valida el tipo de anotación
            TipoAnotacionEnhancedPk taId = new TipoAnotacionEnhancedPk();

            taId.idTipoAnotacion = datos.getTipoAnotacion().getIdTipoAnotacion();

            //taId.idTipoAnotacion = CTipoAnotacion.ESTANDAR;
            TipoAnotacionEnhanced tipoAnota = this.getTipoAnotacion(taId, pm);

            if (tipoAnota == null) {
                throw new DAOException(
                        "No encontró el tipo de la anotación con el ID: "
                        + taId.idTipoAnotacion);
            }

            datos.setEstado(estado);
            datos.setNaturalezaJuridica(naturaleza);
            if (datos.getEspecificacion() == null || datos.getEspecificacion().equals("")) {
                datos.setEspecificacion(naturaleza.getNombre());
            }
            datos.setTipoAnotacion(tipoAnota);
            datos.setFecha(new Date());

            //Se setea el usuario de creación, si es null se busca si en la anotación
            //se tiene seteado el usuario
            if (usuario != null) {
                datos.setUsuario(usuario);
            } else {
                if (datos.getUsuario() != null) {
                    UsuarioEnhancedPk uid = new UsuarioEnhancedPk();
                    uid.idUsuario = datos.getUsuario().getIdUsuario();

                    UsuarioEnhanced usAux = this.getUsuarioByID(uid, pm);
                    datos.setUsuario(usAux);
                }
            }

            //Se asocia el documento asociado si tiene
            DocumentoEnhanced auxDoc = datos.getDocumento();

            if (auxDoc != null) {
                if (auxDoc.getCirculo() == null) {
                    auxDoc.setCirculo(folio.getCirculo());
                }
                this.setDocumentoToAnotacionTMP(datos, datos.getDocumento(), pm);
            }

            //Se setea el ID de la anotacion, si es nula se asigna un secuencial, sino
            //se deja el ID que viene.
            if (datos.getIdAnotacionTmp() == null) {
                datos.setIdAnotacionTmp(String.valueOf(folio.getLastIdAnotacionTMP()
                        + 1));
                folio.setLastIdAnotacionTMP(folio.getLastIdAnotacionTMP() + 1);
            }

            datos.setFolio(folio);
            /*
            if (datos.getOrden() == null) {
                datos.setOrden(datos.getIdAnotacionTmp());
            }
             */

            //Se asocia la información de antiguo sistema
            if (datos.getDatosAntiguoSistema() != null) {
                DatosAntiguoSistemaEnhanced datosAS = datos.getDatosAntiguoSistema();
                datosAS.setIdDatosAntiguoSistema(datos.getIdMatricula() + "-"
                        + datos.getIdAnotacionTmp());
            }

            //Se buscan y asocian las salvedades
            List salvedades = datos.getSalvedadesTMPs();
            SalvedadAnotacionTMP salvedad = null;

            for (Iterator itr = salvedades.iterator(); itr.hasNext();) {
                salvedad = (SalvedadAnotacionTMP) itr.next();
                this.addSalvedadToAnotacionTMP(datos, salvedad, usuario, pm);
            }

            //Se buscan y asocian las anotacionesCiudadano
            List anotacionesCiudadano = datos.getAnotacionesCiudadanoTMPs();
            AnotacionCiudadanoTMP anotaCiud = null;

            for (Iterator itr = anotacionesCiudadano.iterator(); itr.hasNext();) {
                anotaCiud = (AnotacionCiudadanoTMP) itr.next();
                this.addAnotacionCiudadanoToAnotacionTMP(datos, anotaCiud, turno, pm);
            }

            //Se buscan y asocian las anotaciones de cancelación
            List cancelaciones = datos.getAnotacionesCancelacionTMPs();
            CancelacionTMP cancelacion = null;

            for (Iterator itr = cancelaciones.iterator(); itr.hasNext();) {
                cancelacion = (CancelacionTMP) itr.next();
                this.addCancelacionToAnotacionTMP(datos, cancelacion, usuario,
                        pm);
            }

            rta = true;
        } catch (DAOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw e;
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }

        return rta;
    }

    /**
     *
     * @param anotacion
     * @param datos
     * @param pm
     * @return
     * @throws DAOException
     */
    protected boolean setDocumentoToAnotacionTMP(AnotacionTMP anotacion,
            DocumentoEnhanced datos, PersistenceManager pm)
            throws DAOException {
        DocumentoEnhanced doc = null;
        boolean rta;

        JDOGenieZonaRegistralDAO zonaRegistralDAO = new JDOGenieZonaRegistralDAO();

        try {
            if (datos.getIdDocumento() != null) {
                DocumentoEnhancedPk did = new DocumentoEnhancedPk();
                did.idDocumento = datos.getIdDocumento();
                doc = this.getDocumento(did, pm);

                if (doc == null) {
                    throw new DAOException(
                            "No encontró el documento con el ID: "
                            + did.idDocumento);
                }

                anotacion.setDocumento(doc);
            } else {

                //Asignación de llave:
                datos.setIdDocumento(String.valueOf(this.getSecuencial(
                        CDocumento.TABLE_NAME, null)));

                if ((datos.getOficinaInternacional() == null) || (datos.getOficinaInternacional().length() <= 0)) {
                    if (datos.getOficinaOrigen() == null) {
                        throw new DAOException("El documento debe tener oficina origen");
                    } else {
                        OficinaOrigenEnhancedPk ofid = new OficinaOrigenEnhancedPk();
                        ofid.idOficinaOrigen = datos.getOficinaOrigen().getIdOficinaOrigen();
                        /*
                          *  @author Carlos Torres
                          *  @chage   se agrega validacion de version diferente
                          *  @mantis 0013414: Acta - Requerimiento No 069_453_Código_Notaria_NC
                         */
                        ofid.version = datos.getOficinaOrigen().getVersion();
                        OficinaOrigenEnhanced oficina = zonaRegistralDAO.getOficinaOrigen(ofid, pm);
                        datos.setOficinaOrigen(oficina);
                    }
                }

                if (datos.getTipoDocumento() == null) {
                    throw new DAOException(
                            "El documento debe tener tipo de documento");
                }

//                OficinaOrigenEnhancedPk ofid = new OficinaOrigenEnhancedPk();
//                ofid.idOficinaOrigen = datos.getOficinaOrigen()
//                                            .getIdOficinaOrigen();
//
//                OficinaOrigenEnhanced oficina = zonaRegistralDAO.getOficinaOrigen(ofid,
//                        pm);
//
//                if (oficina == null) {
//                    throw new DAOException(
//                        "La oficina origen no existe. IdOficina: " +
//                        ofid.idOficinaOrigen);
//                }
                TipoDocumentoEnhancedPk tdid = new TipoDocumentoEnhancedPk();
                tdid.idTipoDocumento = datos.getTipoDocumento()
                        .getIdTipoDocumento();

                TipoDocumentoEnhanced tipoDoc = this.getTipoDocumento(tdid, pm);

                if (tipoDoc == null) {
                    throw new DAOException(
                            "El tipo de documento no existe. IdTipoDocumento: "
                            + tdid.idTipoDocumento);
                }

//                datos.setOficinaOrigen(oficina);
                datos.setTipoDocumento(tipoDoc);
                anotacion.setDocumento(datos);
            }

            rta = true;
        } catch (DAOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw e;
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }

        return rta;
    }

    /**
     *
     * @param anota
     * @param datos
     * @param pm
     * @return
     * @throws DAOException
     */
    protected boolean addAnotacionCiudadanoToAnotacionTMP(AnotacionTMP anota,
            AnotacionCiudadanoTMP datos, TurnoEnhanced turno, PersistenceManager pm)
            throws DAOException {
        JDOGenieZonaRegistralDAO zonaRegistralDAO = new JDOGenieZonaRegistralDAO();
        boolean rta = false;

        try {
            CiudadanoEnhanced ciudadano = datos.getCiudadano();
            CiudadanoEnhanced ciud = null;
            CiudadanoTMP ciudadanoTMP = null;

            if (ciudadano == null) {
                throw new DAOException(
                        "La AnotacionCiudadanoTMP no tiene ciudadano");
            }

            //Validación de prohibición de enajenación
            JDOGenieCiudadanoDAO ciudDAO = new JDOGenieCiudadanoDAO();

            if (ciudadano.getIdCiudadano() != null) {
                CiudadanoEnhancedPk ciudID = new CiudadanoEnhancedPk();
                ciudID.idCiudadano = ciudadano.getIdCiudadano();
                ciud = ciudDAO.getCiudadano(ciudID, pm);
            }

            if (ciud == null) {
                ciud = ciudDAO.getCiudadanoByDocumento(ciudadano.getTipoDoc(),
                        ciudadano.getDocumento(), false, pm, ciudadano.getIdCirculo());
            }

            // Se valida que el ciudadano este en temporal para asociarlo al ciudadano temporal
            ciudadanoTMP = ciudDAO.getCiudadanoTmpByDocumento(ciudadano.getTipoDoc(), ciudadano.getDocumento(), ciudadano.getIdCirculo());

            if (ciudadanoTMP != null) {
                // Se valida que el temporal sea del turno
                if (ciudadanoTMP.getNumeroRadicacion() != null && turno != null && ciudadanoTMP.getNumeroRadicacion().equals(turno.getIdWorkflow())) {
                    //Se va a traer el ciudadano definitivo de acuerdo a los datos del temporal ID
                    CiudadanoEnhancedPk coid = new CiudadanoEnhancedPk();
                    coid.idCiudadano = ciudadanoTMP.getIdCiudadanoTmp();
                    ciud = ciudDAO.getCiudadano(coid, pm);
                }
            }

            if (ciud != null) {
                if (ciudDAO.hasProhibicionActiva(ciud, CProhibicion.ENAJENAR, pm) && datos.getRolPersona().equals(CAnotacionCiudadano.ROL_PERSONA_DE)
                        && !datos.isToDelete()) {
                    throw new DAOException(
                            "El ciudadano tiene prohibición de enajenación. Tipo Doc: "
                            + ciud.getTipoDoc() + " Número Doc: "
                            + ciud.getDocumento());
                }
                //El ciudadano existe y NO tiene prohibición activa, se revisa si
                //se debe actualizar o simplemente asociar:
                //Se quiere editar el ciudadano. Desde este punto SOLO se puede editar el
                //ciudadano si NO existe ninguna anotación definitiva que lo referencie
                if (!this.isCiudadanoInAnotacionDefinitiva(ciud, pm)) {
                    ciud.setTipoPersona(ciudadano.getTipoPersona());
                    ciud.setNombre(ciudadano.getNombre());
                    ciud.setApellido1(ciudadano.getApellido1());
                    ciud.setApellido2(ciudadano.getApellido2());
                    ciud.setSexo(ciudadano.getSexo());
                    if (ciudadano.getTelefono() != null) {
                        ciud.setTelefono(ciudadano.getTelefono());
                    }
                }
                datos.setCiudadano(ciud);

            } else {
                ciud = ciudDAO.crearCiudadano(ciudadano, pm);
                datos.setCiudadano(ciud);
            }

            datos.setAnotacionTmp(anota);
            rta = true;
        } catch (DAOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw e;
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }

        return rta;
    }

    /**
     * Valida la prohibicion de enajencion de una lista de anotaciones ciudadano
     *
     * @param anotaciones
     * @return
     * @throws DAOException
     */
    public boolean validarAnotacionesCiudadano(List anotacionesCiudadano)
            throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        JDOGenieZonaRegistralDAO zonaRegistralDAO = new JDOGenieZonaRegistralDAO();
        boolean rta = false;
        CiudadanoEnhanced ciud = null;

        try {
            for (Iterator iter = anotacionesCiudadano.iterator(); iter.hasNext();) {
                AnotacionCiudadano anotacionCiudadano = (AnotacionCiudadano) iter.next();
                Ciudadano ciudadano = anotacionCiudadano.getCiudadano();
                if (ciudadano == null) {
                    throw new DAOException(
                            "La AnotacionCiudadanoTMP no tiene ciudadano");
                }
                //Validación de prohibición de enajenación
                JDOGenieCiudadanoDAO ciudDAO = new JDOGenieCiudadanoDAO();

                ciud = ciudDAO.getCiudadanoByDocumento(ciudadano.getTipoDoc(),
                        ciudadano.getDocumento(), false, pm, ciudadano.getIdCirculo());

                if (ciud != null) {
                    if (ciudDAO.hasProhibicionActiva(ciud, CProhibicion.ENAJENAR, pm) && anotacionCiudadano.getRolPersona().equals(CAnotacionCiudadano.ROL_PERSONA_DE)
                            && !anotacionCiudadano.isToDelete()) {
                        throw new DAOException(
                                "El ciudadano tiene prohibición de enajenación. Tipo Doc: "
                                + ciud.getTipoDoc() + " Número Doc: "
                                + ciud.getDocumento());
                    }
                }
            }

            rta = true;
        } catch (DAOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw e;
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        return rta;
    }

    /**
     *
     * @param anota
     * @param datos
     * @param pm
     * @return
     * @throws DAOException
     */
    protected boolean addCancelacionToAnotacion(AnotacionEnhanced anota,
            CancelacionEnhanced datos, PersistenceManager pm)
            throws DAOException {
        JDOGenieZonaRegistralDAO zonaRegistralDAO = new JDOGenieZonaRegistralDAO();
        boolean rta = false;

        try {
            AnotacionEnhanced cancelada = datos.getCancelada();
            AnotacionEnhancedPk cid = new AnotacionEnhancedPk();

            if (cancelada == null) {
                throw new DAOException(
                        "La cancelacion no tiene anotación cancelada");
            }

            cid.idAnotacion = cancelada.getIdAnotacion();
            cid.idMatricula = cancelada.getIdMatricula();
            cancelada = this.getAnotacionByID(cid, pm);

            if (cancelada == null) {
                throw new DAOException("La anotación cancelada no existe");
            }

            datos.setCancelada(cancelada);
            datos.setCanceladora(anota);
            rta = true;
        } catch (DAOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw e;
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }

        return rta;
    }

    /**
     *
     * @param anota
     * @param datos
     * @param pm
     * @return
     * @throws DAOException
     */
    protected boolean addFolioDerivadoHijoToAnotacion(AnotacionEnhanced anota,
            FolioDerivadoEnhanced datos, UsuarioEnhanced usuario,
            TurnoEnhanced turno, boolean validarTurno, PersistenceManager pm) throws DAOException {
        JDOGenieZonaRegistralDAO zonaRegistralDAO = new JDOGenieZonaRegistralDAO();
        boolean rta = false;

        //TODO CAMBIAR EL NOMBRE A ESTA FUNCION
        try {
            AnotacionEnhanced hijo = datos.getHijo();
            AnotacionEnhancedPk cid = new AnotacionEnhancedPk();

            if (hijo == null) {
                throw new DAOException("El folio derivado debe tener hijo");
            }

            //Se verifica si la anotación hija tiene más padres, puesto
            //que no se puede eliminar la anotación temporal hija si
            //existen más folios derivados apuntándole
            AnotacionTMPPk aid = new AnotacionTMPPk();
            aid.idAnotacionTmp = hijo.getIdAnotacion();
            aid.idMatricula = hijo.getIdMatricula();

            AnotacionTMP auxTMP = this.getAnotacionTMPByID(aid, pm);

            if (auxTMP == null) {
                throw new DAOException("No existe la anotación hija");
            }

            if (auxTMP.getAnotacionesPadreTMPs().size() > 1) {
                //La anotación tiene más padres entonces se debe
                //crear o asociar la anotación definitiva hija
                //Verificamos si existe una anotación
                //definitiva que ya esté actuando como hija
                AnotacionEnhancedPk aeid = new AnotacionEnhancedPk();
                aeid.idAnotacion = hijo.getIdAnotacion();
                aeid.idMatricula = hijo.getIdMatricula();

                AnotacionEnhanced aeaux = this.getAnotacionByID(aeid, pm);

                if (aeaux != null) {
                    //Ya existe la anotación definitiva hija, entonces
                    //se debe asociar
                    datos.setHijo(aeaux);
                    datos.setPadre(anota);
                } else {
                    //La anotación definitiva hija no existe, entonces
                    //se debe crear (o hacer definitiva)
                    AnotacionEnhanced an = auxTMP.getDefinitivo(new ArrayList());

                    //No quitar esto por favor, Es para que se asigne automáticamente el ID
                    //en addAnotacionToFolio.
                    //Se quita para que se asigne al identificador de la anotacion
                    //correspondiente a la anotacion temporal
                    //an.setIdAnotacion(null);
                    this.addAnotacionToFolio(auxTMP.getFolio(), an, usuario,
                            turno, validarTurno, pm);

                    pm.makePersistent(an);

                    datos.setHijo(an);
                    datos.setPadre(anota);
                }
            } else {
                //Se verifica si la anotación hijo tiene un folio que no ha sido
                //transformado a definitivo, esto se hace con el fin de establecer
                //el link definitivo entre las dos anotaciones
                FolioEnhancedPk tid = new FolioEnhancedPk();

                tid.idMatricula = hijo.getIdMatricula();

                FolioEnhanced faux = this.getFolioByID(tid, pm);

                if (faux == null) {
                    throw new DAOException("No existe el folio hijo");
                }

                if (!faux.isDefinitivo()) {
                    this.hacerDefinitivoFolio(faux, usuario, turno, validarTurno, pm);
                }

                //A partir de acá se asegura que la anotación del folio hijo
                //ya es definitiva:
                cid.idAnotacion = hijo.getIdAnotacion();
                cid.idMatricula = hijo.getIdMatricula();
                hijo = this.getAnotacionByID(cid, pm);

                if (hijo == null) {
                    throw new DAOException("La anotación hijo no existe");
                }

                datos.setHijo(hijo);
                datos.setPadre(anota);
            }

            rta = true;
        } catch (DAOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw e;
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }

        return rta;
    }

    /**
     *
     * @param anota
     * @param datos
     * @param pm
     * @return
     * @throws DAOException
     */
    protected boolean addFolioDerivadoPadreToAnotacion(AnotacionEnhanced anota,
            FolioDerivadoEnhanced datos, UsuarioEnhanced usuario,
            TurnoEnhanced turno, boolean validarTurno, PersistenceManager pm) throws DAOException {
        JDOGenieZonaRegistralDAO zonaRegistralDAO = new JDOGenieZonaRegistralDAO();
        boolean rta = false;

        //TODO CAMBIAR EL NOMBRE A ESTA FUNCION
        try {
            AnotacionEnhanced padre = datos.getPadre();
            AnotacionEnhancedPk cid = new AnotacionEnhancedPk();

            if (padre == null) {
                throw new DAOException("El folio derivado debe tener hijo");
            }

            //Se verifica si la anotación hija tiene más padres, puesto
            //que no se puede eliminar la anotación temporal hija si
            //existen más folios derivados apuntándole
            AnotacionTMPPk aid = new AnotacionTMPPk();
            aid.idAnotacionTmp = padre.getIdAnotacion();
            aid.idMatricula = padre.getIdMatricula();

            AnotacionTMP auxTMP = this.getAnotacionTMPByID(aid, pm);

            if (auxTMP == null) {
                throw new DAOException("No existe la anotación hija");
            }

            if (auxTMP.getAnotacionesHijosTMPs().size() > 1) {
                //La anotación tiene más hijos entonces se debe
                //crear o asociar la anotación definitiva hija
                //Verificamos si existe una anotación
                //definitiva que ya esté actuando como hija
                AnotacionEnhancedPk aeid = new AnotacionEnhancedPk();
                aeid.idAnotacion = padre.getIdAnotacion();
                aeid.idMatricula = padre.getIdMatricula();

                AnotacionEnhanced aeaux = this.getAnotacionByID(aeid, pm);

                if (aeaux != null) {
                    //Ya existe la anotación definitiva hija, entonces
                    //se debe asociar
                    //datos.setHijo(aeaux);
                    //datos.setPadre(anota);

                    datos.setHijo(anota);
                    datos.setPadre(aeaux);
                } else {
                    //La anotación definitiva hija no existe, entonces
                    //se debe crear (o hacer definitiva)
                    AnotacionEnhanced an = auxTMP.getDefinitivo(new ArrayList());

                    //No quitar esto por favor, Es para que se asigne automáticamente el ID
                    //en addAnotacionToFolio.
                    //Se quita para que se asigne al identificador de la anotacion
                    //correspondiente a la anotacion temporal
                    //an.setIdAnotacion(null);
                    this.addAnotacionToFolio(auxTMP.getFolio(), an, usuario,
                            turno, validarTurno, pm);

                    pm.makePersistent(an);

                    datos.setHijo(anota);
                    datos.setPadre(an);
                }
            } else {
                //Se verifica si la anotación hijo tiene un folio que no ha sido
                //transformado a definitivo, esto se hace con el fin de establecer
                //el link definitivo entre las dos anotaciones
                FolioEnhancedPk tid = new FolioEnhancedPk();

                tid.idMatricula = padre.getIdMatricula();

                FolioEnhanced faux = this.getFolioByID(tid, pm);

                if (faux == null) {
                    throw new DAOException("No existe el folio hijo");
                }

                if (!faux.isDefinitivo()) {
                    this.hacerDefinitivoFolio(faux, usuario, turno, validarTurno, pm);
                }

                //A partir de acá se asegura que la anotación del folio hijo
                //ya es definitiva:
                cid.idAnotacion = padre.getIdAnotacion();
                cid.idMatricula = padre.getIdMatricula();
                padre = this.getAnotacionByID(cid, pm);

                if (padre == null) {
                    throw new DAOException("La anotación hijo no existe");
                }

                /*datos.setHijo(hijo);
               datos.setPadre(anota);*/
                datos.setHijo(anota);
                datos.setPadre(padre);
            }

            rta = true;
        } catch (DAOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw e;
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }

        return rta;
    }

    /**
     *
     * @param anota
     * @param datos
     * @param pm
     * @return
     * @throws DAOException
     */
    protected boolean addCancelacionToAnotacionTMP(AnotacionTMP anota,
            CancelacionTMP datos, UsuarioEnhanced usuario, PersistenceManager pm)
            throws DAOException {
        boolean rta = false;

        try {
            AnotacionEnhanced cancelada;
            AnotacionTMP canceladaTMP;

            //Se valida que no exista la misma cancelación para la anotación:
            CancelacionTMP cal = this.getCancelacionTMP(datos, anota, pm);

            if (cal != null) {
                if (!cal.isToDelete()) {
                    throw new DAOException("Ya está cancelando la misma anotación");
                }
            }
            /*
            //SE IGNORA ESTE CODIGO PORQUE LA CREACION DE LA CANCELADA SE PASO
            //A OTRO Metodo
            //Se mira si la anotación cancelada se debe crear o se debe
            //asociar
            if (anota.isCrearCancelada()) {
                cancelada = datos.getCanceladaDef();
                canceladaTMP = new AnotacionTMP(cancelada, new ArrayList());

                //Se le quita el ID para que se asigne un ID automático
                canceladaTMP.setIdAnotacionTmp(null);
                canceladaTMP.setOrden(null);

                this.addAnotacionTMPToFolio(anota.getFolio(), canceladaTMP,
                    usuario, pm);

                datos.setCanceladaTmp(canceladaTMP);
                datos.setAnotacionTemporal(true);
                datos.setCanceladaDef(null);
            } else {*/
            //SE IGNORA ESTE CODIGO PORQUE YA NO SE PUEDEN CANCELAR ANOTACIONES TEMPORALES
            //Se define si la anotacion cancelada es temporal o es
            //definitiva (La anotación cancelada es guardada por defecto en canceladaDef)
            cancelada = datos.getCanceladaDef();

            AnotacionTMPPk aIdTMP = new AnotacionTMPPk();
            //aIdTMP.idZonaRegistral = cancelada.getIdZonaRegistral();
            aIdTMP.idMatricula = cancelada.getIdMatricula();
            aIdTMP.idAnotacionTmp = cancelada.getIdAnotacion();

            canceladaTMP = this.getAnotacionTMPByID(aIdTMP, pm);

            //Si encontró la anotación entre las temporales:
            if (canceladaTMP != null) {
                if (anota.getIdWorkflow() != null && !anota.getIdWorkflow().equals(canceladaTMP.getIdWorkflow())) {
                    throw new DAOException(
                            "La anotacion temporal a cancelar fue creada en otro turno");
                }
                datos.setCanceladaTmp(canceladaTMP);
                datos.setAnotacionTemporal(true);
                datos.setCanceladaDef(null);
            } //Si no encontró la anotación entre las temporales
            //se revisan las definitivas
            else {
                AnotacionEnhancedPk aId = new AnotacionEnhancedPk();
                aId.idMatricula = cancelada.getIdMatricula();
                aId.idAnotacion = cancelada.getIdAnotacion();

                cancelada = this.getAnotacionByID(aId, pm);

                if (cancelada == null) {
                    throw new DAOException(
                            "No se encontró la anotación cancelada");
                }

                datos.setCanceladaDef(cancelada);
                datos.setCanceladaTmp(null);
                datos.setAnotacionTemporal(false);
            }
            //}

            datos.setIdCancelacionTmp(String.valueOf(anota.getLastIdCancelacion()
                    + 1));
            anota.setLastIdCancelacion(anota.getLastIdCancelacion() + 1);
            datos.setCanceladora(anota);
            rta = true;
        } catch (DAOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw e;
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }

        return rta;
    }

    /**
     *
     * @param anota
     * @param datos
     * @param pm
     * @return
     * @throws DAOException
     */
    protected boolean checkCreacionCanceladaAnotacionTMP(FolioEnhanced folio, AnotacionTMP anota,
            CancelacionTMP datos, UsuarioEnhanced usuario, TurnoEnhanced turno, PersistenceManager pm)
            throws DAOException {
        boolean rta = false;

        try {
            AnotacionEnhanced cancelada;
            AnotacionTMP canceladaTMP;

            //Se valida que no exista la misma cancelación para la anotación:
            CancelacionTMP cal = this.getCancelacionTMP(datos, anota, pm);

            if (cal != null) {
                throw new DAOException("Ya está cancelando la misma anotación");
            }

            //Se mira si la anotación cancelada se debe crear
            if (anota.isCrearCancelada()) {
                cancelada = datos.getCanceladaDef();
                canceladaTMP = new AnotacionTMP(cancelada, new ArrayList());

                //Se le quita el ID para que se asigne un ID automático
                canceladaTMP.setOrden(String.valueOf(this.getNextOrdenAnotacion(folio, pm)));
                canceladaTMP.setIdAnotacionTmp(null);
                canceladaTMP.setHeredada(anota.isHeredada());
                canceladaTMP.setIdWorkflow(anota.getIdWorkflow());//bug 3254

                this.addAnotacionTMPToFolio(folio, canceladaTMP, usuario, turno, pm);
                pm.makePersistent(canceladaTMP);
                datos.setCanceladaDef(canceladaTMP.getDefinitivo(new ArrayList()));
                //Si se creó la anotación nueva, se aumenta el orden previamente
                //seteado de la anotación canceladora
                if (anota.getOrden() != null) {
                    long ordenNum = Long.parseLong(anota.getOrden());
                    ordenNum = ordenNum + 1;
                    anota.setOrden(String.valueOf(ordenNum));
                }

            }
        } catch (DAOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw e;
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }

        return rta;
    }

    /**
     * Obtiene una anotación temporal
     *
     * @param oid
     * @param pm
     * @return
     * @throws DAOException
     */
    protected AnotacionTMP getAnotacionTMPByID(AnotacionTMPPk oid,
            PersistenceManager pm) throws DAOException {
        AnotacionTMP rta = null;

        if ((oid.idAnotacionTmp != null) && (oid.idMatricula != null)) {
            try {
                rta = (AnotacionTMP) pm.getObjectById(oid, true);
            } catch (JDOObjectNotFoundException e) {
                rta = null;
            } catch (JDOException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                throw new DAOException(e.getMessage(), e);
            }
        }

        return rta;
    }

    /**
     * Obtiene una anotación temporal
     *
     * @param oid
     * @param pm
     * @return
     * @throws DAOException
     */
    public AnotacionTMP getAnotacionTMPByIDSinPersitence(AnotacionTMPPk oid) throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        AnotacionTMP rta = null;
        this.getAnotacionesFolio(oid.idMatricula);
        if ((oid.idAnotacionTmp != null) && (oid.idMatricula != null)) {
            try {
                rta = (AnotacionTMP) pm.getObjectById(oid, true);
            } catch (JDOObjectNotFoundException e) {
                rta = null;
            } catch (JDOException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                throw new DAOException(e.getMessage(), e);
            }
        }

        return rta;
    }

    /**
     * Obtiene una anotación temporal
     *
     * @param oid
     * @param pm
     * @return
     * @throws DAOException
     */
    protected AnotacionTMP getAnotacionTMPByIDSinAnotaFolio(AnotacionTMPPk oid,
            PersistenceManager pm) throws DAOException {
        AnotacionTMP rta = null;
        if ((oid.idAnotacionTmp != null) && (oid.idMatricula != null)) {
            try {
                rta = (AnotacionTMP) pm.getObjectById(oid, true);
            } catch (JDOObjectNotFoundException e) {
                rta = null;
            } catch (JDOException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                throw new DAOException(e.getMessage(), e);
            }
        }

        return rta;
    }

    /**
     *
     * @param anota
     * @param datos
     * @param pm
     * @return
     * @throws DAOException
     */
    protected boolean addSalvedadToAnotacionTMP(AnotacionTMP anota,
            SalvedadAnotacionTMP datos, UsuarioEnhanced usuario,
            PersistenceManager pm) throws DAOException {
        boolean rta = false;

        try {
            //Se setea el usuario creador, si es null se mira si en la salvedad
            //viene un usuario para asociarlo
            if (usuario != null) {
                datos.setUsuario(usuario);
            } else {
                if (datos.getUsuario() != null) {
                    UsuarioEnhancedPk uid = new UsuarioEnhancedPk();
                    uid.idUsuario = datos.getUsuario().getIdUsuario();

                    UsuarioEnhanced usAux = this.getUsuarioByID(uid, pm);
                    datos.setUsuario(usAux);
                }
            }

            if (datos.getIdSalvedadAnTmp() == null) {
                datos.setIdSalvedadAnTmp(String.valueOf(anota.getLastIdSalvedad()
                        + 1));
                anota.setLastIdSalvedad(anota.getLastIdSalvedad() + 1);
            }

            datos.setFechaCreacion(new Date());
            datos.setAnotacionTmp(anota);
            rta = true;
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }

        return rta;
    }

    /**
     *
     * @param datos
     * @param usuario
     * @return
     * @throws DAOException
     */
    protected boolean hacerDefinitivoFolio(FolioEnhanced folio,
            UsuarioEnhanced usuario, TurnoEnhanced turno, boolean validarTurno, PersistenceManager pm)
            throws DAOException {
        boolean rta = false;
        JDOGenieCiudadanoDAO ciudDAO = new JDOGenieCiudadanoDAO();
        try {

            //Se busca si existe información en datos temporales
            //para hacerla definitiva
            FolioDatosTMP dTMP;

            try {
                dTMP = folio.getDatosTMP();
            } catch (JDOObjectNotFoundException e) {
                dTMP = null;
            }

            //Se crea una copia del folio
            FolioEnhanced folioAuditoriaViejo = (FolioEnhanced) auditoria.clonarEnhanced(folio);
            if (dTMP != null) {
                this.hacerDefinitivoFolioDatos(folio, dTMP, pm, turno, validarTurno, usuario);
            }

            //Se busca si se debe hacer definitivo la complementacion
            ComplementacionTMP cTMP = folio.getComplementacionTMP();

            if (cTMP != null) {
                this.hacerDefinitivoComplementacion(folio, cTMP, usuario, (turno != null) ? turno.getIdWorkflow() : null, pm);
            }

            //Se busca si se debe hacer definitivo el documento
            DocumentoTMP docTMP = folio.getDocumentoTMP();

            if (docTMP != null) {
                this.hacerDefinitivoDocumento(folio, docTMP, usuario, (turno != null) ? turno.getIdWorkflow() : null, pm);
            }

            //Se buscan las direcciones temporales para hacerlas definitivas
            if (folio.getDireccionesTMPs().size() > 0) {
                this.hacerDefinitivasDirecciones(folio, usuario, (turno != null) ? turno.getIdWorkflow() : null, pm);
            }

            //Se buscan las salvedades temporales a añadir
            if (folio.getSalvedadesTMPs().size() > 0) {
                this.hacerDefinitivasSalvedades(folio, usuario, turno, validarTurno, pm);
            }

            //Se buscan las anotaciones temporales a añadir o actualizar
            if (folio.getAnotacionesTMPs().size() > 0) {
                this.hacerDefinitivasAnotaciones(folio, usuario, turno, validarTurno, pm);
            }

            if (!folio.isDefinitivo()) {
                folio.setDefinitivo(true);
            }

            List ciudsToUpdate = ciudDAO.getCiudadanosTemporalesFolio(folio, pm);
            if (!ciudsToUpdate.isEmpty()) {
                this.hacerDefinitivosCiudadanos(ciudsToUpdate, usuario, turno, pm);
            }

            if (folio.getTurnosFolios() != null && folio.getTurnosFolios().size() > 0) {
                this.actualizarTurnoFolio(folio, usuario, turno, validarTurno, pm);
            }

            //Se hace la auditoría a los atributos que cambiaron
            auditoria.addAuditoria(folio, folioAuditoriaViejo, usuario, pm);
            /**
             * @Author Carlos Torres
             * @Mantis 13176
             * @Chaged
             */
            try{
            if(getAudFlag()){
                 if (turno != null) {
                co.com.iridium.generalSIR.negocio.auditoria.AuditoriaSIR auditoriaSir = new co.com.iridium.generalSIR.negocio.auditoria.AuditoriaSIR();
                auditoriaSir.guardarAuditoriaFolio(folio, folioAuditoriaViejo, (turno != null) ? turno.getIdWorkflow() : folio.getIdMatricula());
                }
            }
            } catch (GeneralSIRException ex) {
                    System.out.println("ERROR: No se ha podido consultar el flag");
            } catch (gov.sir.hermod.dao.DAOException ex) { 
                    System.out.println("ERROR: No se ha podido consultar el flag");
            }

            rta = true;
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }

        return rta;
    }
    
    public boolean getAudFlag() throws gov.sir.hermod.dao.DAOException {
        String response = "";
        boolean enable = true;
        Connection connection = null;
        PreparedStatement ps = null;
        ResultSet rs = null;
        VersantPersistenceManager jdoPM = null;
        String consulta = "SELECT LKCD_VALOR FROM SIR_OP_LOOKUP_CODES " +
                         " WHERE ID_TIPO = 'AUD_FLAG'";

        try {
            jdoPM = (VersantPersistenceManager) gov.sir.hermod.dao.impl.jdogenie.AdministradorPM.getPM();

            jdoPM.currentTransaction().begin();
            connection = jdoPM.getJdbcConnection(null);
            ps = connection.prepareStatement(consulta);
            rs = ps.executeQuery();
            
            while(rs.next()){
            response = (String) rs.getString(1);
            }
            
            if(!response.equals("1")){
                enable = false; 
            }
            

            jdoPM.currentTransaction().commit();

        } catch (SQLException e) {
            if (jdoPM.currentTransaction().isActive()) {
                jdoPM.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new gov.sir.hermod.dao.DAOException(e.getMessage(), e);
        } catch (JDOObjectNotFoundException e) {
            if (jdoPM.currentTransaction().isActive()) {
                jdoPM.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new gov.sir.hermod.dao.DAOException(e.getMessage(), e);
        } catch (JDOException e) {
            if (jdoPM.currentTransaction().isActive()) {
                jdoPM.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new gov.sir.hermod.dao.DAOException(e.getMessage(), e);
        } catch (Throwable e) {
            if (jdoPM.currentTransaction().isActive()) {
                jdoPM.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new gov.sir.hermod.dao.DAOException(e.getMessage(), e);
        } finally {
            try {
                if (rs != null) {
                    rs.close();
                }

                if (ps != null) {
                    ps.close();
                }
                if (connection != null) {
                    connection.close();
                }
                if (jdoPM != null) {
                    jdoPM.close();
                }
            } catch (SQLException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e);
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
                throw new gov.sir.hermod.dao.DAOException(e.getMessage(), e);
            }
        }

        return enable;
    }

    /**
     * Hace definitivos los ciudadanos
     *
     * @param list
     */
    protected void hacerDefinitivosCiudadanos(List ciudadanosTMP, UsuarioEnhanced usuario, TurnoEnhanced turno, PersistenceManager pm) throws DAOException {
        CiudadanoTMP ciudTMP;
        JDOGenieCiudadanoDAO ciudDAO = new JDOGenieCiudadanoDAO();
        /**
         * @Author Carlos Torres
         * @Mantis 13176
         * @Chaged
         */
        co.com.iridium.generalSIR.negocio.auditoria.AuditoriaSIR auditoriaSir = new co.com.iridium.generalSIR.negocio.auditoria.AuditoriaSIR();
        for (Iterator it = ciudadanosTMP.iterator(); it.hasNext();) {
            ciudTMP = (CiudadanoTMP) it.next();

            CiudadanoTMPPk ciudId = new CiudadanoTMPPk();
            ciudId.idCiudadanoTmp = ciudTMP.getIdCiudadanoTmp();
            CiudadanoTMP ciudadanoTMP = ciudDAO.getCiudadanoTMP(ciudId, pm);

            boolean toActualizar = true;

            CiudadanoEnhancedPk ciudID = new CiudadanoEnhancedPk();
            ciudID.idCiudadano = ciudTMP.getIdCiudadanoTmp();

            CiudadanoEnhanced ciudToUpdateDef = ciudDAO.getCiudadano(ciudID, pm);

            //SE DEBE MIRAR EL NUMERO DE RADIACION DEL CIUDADANO
            if (ciudToUpdateDef == null) {
                throw new DAOException("No existe el ciudadano definitivo a actualizar");
            }

            if (ciudadanoTMP.getNumeroRadicacion() != null && !ciudadanoTMP.getNumeroRadicacion().equals(turno.getIdWorkflow())) {
                toActualizar = false;
            }

            if (toActualizar) {
                //Se saca la auditoria
                CiudadanoEnhanced ciudAuditoriaViejo = (CiudadanoEnhanced) auditoria.clonarEnhanced(ciudToUpdateDef);

                //actualización
                ciudToUpdateDef.setTipoPersona(ciudTMP.getTipoPersona());
                ciudToUpdateDef.setApellido1(ciudTMP.getApellido1());
                ciudToUpdateDef.setApellido2(ciudTMP.getApellido2());
                ciudToUpdateDef.setNombre(ciudTMP.getNombre());
                ciudToUpdateDef.setSexo(ciudTMP.getSexo());
                ciudToUpdateDef.setDocumento(ciudTMP.getDocumento());
                ciudToUpdateDef.setTelefono(ciudTMP.getTelefono());
                ciudToUpdateDef.setTipoDoc(ciudTMP.getTipoDocumento());

                //Se hace la auditoría a los atributos que cambiaron
                auditoria.addAuditoria(ciudToUpdateDef, ciudAuditoriaViejo, usuario, pm);
                if (turno != null) {
                    try {
                        auditoriaSir.guardarAuditoriaCiudadano(ciudToUpdateDef, ciudAuditoriaViejo, turno.getIdWorkflow());
                    } catch (GeneralSIRException ex) {
                        Log.getInstance().error(JDOGenieFolioDAO.class, ex.getMessage());
                    }
                }
                pm.deletePersistent(ciudTMP);
            }
        }
    }

    /**
     *
     * @param datos
     * @param usuario
     * @return
     * @throws DAOException
     */
    public boolean hacerDefinitivoFolio(Folio datos, Usuario usuario,
            TurnoPk tid, boolean validarTurno) throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();

        boolean rta = false;
        FolioEnhanced folio;
        UsuarioEnhanced us;

        try {
            TurnoEnhanced turno = null;
            UsuarioEnhancedPk uid = new UsuarioEnhancedPk();
            uid.idUsuario = usuario.getIdUsuario();

            us = this.getUsuarioByID(uid, pm);

            if (us == null) {
                throw new DAOException("El usuario especificado no existe: "
                        + uid.idUsuario);
            }

            if (validarTurno) {
                if (tid != null) {
                    //Validamos que el turno exista:
                    TurnoEnhancedPk tenh = new TurnoEnhancedPk(tid);

                    turno = this.getTurnoByID(tenh, pm);

                    if (turno == null) {
                        throw new DAOException("El turno especificado no existe");
                    }
                }
            }

            //Una vez realizadas las validaciones se inicia la transacción
            //Se pone el candado en folio
            pm.currentTransaction().setOptimistic(false);
            pm.currentTransaction().begin();

            //Obtenemos el folio persistente
            FolioEnhancedPk fid = new FolioEnhancedPk();
            fid.idMatricula = datos.getIdMatricula();

            folio = this.getFolioByID(fid, pm);

            if (folio == null) {
                throw new DAOException("El folio no existe");
            }

            //Se valida el bloqueo
            if (validarTurno) {
                this.validarBloqueoFolio(folio, usuario, pm);
            }

            //revisar desde el principio si se debe actualizar la zona registral
            ZonaRegistralEnhanced zonaRegToUpdate = null;
            FolioDatosTMP dTMP;
            try {
                dTMP = folio.getDatosTMP();
            } catch (JDOObjectNotFoundException e) {
                dTMP = null;
            }

            /*if(dTMP!=null){
			   if(dTMP.getZonaRegistral()!=null){
					zonaRegToUpdate = dTMP.getZonaRegistral();
			   }
			}*/
            //Se hacen definitivos todos los demás cambios del folio
            this.hacerDefinitivoFolio(folio, us, turno, validarTurno, pm);

            //Lo último que se debe revisar es si se debe actualizar la zona registral
            //Ejecutamos el flush
            if (zonaRegToUpdate != null) {
                VersantPersistenceManager pm2 = (VersantPersistenceManager) pm;
                pm2.flush();
                this.updateZonaRegistralFolio(folio, zonaRegToUpdate, us, pm);
            }

            pm.currentTransaction().commit();

            //se ordenan los id de las direcciones definitivas que se cambiaron
            ordenaDireccionesDefinitivas();
        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (DAOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            throw e;
        } catch (Exception e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        return rta;
    }

    /**
     * Deshace los cambios que están siendo aplicados al folio, borra toda la
     * información temporal
     *
     * @param datos
     * @param usuario
     * @return
     * @throws DAOException
     */
    public boolean deshacerCambiosFolio(Folio datos, Usuario usuario)
            throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        boolean rta = false;

        FolioEnhanced folio;
        UsuarioEnhanced us;

        try {
            pm.currentTransaction().begin();

            //Obtenemos el folio persistente
            FolioEnhancedPk fid = new FolioEnhancedPk();
            fid.idMatricula = datos.getIdMatricula();

            folio = this.getFolioByID(fid, pm);

            if (folio == null) {
                throw new DAOException("El folio no existe");
            }

            //Se valida el bloqueo
            this.validarBloqueoFolio(folio, usuario, pm);

            //Se busca si existe información en datos temporales
            //para deshacerla
            FolioDatosTMP dTMP;

            try {
                dTMP = folio.getDatosTMP();
            } catch (JDOObjectNotFoundException e) {
                dTMP = null;
            }

            if (dTMP != null) {
                pm.deletePersistent(dTMP);
                //folio.setDatosTMP(null);
            }

            //Se busca si se debe deshacer la complementacion
            ComplementacionTMP cTMP = folio.getComplementacionTMP();

            if (cTMP != null) {
                //pm.deletePersistent(cTMP);
                //TODO Mirar el borrado de COMPLEMENTACIONES temporales
                folio.setComplementacionTMP(null);
            }

            //Se buscan las direcciones temporales para deshacerlas
            if (folio.getDireccionesTMPs().size() > 0) {
                pm.deletePersistentAll(folio.getDireccionesTMPs());
            }

            //Se buscan las salvedades temporales para deshacerlas
            if (folio.getSalvedadesTMPs().size() > 0) {
                pm.deletePersistentAll(folio.getSalvedadesTMPs());
            }

            //Se buscan las anotaciones temporales para deshacerlas
            if (folio.getAnotacionesTMPs().size() > 0) {
                pm.deletePersistentAll(folio.getAnotacionesTMPs());
            }

            //Se resetean las secuencias temporales
            folio.setLastIdAnotacionTMP(folio.getLastIdAnotacion());
            folio.setLastIdDireccionTMP(folio.getLastIdDireccion());
            folio.setLastIdSalvedadTMP(folio.getLastIdSalvedad());

            pm.currentTransaction().commit();
        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (DAOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            throw e;
        } catch (Exception e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        return rta;
    }

    public void eliminarFolioCreacionDirecta(Folio datos, Usuario usuario)
            throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();

        FolioEnhanced folio;
        UsuarioEnhanced us;
        MatriculaNoGrabadaEnhanced matNoGrabada;
        CirculoEnhanced cirEnh;
        JDOGenieZonaRegistralDAO zonaRegistralDAO = new JDOGenieZonaRegistralDAO();

        try {
            pm.currentTransaction().begin();

            //Obtenemos el folio persistente
            FolioEnhancedPk fid = new FolioEnhancedPk();
            fid.idMatricula = datos.getIdMatricula();

            folio = this.getFolioByID(fid, pm);

            if (folio == null) {
                throw new DAOException("El folio no existe");
            }

            UsuarioEnhancedPk uid = new UsuarioEnhancedPk();
            uid.idUsuario = usuario.getIdUsuario();

            us = this.getUsuarioByID(uid, pm);

            if (us == null) {
                throw new DAOException("El usuario especificado no existe: "
                        + uid.idUsuario);
            }

            //Se valida el bloqueo
            this.validarBloqueoFolio(folio, usuario, pm);

            //Se busca si existe información en datos temporales
            //para deshacerla
            FolioDatosTMP dTMP;

            try {
                dTMP = folio.getDatosTMP();
            } catch (JDOObjectNotFoundException e) {
                dTMP = null;
            }

            if (dTMP != null) {
                pm.deletePersistent(dTMP);
                //folio.setDatosTMP(null);
            }

            //Se busca si se debe deshacer la complementacion
            ComplementacionTMP cTMP = folio.getComplementacionTMP();

            if (cTMP != null) {
                //pm.deletePersistent(cTMP);
                //TODO Mirar el borrado de COMPLEMENTACIONES temporales
                folio.setComplementacionTMP(null);
            }

            //Se buscan las direcciones temporales para deshacerlas
            if (folio.getDireccionesTMPs().size() > 0) {
                pm.deletePersistentAll(folio.getDireccionesTMPs());
            }

            //Se buscan las salvedades temporales para deshacerlas
            if (folio.getSalvedadesTMPs().size() > 0) {
                pm.deletePersistentAll(folio.getSalvedadesTMPs());
            }

            //Se buscan las anotaciones temporales para deshacerlas
            if (folio.getAnotacionesTMPs().size() > 0) {
                pm.deletePersistentAll(folio.getAnotacionesTMPs());
            }

            //Se resetean las secuencias temporales
            folio.setLastIdAnotacionTMP(folio.getLastIdAnotacion());
            folio.setLastIdDireccionTMP(folio.getLastIdDireccion());
            folio.setLastIdSalvedadTMP(folio.getLastIdSalvedad());

            CirculoEnhancedPk cid = new CirculoEnhancedPk();
            cid.idCirculo = datos.getCirculo();
            cirEnh = zonaRegistralDAO.getCirculo(cid, pm);

            long secMatricula = Long.parseLong(datos.getIdMatricula().split("-")[1]);
            if (secMatricula < cirEnh.getLastNoMatricula()) {
                if (!this.matriculaNoGrabadaExistente(cirEnh.getIdCirculo(), secMatricula)) {
                    matNoGrabada = new MatriculaNoGrabadaEnhanced();
                    matNoGrabada.setCirculo(cirEnh);
                    matNoGrabada.setIdCirculo(cirEnh.getIdCirculo());
                    matNoGrabada.setFechaCreacion(new Date());
                    matNoGrabada.setUsuario(us);
                    matNoGrabada.setDescripcion("Cancelacion Creacion Directa del Folio");
                    matNoGrabada.setIdMatNoGrabada(secMatricula);
                    pm.makePersistent(matNoGrabada);
                }
            } else {
                cirEnh.setLastNoMatricula(cirEnh.getLastNoMatricula() - 1);
            }

            pm.deletePersistent(folio);

            pm.currentTransaction().commit();
        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (DAOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            throw e;
        } catch (Exception e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }
    }

    protected boolean eliminarFolioSegregacion(Folio datos, Usuario usuario, TurnoEnhanced turno, PersistenceManager pm)
            throws DAOException {
        //PersistenceManager pm = AdministradorPM.getPM();

        FolioEnhanced folio;
        UsuarioEnhanced us;
        MatriculaNoGrabadaEnhanced matNoGrabada;
        CirculoEnhanced cirEnh;
        JDOGenieZonaRegistralDAO zonaRegistralDAO = new JDOGenieZonaRegistralDAO();

        try {
            //pm.currentTransaction().begin();

            //Obtenemos el folio persistente
            FolioEnhancedPk fid = new FolioEnhancedPk();
            fid.idMatricula = datos.getIdMatricula();

            Folio folioFullSinAnota = getFolioByID(datos.getIdMatricula());

            folio = this.getFolioByID(fid, pm);

            //rta = this.getFolioByID(new FolioEnhancedPk(oid), pm);
            if (folio == null) {
                throw new DAOException("El folio no existe");
            }

            UsuarioEnhancedPk uid = new UsuarioEnhancedPk();
            uid.idUsuario = usuario.getIdUsuario();

            us = this.getUsuarioByID(uid, pm);

            if (us == null) {
                throw new DAOException("El usuario especificado no existe: "
                        + uid.idUsuario);
            }

            //Se valida el bloqueo
            this.validarBloqueoFolio(folio, usuario, pm);

            //Se busca si existe información en datos temporales
            //para deshacerla
            FolioDatosTMP dTMP;

            try {
                dTMP = folio.getDatosTMP();
            } catch (JDOObjectNotFoundException e) {
                dTMP = null;
            }

            if (dTMP != null) {
                pm.deletePersistent(dTMP);
                //folio.setDatosTMP(null);
            }

            //Se busca si se debe deshacer la complementacion
            ComplementacionTMP cTMP = folio.getComplementacionTMP();

            if (cTMP != null) {
                //pm.deletePersistent(cTMP);
                //TODO Mirar el borrado de COMPLEMENTACIONES temporales
                folio.setComplementacionTMP(null);
            }

            //Se buscan las direcciones temporales para deshacerlas
            if (folio.getDireccionesTMPs().size() > 0) {
                pm.deletePersistentAll(folio.getDireccionesTMPs());
            }

//	      	Se buscan las direcciones definitivas para deshacerlas
            if (folioFullSinAnota.getDirecciones() != null && folioFullSinAnota.getDirecciones().size() > 0) {
                List lstDirecciones = folioFullSinAnota.getDirecciones();
                Iterator iteraDir = lstDirecciones.iterator();
                while (iteraDir.hasNext()) {
                    Direccion dir = (Direccion) iteraDir.next();
                    DireccionPk direccionPk = new DireccionPk();
                    direccionPk.idDireccion = dir.getIdDireccion();
                    direccionPk.idMatricula = dir.getIdMatricula();

                    DireccionEnhanced direccionEn = this.getDireccion(new DireccionEnhancedPk(direccionPk), pm);
                    pm.deletePersistent(direccionEn);
                }
            }

            //Se buscan las salvedades temporales para deshacerlas
            if (folio.getSalvedadesTMPs().size() > 0) {
                pm.deletePersistentAll(folio.getSalvedadesTMPs());
            }

            //Se buscan las salvedades definitivas para deshacerlas
            if (folioFullSinAnota.getSalvedades() != null && folioFullSinAnota.getSalvedades().size() > 0) {
                List lstSalvedades = folioFullSinAnota.getSalvedades();
                Iterator iteraSal = lstSalvedades.iterator();
                while (iteraSal.hasNext()) {
                    SalvedadFolio sal = (SalvedadFolio) iteraSal.next();

                    SalvedadFolioEnhanced salvedadFolioEn = SalvedadFolioEnhanced.enhance(sal);
                    pm.deletePersistent(salvedadFolioEn);
                }
            }

            //Se buscan las anotaciones temporales para deshacerlas
            if (folio.getAnotacionesTMPs().size() > 0) {

                Iterator iterAnota = folio.getAnotacionesTMPs().iterator();

                while (iterAnota.hasNext()) {

                    AnotacionTMP anota = (AnotacionTMP) iterAnota.next();
                    AnotacionTMPPk anotacionTMPPk = new AnotacionTMPPk();
                    anotacionTMPPk.idAnotacionTmp = anota.getIdAnotacionTmp();
                    anotacionTMPPk.idMatricula = anota.getIdMatricula();

                    AnotacionTMP anotacionTMP = this.getAnotacionTMPByID(anotacionTMPPk, pm);
                    List listaAnotaHijos = anotacionTMP.getAnotacionesPadreTMPs();
                    pm.deletePersistentAll(listaAnotaHijos);

                }
                pm.deletePersistentAll(folio.getAnotacionesTMPs());
            }

            // 	Se buscan las anotaciones definitivas para deshacerlas
            List lstAnotaciones = getAnotacionesFolioTMP(new FolioPk(folioFullSinAnota.getIdMatricula()));
            if (lstAnotaciones != null && lstAnotaciones.size() > 0) {

                List lstAnotaDef = new ArrayList();
                Iterator iterAnota = lstAnotaciones.iterator();
                while (iterAnota.hasNext()) {

                    Anotacion anota = (Anotacion) iterAnota.next();
                    AnotacionPk anotacionPk = new AnotacionPk();
                    anotacionPk.idAnotacion = anota.getIdAnotacion();
                    anotacionPk.idMatricula = anota.getIdMatricula();

                    AnotacionEnhanced anotacionEn = this.getAnotacionByID(new AnotacionEnhancedPk(anotacionPk), pm);
                    if (anotacionEn != null) {
                        List listaAnotaHijos = anotacionEn.getAnotacionesPadre();
                        pm.deletePersistentAll(listaAnotaHijos);
                        lstAnotaDef.add(anotacionEn);
                    }

                }
                pm.deletePersistentAll(lstAnotaDef);
            }

            //Se resetean las secuencias temporales
            folio.setLastIdAnotacionTMP(folio.getLastIdAnotacion());
            folio.setLastIdDireccionTMP(folio.getLastIdDireccion());
            folio.setLastIdSalvedadTMP(folio.getLastIdSalvedad());

            CirculoEnhancedPk cid = new CirculoEnhancedPk();
            cid.idCirculo = datos.getCirculo();
            cirEnh = zonaRegistralDAO.getCirculo(cid, pm);

            /*proceso para eliminar la slcitud relacionada con los folios */
            if (turno != null && turno.getSolicitud() != null && folio != null) {
                SolicitudFolioEnhanced solFol = this.getSolicitudFolio(turno.getSolicitud(), folio, pm);
                pm.deletePersistent(solFol);
            }

            pm.deletePersistent(folio);

            return true;
            //pm.currentTransaction().commit();
        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (DAOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            throw e;
        } catch (Exception e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }/*finally{
	    	pm.close();
	    }*/
    }

    /**
     * Deshace los cambios que están siendo aplicados a los folios del turno,
     * borra toda la información temporal
     *
     * @param datos
     * @param usuario
     * @return
     * @throws DAOException
     */
    public boolean deshacerCambiosTurno(TurnoPk turnoID, Usuario usuario)
            throws DAOException {

        PersistenceManager pm = AdministradorPM.getPM();
        boolean rta = false;

        FolioEnhanced folio;
        UsuarioEnhanced us;

        try {
            pm.currentTransaction().begin();

            //Validación de turno
            TurnoEnhanced turno = this.getTurnoByID(new TurnoEnhancedPk(turnoID), pm);

            if (turno == null) {
                throw new DAOException("El turno no existe");
            }

            //Validación de usuario
            UsuarioEnhancedPk uid = new UsuarioEnhancedPk();
            uid.idUsuario = usuario.getIdUsuario();

            us = this.getUsuarioByID(uid, pm);

            if (us == null) {
                throw new DAOException("El usuario especificado no existe: "
                        + uid.idUsuario);
            }

            SolicitudEnhanced sol = turno.getSolicitud();

            SolicitudFolioEnhanced solFol;

            //Se filtran las solicitudes folio, solo se itera sobre las definitivas
            List solicitudesFolio = this.getSolicitudesFolioDefinitivas(sol, pm);

            for (Iterator it = solicitudesFolio.iterator(); it.hasNext();) {
                solFol = (SolicitudFolioEnhanced) it.next();

                //Se valida el bloqueo del folio:
                this.validarBloqueoFolio(solFol.getFolio(), usuario, pm);

                //Se llama al servicio que deshace los cambios:
                this.deshacerCambiosFolioByTurno(solFol.getFolio(), us, turno, pm);

            }

            pm.currentTransaction().commit();
            rta = true;
        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (DAOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            throw e;
        } catch (Exception e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        return rta;
    }

    /**
     * Deshace los cambios que están siendo aplicados a los folios del turno,
     * borra toda la información temporal
     *
     * @param turnoID
     * @param usuario
     * @return
     * @throws DAOException
     */
    public boolean deshacerCambiosFolioByTurno(TurnoPk turnoID, Usuario usuario)
            throws DAOException {

        PersistenceManager pm = AdministradorPM.getPM();
        boolean rta = false;

        FolioEnhanced folio;
        UsuarioEnhanced us;

        try {
            pm.currentTransaction().begin();

            //Validación de turno
            TurnoEnhanced turno = this.getTurnoByID(new TurnoEnhancedPk(turnoID), pm);

            if (turno == null) {
                throw new DAOException("El turno no existe");
            }

            //Validación de usuario
            UsuarioEnhancedPk uid = new UsuarioEnhancedPk();
            uid.idUsuario = usuario.getIdUsuario();

            us = this.getUsuarioByID(uid, pm);

            if (us == null) {
                throw new DAOException("El usuario especificado no existe: "
                        + uid.idUsuario);
            }

            SolicitudEnhanced sol = turno.getSolicitud();

            SolicitudFolioEnhanced solFol;

            //Se filtran las solicitudes folio, solo se itera sobre las definitivas
            List solicitudesFolio = this.getSolicitudesFolioDefinitivas(sol, pm);

            for (Iterator it = solicitudesFolio.iterator(); it.hasNext();) {
                solFol = (SolicitudFolioEnhanced) it.next();

                if (solFol.getIdSolicitud().equals(turno.getSolicitud().getIdSolicitud())) {
                    //Se valida el bloqueo del folio:
                    this.validarBloqueoFolio(solFol.getFolio(), usuario, pm);

                    //Se llama al servicio que deshace los cambios:
                    this.deshacerCambiosFolioByTurno(solFol.getFolio(), us, turno, pm);
                }

            }

            pm.currentTransaction().commit();
            rta = true;
        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (DAOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            throw e;
        } catch (Exception e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        return rta;
    }

    /**
     * Deshace los cambios que están siendo aplicados a los folios del turno,
     * borra toda la información temporal
     *
     * @param datos
     * @param usuario
     * @return
     * @throws DAOException
     */
    public boolean deshacerCambiosCiudadanosTurno(TurnoPk turnoID, Usuario usuario)
            throws DAOException {

        PersistenceManager pm = AdministradorPM.getPM();
        boolean rta = false;

        FolioEnhanced folio;
        UsuarioEnhanced us;

        try {
            pm.currentTransaction().begin();

            //Validación de turno
            TurnoEnhanced turno = this.getTurnoByID(new TurnoEnhancedPk(turnoID), pm);

            if (turno == null) {
                throw new DAOException("El turno no existe");
            }

            //Validación de usuario
            UsuarioEnhancedPk uid = new UsuarioEnhancedPk();
            uid.idUsuario = usuario.getIdUsuario();

            us = this.getUsuarioByID(uid, pm);

            if (us == null) {
                throw new DAOException("El usuario especificado no existe: "
                        + uid.idUsuario);
            }

            Query query = pm.newQuery(CiudadanoTMP.class);
            query.declareParameters("String idWorkflow");
            query.setFilter("this.numeroRadicacion == idWorkflow");
            Collection col = (Collection) query.execute(turno.getIdWorkflow());
            for (Iterator iter = col.iterator(); iter.hasNext();) {
                CiudadanoTMP ciudadanotmp = (CiudadanoTMP) iter.next();
                pm.deletePersistent(ciudadanotmp);
            }
            pm.currentTransaction().commit();
            rta = true;
        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (DAOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            throw e;
        } catch (Exception e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        return rta;
    }

    /**
     * Retorna las solicitudes folio que son definitivas. Objetos persistentes.
     *
     * @param sol
     * @param pm
     * @return
     */
    protected List getSolicitudesFolioDefinitivas(SolicitudEnhanced sol, PersistenceManager pm) {
        Query query = pm.newQuery(SolicitudFolioEnhanced.class);
        query.declareParameters("SolicitudEnhanced sol");
        query.setFilter("this.solicitud==sol &&\n"
                + "this.folio.definitivo==true");

        List col = (List) query.execute(sol);
        return col;
    }

    /**
     * Deshace los cambios que están siendo aplicados al folio, borra toda la
     * información temporal
     *
     * @param datos
     * @param usuario
     * @return
     * @throws DAOException
     */
    protected boolean deshacerCambiosFolio(FolioEnhanced folio, UsuarioEnhanced usuario, TurnoEnhanced turno, PersistenceManager pm)
            throws DAOException {
        boolean rta = false;

        try {
            //Se busca si existe información en datos temporales
            //para deshacerla
            FolioDatosTMP dTMP;

            try {
                dTMP = folio.getDatosTMP();
            } catch (JDOObjectNotFoundException e) {
                dTMP = null;
            }

            if (dTMP != null) {
                pm.deletePersistent(dTMP);
                //folio.setDatosTMP(null);
            }

            //Se busca si se debe deshacer la complementacion
            ComplementacionTMP cTMP = folio.getComplementacionTMP();

            if (cTMP != null) {
                //pm.deletePersistent(cTMP);
                //TODO Mirar el borrado de COMPLEMENTACIONES temporales
                folio.setComplementacionTMP(null);
            }

            //Se buscan las direcciones temporales para deshacerlas
            if (folio.getDireccionesTMPs().size() > 0) {
                pm.deletePersistentAll(folio.getDireccionesTMPs());
            }

            //Se buscan las salvedades temporales para deshacerlas
            if (folio.getSalvedadesTMPs().size() > 0) {
                pm.deletePersistentAll(folio.getSalvedadesTMPs());
            }

            //Se buscan las anotaciones temporales para deshacerlas
            if (folio.getAnotacionesTMPs().size() > 0) {
                //Se llama al método que elimina anotaciones temporales:
                for (Iterator it = folio.getAnotacionesTMPs().iterator(); it.hasNext();) {
                    AnotacionTMP anotaTMP = (AnotacionTMP) it.next();
                    AnotacionTMP anotaToDelete = new AnotacionTMP();
                    anotaToDelete.setFolio(folio);
                    anotaToDelete.setIdAnotacionTmp(anotaTMP.getIdAnotacionTmp());
                    anotaToDelete.setToDelete(true);
                    this.actualizarAnotacionTMP(folio, anotaTMP, anotaToDelete, usuario, false, turno, pm);
                }
            }

            //Se resetean las secuencias temporales
            folio.setLastIdAnotacionTMP(folio.getLastIdAnotacion());
            folio.setLastIdDireccionTMP(folio.getLastIdDireccion());
            folio.setLastIdSalvedadTMP(folio.getLastIdSalvedad());

        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (DAOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            throw e;
        } catch (Exception e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }

        return rta;
    }

    /**
     * Deshace los cambios que están siendo aplicados al folio, borra toda la
     * información temporal
     *
     * @param datos
     * @param usuario
     * @return
     * @throws DAOException
     */
    protected boolean deshacerCambiosFolioByTurno(FolioEnhanced folio,
            UsuarioEnhanced usuario,
            TurnoEnhanced turno,
            PersistenceManager pm)
            throws DAOException {
        boolean rta = false;

        try {
            //Se busca si existe información en datos temporales
            //para deshacerla
            FolioDatosTMP dTMP;

            try {
                dTMP = folio.getDatosTMP();
            } catch (JDOObjectNotFoundException e) {
                dTMP = null;
            }

            if (dTMP != null) {
                pm.deletePersistent(dTMP);
                //folio.setDatosTMP(null);
            }

            //Se busca si se debe deshacer la complementacion
            ComplementacionTMP cTMP = folio.getComplementacionTMP();

            if (cTMP != null) {
                //pm.deletePersistent(cTMP);
                //TODO Mirar el borrado de COMPLEMENTACIONES temporales
                folio.setComplementacionTMP(null);
            }

            //Se buscan las direcciones temporales para deshacerlas
            if (folio.getDireccionesTMPs().size() > 0) {
                pm.deletePersistentAll(folio.getDireccionesTMPs());
            }

            //Se buscan las salvedades temporales para deshacerlas
            if (folio.getSalvedadesTMPs().size() > 0) {
                pm.deletePersistentAll(folio.getSalvedadesTMPs());
            }

            //Se buscan las anotaciones temporales para deshacerlas
            boolean restablecerSecuenciaTemporal = true;
            if (folio.getAnotacionesTMPs().size() > 0) {
                //Se llama al método que elimina anotaciones temporales:
                for (Iterator it = folio.getAnotacionesTMPs().iterator(); it.hasNext();) {
                    AnotacionTMP anotaTMP = (AnotacionTMP) it.next();

                    // Borrar sólo las anotaciones creadas con el turno
                    if (anotaTMP.getNumRadicacion() != null && anotaTMP.getNumRadicacion().equals(turno.getIdWorkflow())) {
                        AnotacionTMP anotaToDelete = new AnotacionTMP();
                        anotaToDelete.setFolio(folio);
                        anotaToDelete.setIdAnotacionTmp(anotaTMP.getIdAnotacionTmp());
                        anotaToDelete.setToDelete(true);
                        this.actualizarAnotacionTMP(folio, anotaTMP, anotaToDelete, usuario, false, turno, pm);
                    } else {
                        restablecerSecuenciaTemporal = false;
                    }
                }
            }

            //Se resetean las secuencias temporales
            if (restablecerSecuenciaTemporal) {
                folio.setLastIdAnotacionTMP(folio.getLastIdAnotacion());
            }
            folio.setLastIdDireccionTMP(folio.getLastIdDireccion());
            folio.setLastIdSalvedadTMP(folio.getLastIdSalvedad());

        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (DAOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            throw e;
        } catch (Exception e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }

        return rta;
    }

    /**
     *
     * @param folio
     * @param dTMP
     * @param pm
     * @return
     * @throws DAOException
     */
    protected void hacerDefinitivoFolioDatos(FolioEnhanced folio,
            FolioDatosTMP datos, PersistenceManager pm, TurnoEnhanced turno, boolean validarTurno, UsuarioEnhanced usuario)
            throws DAOException {

        Set set = new HashSet();

        try {
            //Se crea una copia del folio
            FolioEnhanced folioAuditoriaViejo = (FolioEnhanced) auditoria.clonarEnhanced(folio);

            /*
            * @author      :   Henry Gómez Rocha
            * @change      :   Comentareando en los siguientes metodos  la asignacion a null de los datos.
            * Caso Mantis  :   0004503
             */
            if (datos.getNupre() != null) {
                set.add(datos.getNumRadicaNupre());

                if (datos.getNumRadicaNupre() == null
                        || datos.getNumRadicaNupre().equals(turno.getIdWorkflow())) {
                    folio.setNupre(datos.getNupre());
                    //datos.setNupre(null);
                    //datos.setNumRadicaNupre(null);
                }
            }

            if (datos.getDeterminaInm() != null) {
                set.add(datos.getNumRadicaDeterminaInm());

                if (datos.getNumRadicaDeterminaInm() == null
                        || datos.getNumRadicaDeterminaInm().equals(turno.getIdWorkflow())) {
                    folio.setDeterminaInm(datos.getDeterminaInm());
                    //datos.setDeterminaInm(null);
                    //datos.setNumRadicaDeterminaInm(null);
                }
            }

            if (datos.getPrivMetros() != null) {
                set.add(datos.getNumRadicaPrivMetros());

                if (datos.getNumRadicaPrivMetros() == null
                        || datos.getNumRadicaPrivMetros().equals(turno.getIdWorkflow())) {
                    folio.setPrivMetros(datos.getPrivMetros());
                    //datos.setPrivMetros(null);
                    //datos.setNumRadicaPrivMetros(null);
                }
            }

            if (datos.getPrivCentimetros() != null) {
                set.add(datos.getNumRadicaPrivCentimetros());

                if (datos.getNumRadicaPrivCentimetros() == null
                        || datos.getNumRadicaPrivCentimetros().equals(turno.getIdWorkflow())) {
                    folio.setPrivCentimetros(datos.getPrivCentimetros());
                    //datos.setPrivCentimetros(null);
                    //datos.setNumRadicaPrivCentimetros(null);
                }
            }

            if (datos.getConsMetros() != null) {
                set.add(datos.getNumRadicaConsMetros());

                if (datos.getNumRadicaConsMetros() == null
                        || datos.getNumRadicaConsMetros().equals(turno.getIdWorkflow())) {
                    folio.setConsMetros(datos.getConsMetros());
                    //datos.setConsMetros(null);
                    //datos.setNumRadicaConsMetros(null);
                }
            }

            if (datos.getConsCentimetros() != null) {
                set.add(datos.getNumRadicaConsCentimetros());

                if (datos.getNumRadicaConsCentimetros() == null
                        || datos.getNumRadicaConsCentimetros().equals(turno.getIdWorkflow())) {
                    folio.setConsCentimetros(datos.getConsCentimetros());
                    //datos.setConsCentimetros(null);
                    //datos.setNumRadicaConsCentimetros(null);
                }
            }

            if (datos.getCoeficiente() != null) {
                set.add(datos.getNumRadicaCoeficiente());

                if (datos.getNumRadicaCoeficiente() == null
                        || datos.getNumRadicaCoeficiente().equals(turno.getIdWorkflow())) {
                    folio.setCoeficiente(datos.getCoeficiente());
                    //datos.setCoeficiente(null);
                    //datos.setNumRadicaCoeficiente(null);
                }
            }

            if (datos.getHectareas() != null) {
                set.add(datos.getNumRadicaHectareas());

                if (datos.getNumRadicaHectareas() == null
                        || datos.getNumRadicaHectareas().equals(turno.getIdWorkflow())) {
                    folio.setHectareas(datos.getHectareas());
                    //datos.setHectareas(null);
                    //datos.setNumRadicaHectareas(null);
                }
            }

            if (datos.getMetros() != null) {
                set.add(datos.getNumRadicaMetros());

                if (datos.getNumRadicaMetros() == null
                        || datos.getNumRadicaMetros().equals(turno.getIdWorkflow())) {
                    folio.setMetros(datos.getMetros());
                    //datos.setMetros(null);
                    //datos.setNumRadicaMetros(null);
                }
            }

            if (datos.getCentimetros() != null) {
                set.add(datos.getNumRadicaCentimetros());

                if (datos.getNumRadicaCentimetros() == null
                        || datos.getNumRadicaCentimetros().equals(turno.getIdWorkflow())) {
                    folio.setCentimetros(datos.getCentimetros());
                    //datos.setCentimetros(null);
                    //datos.setNumRadicaCentimetros(null);
                }
            }

            if (datos.getLindero() != null) {
                set.add(datos.getNumRadicaLindero());

                if (datos.getNumRadicaLindero() == null
                        || datos.getNumRadicaLindero().equals(turno.getIdWorkflow())) {
                    folio.setLindero(datos.getLindero());
                    //datos.setLindero(null);
                    //datos.setNumRadicaLindero(null);
                }
            }

            if (datos.getCodCatastral() != null) {
                set.add(datos.getNumRadicaCodCatastral());

                if (datos.getNumRadicaCodCatastral() == null
                        || datos.getNumRadicaCodCatastral().equals(turno.getIdWorkflow())) {
                    folio.setCodCatastral(datos.getCodCatastral());
                    //datos.setCodCatastral(null);
                    //datos.setNumRadicaCodCatastral(null);
                }
            }

            if (datos.getCodCatastralAnterior() != null) {
                set.add(datos.getNumRadicaCodCatastralAnterior());

                if (datos.getNumRadicaCodCatastralAnterior() == null
                        || datos.getNumRadicaCodCatastralAnterior().equals(turno.getIdWorkflow())) {
                    folio.setCodCatastralAnterior(datos.getCodCatastralAnterior());
                    //datos.setCodCatastralAnterior(null);
                    //datos.setCodCatastralAnterior(null);
                }
            }

            // bug: 3580
            if (datos.getRadicacion() != null) {
                set.add(datos.getNumRadicaRadicacion());

                if (datos.getNumRadicaRadicacion() == null
                        || datos.getNumRadicaRadicacion().equals(turno.getIdWorkflow())) {
                    folio.setRadicacion(datos.getRadicacion());
                    //datos.setRadicacion(null);
                    //datos.setNumRadicaRadicacion(null);
                }
            }

            if (datos.getFechaApertura() != null) {
                set.add(datos.getNumRadicaFechaApertura());

                if (datos.getNumRadicaFechaApertura() == null
                        || datos.getNumRadicaFechaApertura().equals(turno.getIdWorkflow())) {
                    folio.setFechaApertura(datos.getFechaApertura());
                    //datos.setFechaApertura(null);
                    //datos.setNumRadicaFechaApertura(null);
                }
            }

            if (datos.getEstado() != null) {
                set.add(datos.getNumRadicaEstado());

                if (datos.getNumRadicaEstado() == null
                        || datos.getNumRadicaEstado().equals(turno.getIdWorkflow())) {
                    if (datos.getEstado().getIdEstado() != folio.getEstado()
                            .getIdEstado()) {
                        //creacion en tabla histórica de estados de folio:
                        EstadoHistoriaEnhanced hist = new EstadoHistoriaEnhanced();
                        hist.setIdEstadoHistoria(String.valueOf(folio.getLastIdHistorialEstados()
                                + 1));
                        hist.setFolio(folio);
                        hist.setEstadoOrigen(folio.getEstado());
                        hist.setEstadoDestino(datos.getEstado());
                        hist.setComentario(datos.getComentarioCambioEstado());
                        hist.setComentarioAnterior(folio.getComentario());
                        hist.setUsuario(usuario);
                        hist.setFechaRegistro(new Date());
                        pm.makePersistent(hist);

                        folio.setLastIdHistorialEstados(folio.getLastIdHistorialEstados()
                                + 1);
                        folio.setEstado(datos.getEstado());
                        folio.setComentario(datos.getComentarioCambioEstado());
                        //datos.setEstado(null);
                        //datos.setNumRadicaEstado(null);
                    }
                }
            }

            if (datos.getTipoPredio() != null) {
                set.add(datos.getNumRadicaTipoPredio());

                if (datos.getNumRadicaTipoPredio() == null
                        || datos.getNumRadicaTipoPredio().equals(turno.getIdWorkflow())) {
                    folio.setTipoPredio(datos.getTipoPredio());
                    //datos.setTipoPredio(null);
                    //datos.setNumRadicaTipoPredio(null);
                }
            }

            if (datos.getZonaRegistral() != null) {
                set.add(datos.getNumRadicaTipoPredio());

                if (datos.getNumRadicaZonaRegistral() == null
                        || datos.getNumRadicaZonaRegistral().equals(turno.getIdWorkflow())) {
                    this.updateZonaRegistralFolio(folio, datos.getZonaRegistral(), usuario, pm);
                    //datos.setZonaRegistral(null);
                    //datos.setNumRadicaZonaRegistral(null);
                }
            }

            //Se hace la auditoría a los atributos que cambiaron
            auditoria.addAuditoria(folio, folioAuditoriaViejo, usuario, pm);

            //Si el id del workflow del turno es igual a los numeros de radicacion se deja borrar	
            if (turno != null) {
                if (set.size() == 1 && set.contains(turno.getIdWorkflow())) {
                    pm.deletePersistent(datos);
                    //folio.setDatosTMP(null);
                } else {
                    pm.makePersistent(datos);
                    folio.setDatosTMP(datos);
                }
            } else {
                /**
                 * @author : Julio Alcazar
                 * @change : Se permite eliminar temporales en el caso de que se
                 * modifique los datos sin utilizar folio. Caso Mantis :
                 * 0008036: Acta - Requerimiento No 234 - Error Pantallas
                 * Administrativas - Reabrir Folios
                 */
                if (set.size() == 1 && set.contains(null)) {
                    pm.deletePersistent(datos);
                } else {
                    pm.makePersistent(datos);
                    folio.setDatosTMP(datos);
                }
            }
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }
    }

    /**
     * Actualiza la zona registral del folio
     *
     * @param folio
     * @param zonaRegistral
     * @param pm
     */
    private void updateZonaRegistralFolio(FolioEnhanced folio, ZonaRegistralEnhanced zonaRegistral, UsuarioEnhanced usu, PersistenceManager pm) throws DAOException {
        VersantPersistenceManager jdoPM = (VersantPersistenceManager) pm;
        Connection connection = null;
        connection = jdoPM.getJdbcConnection(null);

        String sql = "UPDATE SIR_NE_FOLIO SET ID_ZONA_REGISTRAL= '" + zonaRegistral.getIdZonaRegistral() + "' "
                + " WHERE ID_MATRICULA='" + folio.getIdMatricula() + "' AND ID_ZONA_REGISTRAL = '" + folio.getZonaRegistral().getIdZonaRegistral() + "' ";

        String sql2 = "INSERT INTO SIR_NE_AUDITORIA (ID_AUDITORIA, DTRA_NOMBRE_TABLA, DTRA_NOMBRE_COLUMNA, DTRA_ID1, DTRA_ID2, DTRA_ID3, DTRA_ID4, DTRA_ID5, ID_USUARIO, DTRA_FECHA, DTRA_OPERACION, DTRA_VALOR_ID1, DTRA_VALOR_ID2, DTRA_VALOR_ID3, DTRA_VALOR_ID4, DTRA_VALOR_ID5, DTRA_VALOR_ANTERIOR) "
                + " VALUES (SEQ_AUDITORIA_NEGOCIO.nextval, 'SIR_NE_FOLIO', 'ID_ZONA_REGISTRAL', 'ID_MATRICULA', 'ID_ZONA_REGISTRAL', null, null, null, " + usu.getIdUsuario() + ", sysdate, 'UPDATE', '" + folio.getIdMatricula() + "', '" + folio.getZonaRegistral().getIdZonaRegistral() + "', null, null, null, '" + folio.getZonaRegistral().getIdZonaRegistral() + "')";

        Statement s = null;
        Statement s2 = null;
        try {
            s = connection.createStatement();
            s.executeUpdate(sql);
            s2 = connection.createStatement();
            s2.executeUpdate(sql2);
        } catch (SQLException e) {
            throw new DAOException("Error SQL: " + e, e);
        } finally {

            try {
                if (s != null) {
                    s.close();
                }
                if (s2 != null) {
                    s2.close();
                }
                if (connection != null) {
                    connection.close();
                }
            } catch (SQLException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e);
            }

        }
    }

    private List ordenarDirTMP(List Direcciones) {
        List lstDireccionesUnModifi = new ArrayList();
        lstDireccionesUnModifi.addAll(Direcciones);
        List lstDirecciones = new ArrayList();

        int i = 0;
        boolean swSalir = false;
        while (i <= 50 && !swSalir) {
            for (int j = 0; j < lstDireccionesUnModifi.size(); j++) {
                DireccionTMP dirJ = (DireccionTMP) lstDireccionesUnModifi.get(j);
                if (dirJ != null && dirJ.getOrden() != null
                        && i == dirJ.getOrden().intValue() && !dirJ.isToDelete()) {
                    lstDirecciones.add(dirJ);
                    lstDireccionesUnModifi.remove(j);
                } else if (dirJ != null && dirJ.getIdDireccionTmp() != null
                        && i == Integer.valueOf(dirJ.getIdDireccionTmp()).intValue() && !dirJ.isToDelete()) {
                    lstDirecciones.add(dirJ);
                    lstDireccionesUnModifi.remove(j);
                }
            }
            if (lstDirecciones.size() == Direcciones.size()) {
                swSalir = true;
            }
            i = i + 1;
        }

        if (lstDireccionesUnModifi != null && !lstDireccionesUnModifi.isEmpty()) {
            lstDireccionesUnModifi.addAll(lstDirecciones);
            return lstDireccionesUnModifi;
        } else {
            return lstDirecciones;
        }
    }

    /**
     *
     * @param folio
     * @param cTMP
     * @param pm
     * @throws DAOException
     */
    protected void hacerDefinitivoComplementacion(FolioEnhanced folio,
            ComplementacionTMP datos, UsuarioEnhanced usuario, String idTurno, PersistenceManager pm)
            throws DAOException {
        try {
            //Se revisa si se va a insertar una complementación
            //o se va a actualizar
            ComplementacionEnhancedPk oid = new ComplementacionEnhancedPk();
            oid.idComplementacion = datos.getIdComplementacionTmp();

            ComplementacionEnhanced aux = this.getComplementacion(oid, pm);

            if (aux == null) {
                //inserción
                ComplementacionEnhanced nuevaComp = datos.getDefinitivo();
                pm.makePersistent(nuevaComp);
                folio.setComplementacion(nuevaComp);
            } else {
                //actualización

                //Puede que haya encontrado la complementación definitiva pero aún no está asociada:
                if (folio.getComplementacion() == null) {
                    folio.setComplementacion(aux);
                } else {
                    //La complementación puede ser un delta a la actual o una nueva asociación con otra:

                    if (!aux.getIdComplementacion().equals(folio.getComplementacion().getIdComplementacion())) {
                        //Nueva asociación:
                        folio.setComplementacion(aux);
                    } else {
                        //Modificación a la actual:
                        ComplementacionEnhanced comAuditoriaViejo = (ComplementacionEnhanced) auditoria.clonarEnhanced(aux);

                        aux.setComplementacion(datos.getComplementacion());

                        //Se hace la auditoría a los atributos que cambiaron
                        auditoria.addAuditoria(aux, comAuditoriaViejo, usuario, pm);
                        /**
                         * @Author Carlos Torres
                         * @Mantis 13176
                         * @Chaged
                         */
                        if (idTurno != null) {
                            co.com.iridium.generalSIR.negocio.auditoria.AuditoriaSIR auditoriaSir = new co.com.iridium.generalSIR.negocio.auditoria.AuditoriaSIR();
                            try {
                                auditoriaSir.guardarAuditoriaComplementacion(aux, comAuditoriaViejo, idTurno);
                            } catch (GeneralSIRException exp) {
                                Log.getInstance().error(JDOGenieFolioDAO.class, exp.getMessage());
                            }
                        }
                    }

                }

            }

            //TODO Permitir que se pueda eliminar la complementacion temporal
            //dependiendo si existen folios asociados a la misma complementacion
            //pm.deletePersistent(datos);
            folio.setComplementacionTMP(null);
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }
    }

    /**
     *
     * @param folio
     * @param pm
     * @throws DAOException
     */
    protected void hacerDefinitivasDirecciones(FolioEnhanced folio,
            UsuarioEnhanced usuario, String turno, PersistenceManager pm)
            throws DAOException {
        try {
            DireccionTMP dir;
            DireccionEnhanced direccion;
            List lstDirecciones = ordenarDirTMP(folio.getDireccionesTMPs());
            /**
             * @Author Carlos Torres
             * @Mantis 13176
             * @Chaged
             */
            co.com.iridium.generalSIR.negocio.auditoria.AuditoriaSIR auditoriaSir = new co.com.iridium.generalSIR.negocio.auditoria.AuditoriaSIR();
            for (Iterator itr = lstDirecciones.iterator(); itr.hasNext();) {
                dir = (DireccionTMP) itr.next();
                if (dir.isToDelete()) {
                    DireccionEnhancedPk dirID = new DireccionEnhancedPk();
                    dirID.idDireccion = dir.getIdDireccionTmp();
                    dirID.idMatricula = dir.getIdMatricula();

                    DireccionEnhanced dirToDelete = this.getDireccion(dirID, pm);

                    if (dirToDelete == null) {
                        throw new DAOException("No encontró la dirección definitiva a borrar con ID: " + dirID.idDireccion);
                    }
                    //Se hace la auditoría a los atributos que cambiaron
                    auditoria.addAuditoria(null, dirToDelete, usuario, pm);
                    /**
                     * @Author Carlos Torres
                     * @Mantis 13176
                     * @Chaged
                     */
                    if (turno != null) {
                        try {
                            auditoriaSir.guardarAuditoriaDireccion(null, dirToDelete, turno);
                        } catch (GeneralSIRException ex) {
                            Log.getInstance().error(JDOGenieFolioDAO.class, ex.getMessage());
                        }
                    }

                    //Se elimina la dirección
                    pm.deletePersistent(dirToDelete);
                    VersantPersistenceManager pm2 = (VersantPersistenceManager) pm;
                    pm2.flush();

                    //la matricula pendiente por ordenar direcciones en definitiva
                    matriculasCambioDireccion = dirToDelete.getIdMatricula();
                } else {
                    direccion = dir.getDefinitivo();
                    direccion.setUsuarioCreacion(usuario);

                    //Se cambia la política de direcciones,
                    //solo se tiene en cuenta el secuancial definitivo
                    direccion.setIdDireccion(null);
                    //ordenar lista

                    this.addDireccionToFolio(folio, direccion, pm, dir.getOrden());
                    pm.makePersistent(direccion);
                    //la matricula pendiente por ordenar direcciones en definitiva
                    matriculasCambioDireccion = direccion.getIdMatricula();
                    /**
                     * @Author Carlos Torres
                     * @Mantis 13176
                     * @Chaged
                     */
                    if (turno != null) {
                        try {
                            auditoriaSir.guardarAuditoriaDireccion(direccion, null, turno);
                        } catch (GeneralSIRException ex) {
                            Log.getInstance().error(JDOGenieFolioDAO.class, ex.getMessage());
                        }
                    }
                }

            }

            pm.deletePersistentAll(folio.getDireccionesTMPs());
            folio.setLastIdDireccion(folio.getLastIdDireccionTMP());
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }
    }

    private String matriculasCambioDireccion = "";

    /**
     * Método encargado de actualizar de manera ordenada la tabla de direcciones
     * definitivas de una matricula.
     *
     * @author Diego Alejandro Hernandez Uribe
     * @throws DAOException
     */
    private void ordenaDireccionesDefinitivas() throws DAOException {
        //Si matriculasCambioDireccion es vacio indica que no se agregaron/quitaron direcciones.
        if (!"".equals(matriculasCambioDireccion)) {
            PersistenceManager pm = AdministradorPM.getPM();
            pm.currentTransaction().begin();
            VersantPersistenceManager jdoPM = (VersantPersistenceManager) pm;

            ResultSet rs = null;
            PreparedStatement pst = null;
            PreparedStatement pst1 = null;
            Connection connection = null;

            //SELECT realizado a la tabla SIR_NE_DIRECCION para cargar las direcciones
            //de una matricula.
            String sql = "SELECT id_direccion,id_matricula FROM SIR_NE_DIRECCION "
                    + "WHERE id_matricula = ? "
                    + "ORDER BY id_matricula ";

            try {
                connection = jdoPM.getJdbcConnection(null);
                pst = connection.prepareStatement(sql);
                pst.setString(1, matriculasCambioDireccion);

                rs = pst.executeQuery();

                //List en el que se cargaran los resultados de la consulta.
                //Este será un List<String[]> en el que el String[] tendrá
                //2 posiciones [0] = id_direccion, [1] = id_matricula
                List lstIdsDirecciones = new ArrayList();
                while (rs.next()) {
                    lstIdsDirecciones.add(new String[]{rs.getString(1), rs.getString(2)});
                }

                for (int i = 0; i < lstIdsDirecciones.size(); i++) {
                    String[] vectStrI = (String[]) lstIdsDirecciones.get(i);
                    for (int j = (i + 1); j < lstIdsDirecciones.size(); j++) {
                        if (vectStrI != null && vectStrI.length > 0) {
                            int idStrI = Integer.valueOf(vectStrI[0]).intValue();
                            String[] vectStrJ = (String[]) lstIdsDirecciones.get(j);
                            int idStrJ = Integer.valueOf(vectStrJ[0]).intValue();
                            if (idStrI > idStrJ) {
                                String[] AucStrI = new String[]{vectStrI[0], vectStrI[1]};
                                String[] AucStrJ = new String[]{vectStrJ[0], vectStrJ[1]};
                                lstIdsDirecciones.set(i, AucStrJ);
                                lstIdsDirecciones.set(j, AucStrI);
                                //actualizamos i // que mierda tan carechimba
                                vectStrI = (String[]) lstIdsDirecciones.get(i);
                            }
                        }
                    }
                }

                //Variable que tendra el id ordenada, la cual sera actualizada en la tabla.
                int contDir = 1;

                //Se recorre la lista de direcciones y se actualiza el id_direccion de
                //cada una de estas
                for (int i = 0; i < lstIdsDirecciones.size(); i++) {

                    String[] dirMat = (String[]) lstIdsDirecciones.get(i);
                    String mat = dirMat[1];

                    String sb = "UPDATE SIR_NE_DIRECCION "
                            + "set id_direccion = ? "
                            + //contDir+"' "+
                            "where id_matricula = ? "
                            +//mat+"' " +
                            "and id_direccion = ? "; //+dirMat[0]+"' " ;

                    pst1 = connection.prepareStatement(sb);
                    pst1.setString(1, "" + contDir);
                    pst1.setString(2, mat);
                    pst1.setString(3, dirMat[0]);

                    contDir++;
                    pst1.executeUpdate();
                }
                pm.currentTransaction().commit();
            } catch (SQLException e) {
                if (pm.currentTransaction().isActive()) {
                    pm.currentTransaction().rollback();
                }
                throw new DAOException("Error SQL: " + e, e);
            } finally {
                if (connection != null) {
                    try {
                        if (rs != null) {
                            rs.close();
                        }
                        if (pst != null) {
                            pst.close();
                        }
                        if (pst1 != null) {
                            pst1.close();
                        }
                        if (connection != null) {
                            connection.close();
                        }

                    } catch (SQLException e1) {
                        Log.getInstance().error(JDOGenieFolioDAO.class, e1.getMessage());
                    }
                }
                //se le asigna vacio a la variable.
                matriculasCambioDireccion = "";
                pm.close();
            }
        }
    }

    /**
     * Este método actualiza la fecha de apertura del folio en la tabla
     * SIR_REL_REG_FOLIO, en el momento en que el folio se hizó definitivo.
     *
     * @param folio
     * @param pm
     * @throws DAOException
     */
    protected void actualizarTurnoFolio(FolioEnhanced folio,
            UsuarioEnhanced usuario, TurnoEnhanced turno, boolean validarTurno,
            PersistenceManager pm) throws DAOException {
        try {
            if (validarTurno) {
                if (turno == null) {
                    throw new DAOException("EL turno no puede ser nulo");
                }
            }

            if (folio.getTurnosFolios() != null && folio.getTurnosFolios().size() > 0) {

                for (Iterator itr = folio.getTurnosFolios().iterator(); itr.hasNext();) {
                    TurnoFolioEnhanced turnoFolio = (TurnoFolioEnhanced) itr.next();

                    if (turnoFolio.getAnio().equals(turno.getAnio())
                            && turnoFolio.getIdCirculo().equals(turno.getIdCirculo())
                            && turnoFolio.getIdProceso() == turno.getIdProceso()
                            && turnoFolio.getIdTurno().equals(turno.getIdTurno())) {
                        turnoFolio.setFechaApertura(new Date());
                        pm.makePersistent(turnoFolio);
                    }

                }

            }

        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }
    }

    /**
     *
     * @param folio
     * @param pm
     * @throws DAOException
     */
    protected void hacerDefinitivasSalvedades(FolioEnhanced folio,
            UsuarioEnhanced usuario, TurnoEnhanced turno, boolean validarTurno, PersistenceManager pm)
            throws DAOException {
        try {
            if (validarTurno) {
                if (turno == null) {
                    throw new DAOException("EL turno no puede ser nulo");
                }
            }
            SalvedadFolioTMP sal;
            SalvedadFolioEnhanced salvedad;

            for (Iterator itr = folio.getSalvedadesTMPs().iterator();
                    itr.hasNext();) {
                sal = (SalvedadFolioTMP) itr.next();
                salvedad = sal.getDefinitivo();

                //Se asocia el usuario creador
                salvedad.setUsuarioCreacion(usuario);

                //Se añade al folio
                this.addSalvedadToFolio(folio, salvedad, pm);

                //Se crea la asociación con el turno
                if (turno != null) {
                    TurnoSalvedadFolioEnhanced tsf = new TurnoSalvedadFolioEnhanced();
                    tsf.setTurno(turno);
                    tsf.setSalvedad(salvedad);
                    salvedad.addTurnoSalvedadFolio(tsf);
                    salvedad.setNumRadicacion(turno.getIdWorkflow());
                }

                pm.makePersistent(salvedad);
            }

            pm.deletePersistentAll(folio.getSalvedadesTMPs());
            folio.setLastIdSalvedad(folio.getLastIdSalvedadTMP());
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }
    }

    /**
     *
     * @param folio
     * @param datos
     * @param pm
     * @return
     * @throws DAOException
     */
    protected boolean addSalvedadToFolio(FolioEnhanced folio,
            SalvedadFolioEnhanced datos, PersistenceManager pm)
            throws DAOException {
        boolean rta = false;

        try {
            if (datos.getIdSalvedad() == null) {
                datos.setIdSalvedad(String.valueOf(folio.getLastIdSalvedad()
                        + 1));
                folio.setLastIdSalvedadTMP(folio.getLastIdSalvedad() + 1);
            }

            datos.setFolio(folio);
            rta = true;
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }

        return rta;
    }

    /**
     *
     * @param folio
     * @param pm
     * @throws DAOException
     */
    protected void hacerDefinitivasAnotaciones(FolioEnhanced folio,
            UsuarioEnhanced usuario, TurnoEnhanced turno, boolean validarTurno, PersistenceManager pm)
            throws DAOException {
        try {
            if (validarTurno) {
                if (turno == null) {
                    throw new DAOException("EL turno no puede ser nulo");
                }
            }
            /**
             * @Author Carlos Torres
             * @Mantis 13176
             * @Chaged
             */
            co.com.iridium.generalSIR.negocio.auditoria.AuditoriaSIR auditoriaSir = new co.com.iridium.generalSIR.negocio.auditoria.AuditoriaSIR();
            AnotacionTMP anotaTMP;
            AnotacionEnhanced anotacion;
            List cache;
            //int anotapadresize=0;

            List anotacionesTmpDerivadas = new ArrayList();
            List anotacionesTemporales = new ArrayList();

            anotacionesTemporales = folio.getAnotacionesTMPs();

            for (Iterator itr = anotacionesTemporales.iterator();
                    itr.hasNext();) {
                cache = new ArrayList();
                anotaTMP = (AnotacionTMP) itr.next();

                //Se revisa si la anotación se debe actualizar
                //o insertar:
                AnotacionEnhancedPk anid = new AnotacionEnhancedPk();
                anid.idAnotacion = anotaTMP.getIdAnotacionTmp();
                anid.idMatricula = anotaTMP.getIdMatricula();

                AnotacionEnhanced aned = this.getAnotacionByID(anid, pm);

                if (aned == null) {

                    //Se debe agregar la anotación, sólo si esta coincide con el turno (Caso calificación)
                    //ver bug 3254, o si la anotación fue creada con el turno en cuetión (Caso herencia y anotaciones)
                    //de antiguo sistema o correcciones con diferentes numeros de radicación, o si NO se debe
                    //validar el turno (Caso creación folio directa por pantalla adminisrativa)
                    boolean flagAgregarAnotacion = false;

                    if (!validarTurno) {
                        flagAgregarAnotacion = true;
                    } else {
                        if ((turno.getIdWorkflow().equals(anotaTMP.getNumRadicacion()))
                                || (turno.getIdWorkflow().equals(anotaTMP.getIdWorkflow()))) {
                            flagAgregarAnotacion = true;
                        }
                    }

                    if (flagAgregarAnotacion) {
                        anotacion = anotaTMP.getDefinitivo(cache);
                        //Se setea el usuario creador definitivo
                        anotacion.setUsuarioCreacion(usuario);

                        //No quitar esto por favor, Es para que se asigne automáticamente el ID
                        //en addAnotacionToFolio.
                        //Se quita para que se asigne el identificador de la anotacion
                        //correspondiente a la anotacion temporal.
                        //anotacion.setIdAnotacion(null);
                        this.addAnotacionToFolio(folio, anotacion, usuario, turno, validarTurno, pm);
                        /* JAlcaza caso Mantis 03996 Acta - Requerimiento No 186 - Fechas de radicación y documento turnos de correcciones
                          * No se permitia la actualización de datos del documento en anotaciones q
                         */
                        DocumentoTMP docTMP = anotaTMP.getDocumentoTMP();

                        if (docTMP != null) {
                            this.hacerDefinitivoDocumento(aned, docTMP, usuario, pm, turno.getIdWorkflow());
                        }
                        pm.makePersistent(anotacion);
                        AnotacionTMP canceladoraTMP = this.getAnotacionCanceladoraTMP(anotaTMP, pm);
                        if (canceladoraTMP != null) {

                            CancelacionTMP cancelacionTMP = new CancelacionTMP();
                            cancelacionTMP.setCanceladaDef(anotacion);
                            CancelacionTMP toUpdate = this.getCancelacionTMP(cancelacionTMP,
                                    canceladoraTMP, pm);

                            if (toUpdate != null) {
                                toUpdate.setAnotacionTemporal(false);
                                toUpdate.setCanceladaTmp(null);
                                toUpdate.setCanceladaDef(anotacion);
                            }
                        }

                        if (turno != null && turno.getIdFase() != null && (turno.getIdFase().equals("ANT_CREACION_FOLIO"))
                                && (turno.getIdProceso() == 6 || turno.getIdProceso() == 3 || turno.getIdProceso() == 1)) {

                            List listaAnotaPadre = anotaTMP.getAnotacionesPadreTMPs();
                            if (listaAnotaPadre != null && listaAnotaPadre.size() > 0) {
                                // borrar persistencia y volver a agregar datos temporales
                                Iterator iterAnotaLst = listaAnotaPadre.iterator();
                                List lstAnotaB = new ArrayList();
                                List lstFolioDeriveB = new ArrayList();
                                while (iterAnotaLst.hasNext()) {
                                    FolioDerivadoTMP folioDerivePadreB = (FolioDerivadoTMP) iterAnotaLst.next();
                                    lstFolioDeriveB.add(folioDerivePadreB);

                                    AnotacionTMPPk anotacionTMPPkFD = new AnotacionTMPPk();
                                    anotacionTMPPkFD.idAnotacionTmp = folioDerivePadreB.getIdAnotacionTmp();
                                    anotacionTMPPkFD.idMatricula = folioDerivePadreB.getIdMatricula();
                                    AnotacionTMP anotacionTMPFD = this.getAnotacionTMPByIDSinAnotaFolio(anotacionTMPPkFD, pm);

                                    /*pm.deletePersistent(anotacionTMPFD);*/
                                    lstAnotaB.add(anotacionTMPFD);

                                }
                                if (lstFolioDeriveB.size() > 0) {
                                    pm.deletePersistentAll(lstFolioDeriveB);
                                    pm.deletePersistentAll(lstAnotaB);
                                    VersantPersistenceManager pm2 = (VersantPersistenceManager) pm;
                                    pm2.flush();
                                }

                            }
                        }

                        List listaAnotaHijos = anotaTMP.getAnotacionesHijosTMPs();
                        List lstAnotaHB = new ArrayList();
                        if (listaAnotaHijos != null && listaAnotaHijos.size() > 0) {
                            // borrar persistencia y volver a agregar datos temporales
                            Iterator iterAnotaLst = listaAnotaHijos.iterator();
                            while (iterAnotaLst.hasNext()) {
                                FolioDerivadoTMP folioDeriveHijoB = (FolioDerivadoTMP) iterAnotaLst.next();

                                AnotacionTMPPk anotacionTMPPkFD = new AnotacionTMPPk();
                                anotacionTMPPkFD.idAnotacionTmp = folioDeriveHijoB.getIdAnotacion1Tmp();
                                anotacionTMPPkFD.idMatricula = folioDeriveHijoB.getIdMatricula1();
                                AnotacionTMP anotacionTMPFD = this.getAnotacionTMPByIDSinAnotaFolio(anotacionTMPPkFD, pm);
                                lstAnotaHB.add(anotacionTMPFD);

                            }
                        }
                        // pm.deletePersistent(anotaTMP);
                        if (turno != null && turno.getIdFase() != null && turno.getIdFase().equals("ANT_REVISION")
                                && turno.getIdProceso() == 1 && !lstAnotaHB.isEmpty()) {
                            pm.deletePersistentAll(lstAnotaHB);
                        }
                    }

                } else {
                    //Se debe actualizar la anotacion
                    //Se cambian los datos básicos

                    //Se crea una copia de la anotación
                    AnotacionEnhanced anotacionAuditoriaViejo = (AnotacionEnhanced) auditoria.clonarEnhanced(aned);

                    if (anotaTMP.getEstado() != null) {
                        aned.setEstado(anotaTMP.getEstado());
                    }

                    if (anotaTMP.getNaturalezaJuridica() != null) {
                        aned.setNaturalezaJuridica(anotaTMP.getNaturalezaJuridica());
                    }

                    if (anotaTMP.getTipoAnotacion() != null) {
                        aned.setTipoAnotacion(anotaTMP.getTipoAnotacion());
                    }

                    if (anotaTMP.getOrden() != null) {
                        aned.setOrden(anotaTMP.getOrden());
                    }

                    if (anotaTMP.getEspecificacion() != null) {
                        aned.setEspecificacion(anotaTMP.getEspecificacion());
                    }

                    if (anotaTMP.getComentario() != null) {
                        aned.setComentario(anotaTMP.getComentario());
                    }

                    if (anotaTMP.getFechaRadicacion() != null) {
                        aned.setFechaRadicacion(anotaTMP.getFechaRadicacion());
                    }

                    if (anotaTMP.getValor() != aned.getValor()) {
                        aned.setValor(anotaTMP.getValor());
                    }

                    //Se busca si se debe hacer definitivo el documento
                    DocumentoTMP docTMP = anotaTMP.getDocumentoTMP();

                    if (docTMP != null) {
                        this.hacerDefinitivoDocumento(aned, docTMP, usuario, pm, (turno != null) ? turno.getIdWorkflow() : null);
                    }

                    if (anotaTMP.getNumRadicacion() != null) {
                        boolean crearNuevaRelacion = true;
                        //Toca cambiar la asociación con turno (si existe)
                        if (!aned.getTurnoAnotacions().isEmpty()) {
                            TurnoAnotacionEnhanced turnoAnota = (TurnoAnotacionEnhanced) aned.getTurnoAnotacions().get(0);
                            if (!anotaTMP.getNumRadicacion().equals(turnoAnota.getTurno().getIdWorkflow())) {
                                pm.deletePersistent(turnoAnota);
                                //Ejecutamos el borrado
                                VersantPersistenceManager pm2 = (VersantPersistenceManager) pm;
                                pm2.flush();
                            } else {
                                crearNuevaRelacion = false;
                            }
                        }

                        if (crearNuevaRelacion) {
                            TurnoEnhanced turnoAux = this.getTurnoByWFId(anotaTMP.getNumRadicacion(), pm);
                            if (turnoAux != null) {
                                TurnoAnotacionEnhanced tae = new TurnoAnotacionEnhanced();
                                tae.setTurno(turnoAux);
                                tae.setAnotacion(aned);
                                pm.makePersistent(tae);
                            }
                        }
                        aned.setNumRadicacion(anotaTMP.getNumRadicacion());
                    }

                    //Miramos los ciudadanos asociados para ver si se deben
                    //agregar o borrar
                    AnotacionCiudadanoTMP ace = new AnotacionCiudadanoTMP();

                    for (Iterator it = anotaTMP.getAnotacionesCiudadanoTMPs()
                            .iterator(); it.hasNext();) {
                        ace = (AnotacionCiudadanoTMP) it.next();

                        //Se revisa si se debe crear o actualizar (borrar)
                        AnotacionCiudadanoEnhancedPk acid = new AnotacionCiudadanoEnhancedPk();
                        acid.idAnotacion = ace.getIdAnotacionTmp();
                        acid.idCiudadano = ace.getIdCiudadano();
                        acid.idMatricula = ace.getIdMatricula();
                        acid.rolPersona = ace.getRolPersona();

                        AnotacionCiudadanoEnhanced toUpdate = this.getAnotacionCiudadano(acid,
                                pm);

                        if (toUpdate != null) {
                            AnotacionCiudadanoEnhanced viejo = (AnotacionCiudadanoEnhanced) auditoria.clonarEnhanced(toUpdate);
                            //La anotacionCiudadano se debe actualizar
                            //Se verifica si se tiene que borrar la anotacionCiudadano
                            if (ace.isToDelete()) {
                                //Se hace la auditoría a los atributos que cambiaron
                                auditoria.addAuditoria(null, toUpdate, usuario, pm);

                                toUpdate.getAnotacion()
                                        .removeAnotacionesCiudadano(toUpdate);
                                pm.deletePersistent(toUpdate);
                                /**
                                 * @Author Carlos Torres
                                 * @Mantis 13176
                                 * @Chaged
                                 */
                                if (turno != null) {
                                    try {
                                        auditoriaSir.guardarAuditoriaAnotacionCiudadano(null, viejo, turno.getIdWorkflow());
                                    } catch (GeneralSIRException exc) {
                                        Log.getInstance().error(JDOGenieFolioDAO.class, exc.getMessage());
                                    }
                                }

                            } else if (ace.isToUpdate()) {
                                toUpdate.setMarcaPropietario(ace.getMarcaPropietario());
                                toUpdate.setParticipacion(ace.getParticipacion());
                                /**
                                 * @Author Carlos Torres
                                 * @Mantis 13176
                                 * @Chaged
                                 */
                                if (turno != null) {
                                    try {
                                        auditoriaSir.guardarAuditoriaAnotacionCiudadano(toUpdate, viejo, turno.getIdWorkflow());
                                    } catch (GeneralSIRException exc) {
                                        Log.getInstance().error(JDOGenieFolioDAO.class, exc.getMessage());
                                    }
                                }
                            } else {
                                toUpdate.getAnotacion().removeAnotacionesCiudadano(toUpdate);
                                CiudadanoEnhanced ciudOld = (CiudadanoEnhanced) auditoria.clonarEnhanced(toUpdate.getCiudadano());
                                /**
                                 * @Author Carlos Torres
                                 * @Mantis 13176
                                 * @Chaged
                                 */
                                AnotacionCiudadanoEnhanced acold = (AnotacionCiudadanoEnhanced) auditoria.clonarEnhanced(toUpdate);
                                pm.deletePersistent(toUpdate);
                                VersantPersistenceManager pm2 = (VersantPersistenceManager) pm;
                                pm2.flush();
                                AnotacionCiudadanoEnhanced acToInsert = ace.getDefinitivo();
                                this.addAnotacionCiudadanoToAnotacion(aned,
                                        acToInsert, pm);
                                pm.makePersistent(acToInsert);
                                /**
                                 * Desarrollador: Diana Lora Mantis 0008623:
                                 * Acta - Requerimiento No 030_151 - Error al
                                 * Modificar Ciudadanos en Temporal y los
                                 * cambios no se hacen definitivos.
                                 */
                                pm2.flush();
                                /**
                                 * @Author Carlos Torres
                                 * @Mantis 13176
                                 * @Chaged
                                 */
                                if (turno != null) {
                                    try {
                                        auditoriaSir.guardarAuditoriaAnotacionCiudadano(acToInsert, acold, turno.getIdWorkflow());
                                        auditoriaSir.guardarAuditoriaCiudadano(acToInsert.getCiudadano(), ciudOld, turno.getIdWorkflow());
                                    } catch (GeneralSIRException exc) {
                                        Log.getInstance().error(JDOGenieFolioDAO.class, exc.getMessage());
                                    }
                                }
                            }
                        } else {
                            //Se tiene que insertar la anotacionCiudadano
                            AnotacionCiudadanoEnhanced acToInsert = ace.getDefinitivo();
                            this.addAnotacionCiudadanoToAnotacion(aned,
                                    acToInsert, pm);
                            pm.makePersistent(acToInsert);
                            /**
                             * @Author Carlos Torres
                             * @Mantis 13176
                             * @Chaged
                             */
                            if (turno != null) {
                                try {
                                    auditoriaSir.guardarAuditoriaAnotacionCiudadano(acToInsert, null, turno.getIdWorkflow());
                                } catch (GeneralSIRException exc) {
                                    Log.getInstance().error(JDOGenieFolioDAO.class, exc.getMessage());
                                }
                            }
                        }
                    }

                    //Miramos las salvedades de la anotacion para ver si se deben
                    //insertar, actualizar o borrar
                    SalvedadAnotacionTMP sal = new SalvedadAnotacionTMP();

                    for (Iterator it = anotaTMP.getSalvedadesTMPs().iterator();
                            it.hasNext();) {
                        sal = (SalvedadAnotacionTMP) it.next();

                        SalvedadAnotacionEnhancedPk saId = new SalvedadAnotacionEnhancedPk();
                        saId.idSalvedad = sal.getIdSalvedadAnTmp();
                        saId.idAnotacion = sal.getIdAnotacionTmp();
                        saId.idMatricula = sal.getIdMatricula();

                        SalvedadAnotacionEnhanced saToUpdate = this.getSalvedadAnotacion(saId,
                                pm);

                        if (saToUpdate != null) {
                            //La salvedad se debe actualizar
                            //Se verifica si se tiene que borrar la salvedad
                            if (sal.isToDelete()) {

                                //Se hace la auditoría a los atributos que cambiaron
                                auditoria.addAuditoria(null, saToUpdate, usuario, pm);

                                //Se elimina la salvedad
                                saToUpdate.getAnotacion().removeSalvedade(saToUpdate);
                                pm.deletePersistent(saToUpdate);
                            } else {

                                //Se crea una copia del folio
                                SalvedadAnotacionEnhanced salvedadAnotacionViejo = (SalvedadAnotacionEnhanced) auditoria.clonarEnhanced(saToUpdate);

                                //Se actualiza la salvedad
                                if (sal.getDescripcion() != null) {
                                    saToUpdate.setDescripcion(sal.getDescripcion());
                                }

                                //Se hace la auditoría a los atributos que cambiaron
                                auditoria.addAuditoria(saToUpdate, salvedadAnotacionViejo, usuario, pm);

                            }
                        } else {
                            //Se tiene que insertar la salvedad
                            SalvedadAnotacionEnhanced saToInsert = sal.getDefinitivo();

                            //Se setea el ID de la salvedad en null para que la inserte
                            //con el secuencial asignado en definitivo
                            saToInsert.setIdSalvedad(null);
                            this.addSalvedadToAnotacion(aned, saToInsert,
                                    usuario, turno, validarTurno, pm);
                            pm.makePersistent(saToInsert);
                        }
                    }

                    //Miramos los cancelaciones asociadas para ver si se deben
                    //agregar o borrar
                    CancelacionTMP can = new CancelacionTMP();

                    for (Iterator it = anotaTMP.getAnotacionesCancelacionTMPs()
                            .iterator(); it.hasNext();) {
                        can = (CancelacionTMP) it.next();

                        //Se revisa si se debe crear o actualizar (borrar)
                        CancelacionEnhanced canToUpdate = this.getCancelacion(can, anotaTMP, pm);

                        if (canToUpdate != null) {
                            //La cancelacion se debe actualizar
                            //Se verifica si se tiene que borrar la anotacionCiudadano
                            if (can.isToDelete()) {
                                //Se hace la auditoría a los atributos que cambiaron
                                auditoria.addAuditoria(null, canToUpdate, usuario, pm);
                                /**
                                 * @Author Carlos Torres
                                 * @Mantis 13176
                                 * @Chaged
                                 */
                                try {
                                    auditoriaSir.guardarAuditoriaRelCancelacion(null, canToUpdate, turno.getIdWorkflow());
                                } catch (GeneralSIRException exp) {
                                    Log.getInstance().error(JDOGenieFolioDAO.class, exp.getMessage());
                                }
                                canToUpdate.getCanceladora().removeAnotacionesCancelacion(canToUpdate);
                                pm.deletePersistent(canToUpdate);
                            }
                        } else {
                            //Se tiene que insertar la cancelacion
                            CancelacionEnhanced canToInsert = can.getDefinitivo();
                            this.addCancelacionToAnotacion(aned,
                                    canToInsert, pm);
                            pm.makePersistent(canToInsert);
                            /**
                             * @Author Carlos Torres
                             * @Mantis 13176
                             * @Chaged
                             */
                            if (turno != null) {
                                try {
                                    auditoriaSir.guardarAuditoriaRelCancelacion(canToInsert, null, turno.getIdWorkflow());
                                } catch (GeneralSIRException exp) {
                                    Log.getInstance().error(JDOGenieFolioDAO.class, exp.getMessage());
                                }
                            }
                        }
                    }

                    //SE DEBEN TENER EN CUENTA LOS FOLIOS DERIVADOS QUE SE ENCUENTREN PARA
                    //ACTUALIZAR - Damned Versant!
                    AnotacionTMPPk tid = new AnotacionTMPPk();
                    tid.idAnotacionTmp = anotaTMP.getIdAnotacionTmp();
                    tid.idMatricula = folio.getIdMatricula();

                    AnotacionTMP anotaTMPAux = this.getAnotacionTMPByID(tid, pm);

                    FolioDerivadoTMP folioDerivadoTMP;

                    for (Iterator it = anotaTMPAux.getAnotacionesHijosTMPs().iterator(); it.hasNext();) {
                        folioDerivadoTMP = (FolioDerivadoTMP) it.next();

                        FolioDerivadoEnhancedPk fdId = new FolioDerivadoEnhancedPk();
                        fdId.idAnotacion = folioDerivadoTMP.getIdAnotacionTmp();
                        fdId.idAnotacion1 = folioDerivadoTMP.getIdAnotacion1Tmp();
                        fdId.idMatricula = folioDerivadoTMP.getIdMatricula();
                        fdId.idMatricula1 = folioDerivadoTMP.getIdMatricula1();

                        FolioDerivadoEnhanced folioDerivadoEnhanced;

                        try {
                            folioDerivadoEnhanced = (FolioDerivadoEnhanced) pm.getObjectById(fdId, true);
                        } catch (JDOObjectNotFoundException e) {
                            folioDerivadoEnhanced = null;
                        }
                        if (folioDerivadoEnhanced == null && !folioDerivadoTMP.isToDelete()) {
                            FolioDerivadoEnhanced fdToInsert = folioDerivadoTMP.getDefinitivo(new ArrayList());
                            this.addFolioDerivadoHijoToAnotacion(aned, fdToInsert, usuario, turno, validarTurno,
                                    pm);

                            AnotacionTMPPk anotaDerivadaPk = new AnotacionTMPPk();
                            anotaDerivadaPk.idAnotacionTmp = folioDerivadoTMP.getIdAnotacion1Tmp();
                            anotaDerivadaPk.idMatricula = folioDerivadoTMP.getIdMatricula1();

                            pm.makePersistent(fdToInsert);
                            pm.deletePersistent(folioDerivadoTMP);
                            /**
                             * @Author Carlos Torres
                             * @Mantis 13176
                             * @Chaged
                             */
                            if (turno != null) {
                                try {
                                    auditoriaSir.guardarAuditoriaFolioDerivado(folioDerivadoEnhanced, null, turno.getIdWorkflow());
                                } catch (GeneralSIRException exp) {
                                    Log.getInstance().error(JDOGenieFolioDAO.class, exp.getMessage());
                                }
                            }
                            AnotacionTMP anotaTmpderivada = (AnotacionTMP) pm.getObjectById(anotaDerivadaPk, true);

                            /*
                                                         * @Autor:Guillermo Cabrera
                                                         * @fecha: 26-07-2010
                                                         * @cambio:Se obtiene el número de anotaciones padre con la anotacion
                                                         * derivada, si el numero de anotaciones padre es mayor de 0 no se puede
                                                         * eliminar la anotacion derivada.
                                                         * @mantis:4644
                                                         
                                                        anotapadresize=anotaTmpderivada.getAnotacionesPadreTMPs().size();*/
                            if (anotaTmpderivada != null && !anotacionesTmpDerivadas.contains(anotaTmpderivada)) {
                                anotacionesTmpDerivadas.add(anotaTmpderivada);
                            }
                            //Ejecutamos el borrado

                            VersantPersistenceManager pm2 = (VersantPersistenceManager) pm;
                            pm2.flush();
                        } else {
                            //Se hace la auditoría a los atributos que cambiaron
                            auditoria.addAuditoria(null, folioDerivadoEnhanced, usuario, pm);
                            /**
                             * @Author Carlos Torres
                             * @Mantis 13176
                             * @Chaged
                             */
                            if (turno != null) {
                                try {
                                    auditoriaSir.guardarAuditoriaFolioDerivado(null, folioDerivadoEnhanced, turno.getIdWorkflow());
                                } catch (GeneralSIRException exp) {
                                    Log.getInstance().error(JDOGenieFolioDAO.class, exp.getMessage());
                                }
                            }
                            AnotacionTMPPk anotaDerivadaPk = new AnotacionTMPPk();
                            anotaDerivadaPk.idAnotacionTmp = folioDerivadoTMP.getIdAnotacion1Tmp();
                            anotaDerivadaPk.idMatricula = folioDerivadoTMP.getIdMatricula1();

                            pm.deletePersistent(folioDerivadoTMP);
                            pm.deletePersistent(folioDerivadoEnhanced);

                            AnotacionTMP anotaTmpderivada = (AnotacionTMP) pm.getObjectById(anotaDerivadaPk, true);

                            /*
                                                         * @Autor:Guillermo Cabrera
                                                         * @fecha: 26-07-2010
                                                         * @cambio:Se obtiene el número de anotaciones padre con la anotacion
                                                         * derivada, si el numero de anotaciones padre es mayor de 0 no se puede
                                                         * eliminar la anotacion derivada.
                                                         * @mantis:4644
                                                         
                                                        anotapadresize=anotaTmpderivada.getAnotacionesPadreTMPs().size();*/
                            if (anotaTmpderivada != null && !anotacionesTmpDerivadas.contains(anotaTmpderivada)) {
                                anotacionesTmpDerivadas.add(anotaTmpderivada);
                            }
                            //Ejecutamos el borrado
                            VersantPersistenceManager pm2 = (VersantPersistenceManager) pm;
                            pm2.flush();
                        }
                    }
                    //se eliminan las anotaciones tmp de los folios derivados

                    //Se hace la auditoría a los atributos que cambiaron
                    auditoria.addAuditoria(aned, anotacionAuditoriaViejo, usuario, pm);
                    //pm.deletePersistent(anotaTMP);
                    /**
                     * @Author Carlos Torres
                     * @Mantis 13176
                     * @Chaged
                     */
                    if (turno != null) {
                        try {
                            auditoriaSir.guardarAuditoriaAnotacion(aned, anotacionAuditoriaViejo, turno.getIdWorkflow());
                        } catch (co.com.iridium.generalSIR.comun.GeneralSIRException exp) {
                            Log.getInstance().error(co.com.iridium.generalSIR.negocio.auditoria.AuditoriaSIR.class, exp.getMessage());
                        }
                    }
                }
            }
            /*
                 * @Autor:Guillermo Cabrera
                 * @fecha: 26-07-2010
                 * @cambio:Se obtiene el número de anotaciones padre con la anotacion
                 * derivada, si el numero de anotaciones padre es mayor de 0 no se puede
                  * eliminar la anotacion derivada.
                 * @mantis:4644
               
                 if (anotapadresize==0)
                 {
                    for(int i=0;i<anotacionesTmpDerivadas.size();i++)
                    {
				AnotacionTMP anotaTmp=(AnotacionTMP)anotacionesTmpDerivadas.get(i);
				if(anotaTmp.getIdAnotacionTmp()!=null)
                                {
                                    if(turno == null ||
                                    turno.getIdWorkflow().equals(anotaTmp.getNumRadicacion())||
                                    turno.getIdWorkflow().equals(anotaTmp.getIdWorkflow()))
                                    {
                                        pm.deletePersistent(anotaTmp);
                                    }
                                }

                    }
                  }*/

            for (int i = 0; i < anotacionesTemporales.size(); i++) {
                AnotacionTMP anotaTmp = (AnotacionTMP) anotacionesTemporales.get(i);
                if (anotaTmp.getIdAnotacionTmp() != null) {
                    if (turno == null
                            || turno.getIdWorkflow().equals(anotaTmp.getNumRadicacion())
                            || turno.getIdWorkflow().equals(anotaTmp.getIdWorkflow())) {
                        pm.deletePersistent(anotaTmp);
                    }
                }
            }

            //pm.deletePersistentAll(folio.getAnotacionesTMPs());
            folio.setLastIdAnotacion(folio.getLastIdAnotacionTMP());
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }
    }

    /**
     *
     * @param anota
     * @param datos
     * @param pm
     * @return
     * @throws DAOException
     */
    protected boolean addSalvedadToAnotacion(AnotacionEnhanced anota,
            SalvedadAnotacionEnhanced datos, UsuarioEnhanced usuario,
            TurnoEnhanced turno, boolean validarTurno, PersistenceManager pm) throws DAOException {
        boolean rta = false;

        try {
            if (datos.getIdSalvedad() == null) {
                datos.setIdSalvedad(String.valueOf(anota.getLastIdSalvedad()
                        + 1));
                anota.setLastIdSalvedad(anota.getLastIdSalvedad() + 1);
            }

            datos.setAnotacion(anota);

            //Se setea el usuario creador definitivo
            datos.setUsuarioCreacion(usuario);

            //Se asocia el turno creador
            if (turno != null) {
                TurnoSalvedadAnotacionEnhanced tsae = new TurnoSalvedadAnotacionEnhanced();
                tsae.setTurno(turno);
                tsae.setSalvedad(datos);
                datos.setNumRadicacion(turno.getIdWorkflow());
                datos.addTurnoSalvedadAnotacion(tsae);
            }

            rta = true;
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }

        return rta;
    }

    /**
     * Retorna la información del folio dependiendo del usuario solicitante, si
     * el usuario tiene bloqueado el folio se retorna la información definitiva
     * y temporal, si el usuario no tiene el bloqueo del folio se lanza una
     * excepcion indicando lo sucedido
     *
     * @param oid
     * @param us
     * @return
     * @throws DAOException
     */
    public Folio getFolioByID(FolioPk oid, Usuario usuario)
            throws DAOException {
        FolioEnhanced datos = null;
        Folio aux = null;
        PersistenceManager pm = AdministradorPM.getPM();

        try {
            datos = this.getFolioByID(new FolioEnhancedPk(oid), pm);

            if (datos == null) {
                throw new DAOException("El folio especificado no existe");
            }

            //Validar bloqueo del folio
            if (usuario != null) {
                this.validarBloqueoFolio(datos, usuario, pm);
            }

            //Una vez realizadas las validaciones se procede a obtener
            //la información del folio definitiva y temporal:
            this.makeTransientFolioTMP(datos, pm);

        } catch (DAOException e) {
            throw e;
        } catch (Exception e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e);
        } finally {
            pm.close();
        }

        aux = this.getMaskedFolio(datos);
        this.ordenarDirecciones(aux.getDirecciones());
        return aux;
    }

    /**
     * @author : Henry Gómez Rocha y Fernando Padilla
     * @change : Evita que al momento de pasar del role Calificador al role
     * Digitador se verifique el usuario que tiene el bloqueo. Caso Mantis :
     * 0004967
     * @param oid
     * @param usuario
     * @param validarBloqueo
     * @return
     * @throws DAOException
     */
    public Folio getFolioByID(FolioPk oid, Usuario usuario, boolean validarBloqueo)
            throws DAOException {
        FolioEnhanced datos = null;
        Folio aux = null;
        PersistenceManager pm = AdministradorPM.getPM();

        try {
            datos = this.getFolioByID(new FolioEnhancedPk(oid), pm);

            if (datos == null) {
                throw new DAOException("El folio especificado no existe");
            }

            //Validar bloqueo del folio
            if (usuario != null) {
                if (validarBloqueo) {
                    this.validarBloqueoFolio(datos, usuario, pm);
                }

            }

            //Una vez realizadas las validaciones se procede a obtener
            //la información del folio definitiva y temporal:
            this.makeTransientFolioTMP(datos, pm);

        } catch (DAOException e) {
            throw e;
        } catch (Exception e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e);
        } finally {
            pm.close();
        }

        aux = this.getMaskedFolio(datos);
        this.ordenarDirecciones(aux.getDirecciones());
        return aux;
    }

    /**
     * Segrega un folio
     *
     * @param datos Tiene los IDs del folio a segregar y los IDs de la
     * anotaciones a heredar
     * @param foliosDerivados Lista de folios derivados
     * @param usuario Usuario que realiza la segregación, debe tener el folio
     * bloqueado
     * @param nuevaAnotacion Anotación que se crea en el padre y en los hijos
     * para encadenarlos
     * @param copiarComentarioSegregacion Permite determinar si se debe o no
     * copiar el comentario de la anotación origen a las nuevas anotaciones de
     * los nuevos folios.
     * @param copiarComentarioHeredadas Permite determinar si se debe o no
     * copiar el comentario de las anotaciones a heredar en los nuevos folios
     * @return
     * @throws DAOException
     */
    public List segregarFolio(Folio datos, List foliosDerivados,
            Usuario usuario, Anotacion nuevaAnotacion, boolean copiarComentarioSegregacion, boolean copiarComentarioHeredadas, TurnoPk oid) throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        List rta = new ArrayList();

        FolioEnhanced folio;
        UsuarioEnhanced us;
        FolioDerivadoEnhanced faux;
        DAOException exc = new DAOException("Fallo en la segregación del folio");
        Hashtable ht = new Hashtable();

        TurnoEnhancedPk toid = new TurnoEnhancedPk();
        TurnoEnhanced turnoe = null;

        if (oid != null) {
            toid.anio = oid.anio;
            toid.idCirculo = oid.idCirculo;
            toid.idProceso = oid.idProceso;
            toid.idTurno = oid.idTurno;
            turnoe = this.getTurnoByID(toid, pm);
        }

        try {

            // Se obtiene la naturaleza juridica para poder guardar el nombre en la especificacion de la anotacion
            NaturalezaJuridicaEnhancedPk natJurId = new NaturalezaJuridicaEnhancedPk();
            natJurId.idNaturalezaJuridica = nuevaAnotacion.getNaturalezaJuridica().getIdNaturalezaJuridica();
            NaturalezaJuridicaEnhanced natJurTemp = this.getNaturalezaJuridica(natJurId, pm);

            //Validamos que el folio recibido tenga asociado el turno
            if (datos.getTurnosFolios().size() == 0) {
                throw new DAOException("El folio debe tener asociado el turno");
            }

            //Validamos el usuario y si tiene acceso al folio
            //para modificarlo
            UsuarioEnhancedPk uid = new UsuarioEnhancedPk();
            uid.idUsuario = usuario.getIdUsuario();

            us = this.getUsuarioByID(uid, pm);

            if (us == null) {
                throw new DAOException("El usuario especificado no existe: "
                        + uid.idUsuario);
            }

            //Validamos si el folio está bloqueado
            BloqueoFolioEnhanced bloqueo = this.getBloqueoFolio(datos.getIdMatricula(),
                    pm);

            if (bloqueo == null) {
                throw new DAOException("La matricula no se encuentra bloqueada");
            }

            //Validamos que el usuario sea dueño del bloqueo del folio
            UsuarioEnhanced usuAux = this.getUsuarioByLlaveBloqueo(bloqueo.getLlaveBloqueo(),
                    pm);

            if (usuAux == null) {
                throw new DAOException(
                        "Error en la obtención del usuario a partir de la llave de bloqueo");
            }

            if (usuAux.getIdUsuario() != us.getIdUsuario()) {
                throw new DAOException(
                        "El usuario no es dueño del bloqueo del folio. El turno asociado a la matrícula es: " + bloqueo.getIdWorkflowBloqueo());
            }

            //Una vez realizadas las validaciones se inicia la transacción
            pm.currentTransaction().setOptimistic(false);
            pm.currentTransaction().begin();

            //Obtenemos el folio persistente
            FolioEnhancedPk fid = new FolioEnhancedPk();
            fid.idMatricula = datos.getIdMatricula();

            folio = this.getFolioByID(fid, pm);

            if (folio == null) {
                throw new DAOException("El folio no existe");
            }

            //Se decide si la anotación padre es una anotación nueva
            //o es una anotación existente en el sistema
            AnotacionTMP anotaPadre = null;
            TipoAnotacionEnhanced tipoAnota = null;

            if (nuevaAnotacion.getIdAnotacion() != null) {
                AnotacionTMPPk anotaValEx = new AnotacionTMPPk();
                anotaValEx.idAnotacionTmp = nuevaAnotacion.getIdAnotacion();
                anotaValEx.idMatricula = folio.getIdMatricula();

                anotaPadre = this.getAnotacionTMPByID(anotaValEx, pm);
                anotaPadre.setEspecificacion(natJurTemp.getNombre());
                if (anotaPadre == null) {
                    throw new DAOException(
                            "No existe la anotación padre especificada con ID: "
                            + nuevaAnotacion.getIdAnotacion());
                }

                if (!anotaPadre.getTipoAnotacion().getIdTipoAnotacion().equals(CTipoAnotacion.GENERADORA)) {
                    throw new DAOException(
                            "La anotación seleccionada como padre NO es de tipo generadora");
                }
            } else {
                //Validamos que la nueva anotación tenga un documento asociado
                if (nuevaAnotacion.getDocumento() == null) {
                    throw new DAOException(
                            "La anotación debe tener asociado un documento");
                }

                //Se crea la anotación padre que se asocia al folio generador
                anotaPadre = new AnotacionTMP(nuevaAnotacion);
                tipoAnota = new TipoAnotacionEnhanced();
                tipoAnota.setIdTipoAnotacion(CTipoAnotacion.GENERADORA);
                anotaPadre.setTipoAnotacion(tipoAnota);
                anotaPadre.setEspecificacion(natJurTemp.getNombre());
                /*
                NaturalezaJuridicaEnhanced nat = new NaturalezaJuridicaEnhanced();
                nat.setIdNaturalezaJuridica(CNaturalezaJuridica.DESENGLOBE);
                anotaPadre.setNaturalezaJuridica(nat);
                 */
                //Asignación de orden:
                anotaPadre.setOrden(String.valueOf(this.getNextOrdenAnotacion(
                        folio, pm)));

                this.addAnotacionTMPToFolio(folio, anotaPadre, us, turnoe, pm);
                pm.makePersistent(anotaPadre);

                List salvedades = datos.getSalvedades();
                if (salvedades != null) {
                    for (Iterator salvItera = salvedades.iterator();
                            salvItera.hasNext();) {
                        SalvedadFolio salv = (SalvedadFolio) salvItera.next();
                        SalvedadFolioTMP salvTmp = new SalvedadFolioTMP();
                        salvTmp.setIdSalvedadFoTmp(salv.getIdSalvedad());
                        salvTmp.setDescripcion(salv.getDescripcion());
                        salvTmp.setIdMatricula(salv.getIdMatricula());
                        salvTmp.setNumRadicacion(salv.getNumRadicacion());
                        if (salvTmp.getIdSalvedadFoTmp() == null
                                || salvTmp.getIdSalvedadFoTmp().equals("")) {
                            this.addSalvedadTMPToFolio(folio, salvTmp, us, pm);
                            pm.makePersistent(salvTmp);
                        } else if (salv.isTemporal()) {
                            this.updateSalvedadTMPToFolio(folio, salvTmp, us, pm);
                        }
                    }
                }
            }

            //Se realiza el flush para que mande los cambios a base de datos
            VersantPersistenceManager pm2 = (VersantPersistenceManager) pm;
            pm2.flush();

            //Recorremos la lista de folios derivados
            FolioDerivadoTMP fd = null;
            FolioEnhanced hijo;
            AnotacionEnhancedPk aid;
            AnotacionEnhanced anEnh;
            Anotacion anAux;
            List cache;
            List cache2;

            for (Iterator it = foliosDerivados.iterator(); it.hasNext();) {
                fd = new FolioDerivadoTMP((FolioDerivado) it.next());

                //Se crea el folio derivado, se hereda el tipo de predio, la zona registral
                //la complementacion, la última direccion y las anotaciones
                //del folio
                hijo = new FolioEnhanced();

                //Seteamos el documento del hijo como el documento de la nuevaAnotacion
                DocumentoEnhanced doc = anotaPadre.getDocumento();
                hijo.setDocumento(doc);

                TurnoFolioEnhanced tf = TurnoFolioEnhanced.enhance((TurnoFolio) datos.getTurnosFolios()
                        .get(0));
                hijo.addTurnosFolio(tf);

                hijo.setTipoPredio(folio.getTipoPredio());
                hijo.setZonaRegistral(folio.getZonaRegistral());
                //hijo.setComplementacion(folio.getComplementacion());

                //El lindero queda de la siguiente manera:
                //NOMBRE_LOTE con extensión de AREA cuyos linderos y demás especificaciones obran en TIPO_DOC NUM, FECHA,
                //OFICINA_PROC. Artículo 11 Decreto 1711 de 1984
                hijo.setLindero(this.contruirLindero(fd, doc, pm));
                hijo.setNombreLote(fd.getLote());
                hijo.setHectareas(fd.getHectareas());
                hijo.setMetros(fd.getMetros());
                hijo.setCentimetros(fd.getCentimetros());

                /*
                if (folio.getDirecciones().size() > 0) {
                    DireccionEnhanced dirAux = this.getUltimaDireccion(fid, pm);

                    DireccionEnhanced.ID dirID = new DireccionEnhanced.ID();
                    dirID.idDireccion = dirAux.getIdDireccion();
                    dirID.idMatricula = dirAux.getIdMatricula();
                    dirID.idZonaRegistral = dirAux.getIdZonaRegistral();

                    dirAux = this.getDireccion(dirID, pm);

                    if (dirAux == null) {
                        throw new DAOException("No se encontró la direccion");
                    }

                    hijo.addDireccione(dirAux);
                }*/
                for (Iterator it2 = datos.getAnotaciones().iterator();
                        it2.hasNext();) {
                    List errores = new ArrayList();
                    anAux = (Anotacion) it2.next();
                    anAux.setIdMatricula(datos.getIdMatricula());
                    try {
                        this.heredarAnotacion(anAux, hijo, true, copiarComentarioHeredadas, pm, anotaPadre.getIdWorkflow());
                    } catch (DAOException e) {
                        String id_anotacion = "";
                        if (anAux != null) {

                            if (anAux.getIdAnotacion() != null) {
                                id_anotacion = anAux.getIdAnotacion();
                            }
                            if (anAux.getOrden() != null) {
                                id_anotacion = anAux.getOrden();
                            }

                        }
                        id_anotacion = anAux.getIdMatricula() + ", Anotación No. " + id_anotacion;
                        ht.put(id_anotacion, e.getErrores());
                    }
                }

                if (ht.size() > 0) {
                    exc.setHashErrores(ht);
                    throw exc;
                }

                this.crearFolio(hijo, usuAux, pm, turnoe, true);

                //El flag en true del anterior método nos asegura la siguiente linea
                TurnoFolioEnhanced turnoF = (TurnoFolioEnhanced) hijo.getTurnosFolios().get(0);

                //Bloqueamos el folio recién creado con la misma llave en que se tiene
                //bloqueado el folio padre
                BloqueoFolioEnhanced bf = new BloqueoFolioEnhanced();
                bf.setFechaBloqueo(new Date());
                bf.setFolio(hijo);
                bf.setLlaveBloqueo(bloqueo.getLlaveBloqueo());
                bf.setIdWorkflowBloqueo(turnoF.getTurno().getIdWorkflow());
                pm.makePersistent(bf);
                //Se crea la anotación hija que se asocia al folio generado
                AnotacionTMP anotaHija = new AnotacionTMP(anotaPadre.getDefinitivo(
                        new ArrayList()), new ArrayList());
                tipoAnota = new TipoAnotacionEnhanced();
                tipoAnota.setIdTipoAnotacion(CTipoAnotacion.DERIVADO);
                anotaHija.setTipoAnotacion(tipoAnota);

                anotaHija.setOrden(String.valueOf(this.getNextOrdenAnotacion(
                        hijo, pm)));

                //Si la anotación padre tiene naturaleza juridica 0126 las hijas
                //quedan con la naturaleza juridica 0125
                if (anotaPadre.getNaturalezaJuridica().getIdNaturalezaJuridica().equals(CNaturalezaJuridica.COMPRAVENTA_PARCIAL)) {
                    NaturalezaJuridicaEnhancedPk natId = new NaturalezaJuridicaEnhancedPk();
                    natId.idNaturalezaJuridica = CNaturalezaJuridica.COMPRAVENTA;
                    //NaturalezaJuridicaEnhanced nat = new NaturalezaJuridicaEnhanced();
                    NaturalezaJuridicaEnhanced nat = this.getNaturalezaJuridica(natId, pm);
                    //nat.setIdNaturalezaJuridica(CNaturalezaJuridica.COMPRAVENTA);
                    anotaHija.setNaturalezaJuridica(nat);
                    anotaHija.setEspecificacion(nat.getNombre());
                }

                if (!copiarComentarioSegregacion) {
                    anotaHija.setComentario(null);
                }

                anotaHija.setIdAnotacionTmp(null);
                this.addAnotacionTMPToFolio(hijo, anotaHija, us, turnoe, pm);
                pm.makePersistent(anotaHija);

                fd.setPadreTmp(anotaPadre);
                fd.setHijoTmp(anotaHija);
                pm.makePersistent(fd);
            }

            pm.currentTransaction().commit();

            FolioDerivadoTMP fdTMP;

            for (Iterator it = anotaPadre.getAnotacionesHijosTMPs().iterator();
                    it.hasNext();) {
                fdTMP = (FolioDerivadoTMP) it.next();
                this.makeTransientAnotacionTMP(fdTMP.getHijoTmp(), pm,
                        new ArrayList());
                this.makeTransientAnotacionTMP(fdTMP.getPadreTmp(), pm,
                        new ArrayList());
                pm.makeTransient(fdTMP);
                rta.add(fdTMP.getDefinitivo(new ArrayList()));
            }
        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (DAOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            throw e;
        } catch (Exception e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        return TransferUtils.makeTransferAll(rta);
    }

    /**
     * Copia la anotación con el ID especificado al folio transiente. La
     * anotación con el ID puede ser definitiva o temporal. Si la anotación es
     * de cancelación no se copia, si la anotación es cancelada por otra se
     * copia su canceladora también
     *
     * @param anAux
     * @param hijo
     * @param pm
     * @param idWorkflow Turno que está creando la nueva anotación temporal
     */
    private void heredarAnotacion(Anotacion anAux, FolioEnhanced hijo, boolean heredada, boolean copiarComentario, PersistenceManager pm, String idWorkflow) throws DAOException {

        ForsetiProperties fp = ForsetiProperties.getInstancia();
        boolean copiarCanceladora = Boolean.valueOf(fp.getProperty(ForsetiProperties.COPIAR_CANCELADORA_COPIA_ANOTACION)).booleanValue();

        AnotacionEnhancedPk aid = new AnotacionEnhancedPk();
        aid.idAnotacion = anAux.getIdAnotacion();
        aid.idMatricula = anAux.getIdMatricula();
        AnotacionEnhanced anEnh = this.getAnotacionByID(aid, pm);
        DAOException exc = new DAOException();

        List errores = new ArrayList();

        AnotacionTMP anTMP;
        List cache = new ArrayList();
        boolean crearAnotacionNormal = true;

        //Se busca si la anotación a heredar es definitiva
        if (anEnh != null) {

            //Si la anotación encontrada cancela a otra, no se puede
            //heredar esta anotación
            if (anEnh.getAnotacionesCancelacions().size() > 0) {
                errores.add(
                        "La anotación no se puede heredar puesto que es de cancelación");
            }

            //Si se debe copiar la canceladora se valida lo siguiente:
            if (copiarCanceladora) {
                //Si la anotación encontrada es cancelada por otra
                //anotación del mismo folio se agrega dentro de
                //las anotaciones a agregar y se pone un flag en true
                //que indica que la anotación cancelada asociada se
                //debe crear en vez de asociarla.
                AnotacionEnhanced anCanceladora = this.getAnotacionCanceladora(anEnh,
                        pm);

                if (anCanceladora != null) {
                    //La anotación tiene una anotación que la cancela
                    //Entonces se agrega esta anotación indicando que
                    //la anotación cancelada se debe también crear
                    anTMP = new AnotacionTMP(anCanceladora, cache);
                    anTMP.setCrearCancelada(true);

                    //Por el bug 2506 se quita la posibilidad de copiar o NO copiar el comentario
                    //de las anotaciones definitivas
                    /*
					if(!copiarComentario){
						anTMP.setComentario(null);
					}*/
                    //Seteamos el orden en null para que sea asignado
                    //por el sistema
                    anTMP.setOrden(null);
                    anTMP.setDatosAntiguoSistema(null);
                    anTMP.setHeredada(heredada);
                    anTMP.setIdWorkflow(idWorkflow);//bug 3254
                    hijo.addAnotacionesTMP(anTMP);
                    crearAnotacionNormal = false;
                }
            }

            if (crearAnotacionNormal) {
                //La anotación no tiene una anotación que la cancela
                //Entonces se agrega esta anotación de manera normal
                anTMP = new AnotacionTMP(anEnh, cache);

                //Por el bug 2506 se quita la posibilidad de copiar o NO copiar el comentario
                //de las anotaciones definitivas
                /*
				if(!copiarComentario){
					anTMP.setComentario(null);
				}*/
                //Seteamos el orden en null para que sea asignado
                //por el sistema
                anTMP.setOrden(null);
                anTMP.setDatosAntiguoSistema(null);
                anTMP.setHeredada(heredada);
                anTMP.setIdWorkflow(idWorkflow);
                hijo.addAnotacionesTMP(anTMP);
            }

        } else {
            //Se busca entre las anotaciones temporales
            AnotacionTMPPk tid = new AnotacionTMPPk();
            tid.idAnotacionTmp = anAux.getIdAnotacion();
            tid.idMatricula = anAux.getIdMatricula();

            AnotacionTMP anotaTMP = this.getAnotacionTMPByID(tid, pm);

            if (anotaTMP == null) {
                errores.add(
                        "No se encontró la anotación a heredar "
                        + aid.idAnotacion);
            } else {

                //Si la anotación encontrada cancela a otra, no se puede
                //heredar esta anotación
                if (anotaTMP.getAnotacionesCancelacionTMPs().size() > 0) {
                    errores = new ArrayList();
                    errores.add(
                            "La anotación no se puede heredar puesto que es de cancelación");
                }

                //Si se debe copiar la canceladora se valida lo siguiente:
                if (copiarCanceladora) {

                    //Si la anotación encontrada es cancelada por otra
                    //anotación del mismo folio se agrega dentro de
                    //las anotaciones a agregar y se pone un flag en true
                    //que indica que la anotación cancelada asociada se
                    //debe crear en vez de asociarla.
                    AnotacionTMP anCanceladoraTMP = this.getAnotacionCanceladoraTMP(anotaTMP,
                            pm);

                    cache = new ArrayList();

                    if (anCanceladoraTMP != null) {
                        //La anotación tiene una anotación que la cancela
                        //Entonces se agrega esta anotación indicando que
                        //la anotación cancelada se debe también crear
                        anTMP = new AnotacionTMP(anCanceladoraTMP.getDefinitivo(
                                new ArrayList()), cache);
                        anTMP.setCrearCancelada(true);

                        if (!copiarComentario) {
                            anTMP.setComentario(null);
                        }

                        //Seteamos el orden en null para que sea asignado
                        //por el sistema
                        anTMP.setOrden(null);
                        anTMP.setDatosAntiguoSistema(null);
                        anTMP.setHeredada(heredada);
                        anTMP.setIdWorkflow(idWorkflow);
                        hijo.addAnotacionesTMP(anTMP);
                        crearAnotacionNormal = false;
                    }
                }

                if (crearAnotacionNormal) {
                    //La anotación no tiene una anotación que la cancela
                    //Entonces se agrega esta anotación de manera normal
                    anTMP = new AnotacionTMP(anotaTMP.getDefinitivo(
                            new ArrayList()), cache);

                    if (!copiarComentario) {
                        anTMP.setComentario(null);
                    }

                    //Seteamos el orden en null para que sea asignado
                    //por el sistema
                    anTMP.setOrden(null);
                    anTMP.setDatosAntiguoSistema(null);
                    anTMP.setHeredada(heredada);
                    anTMP.setIdWorkflow(idWorkflow);
                    hijo.addAnotacionesTMP(anTMP);
                }

            }
        }

        if (errores.size() > 0) {
            exc.setErrores(errores);
            throw exc;
        }

    }

    /**
     * Obtiene la anotación que cancela a la anotación dada, si no existe una
     * anotación que la cancela retorna null
     *
     * @param anEnh
     * @param pm
     * @return
     */
    protected AnotacionEnhanced getAnotacionCanceladora(
            AnotacionEnhanced anEnh, PersistenceManager pm)
            throws DAOException {
        AnotacionEnhanced rta = null;

        try {
            String idAnota1 = anEnh.getIdAnotacion();
            String idMat = anEnh.getIdMatricula();

            Query query = pm.newQuery(AnotacionEnhanced.class);
            query.declareVariables("CancelacionEnhanced cancel");
            query.declareParameters(
                    "String idAnota1, String idMat");
            query.setFilter("this.anotacionesCancelacion.contains(cancel) && "
                    + " cancel.idAnotacion1 == idAnota1 && cancel.idMatricula == idMat");

            Collection col = (Collection) query.execute(idAnota1, idMat);

            Iterator iter = col.iterator();

            if (iter.hasNext()) {
                rta = (AnotacionEnhanced) iter.next();
            } else {
                rta = null;
            }
        } catch (JDOObjectNotFoundException e) {
            rta = null;
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }

        return rta;
    }

    /**
     * Obtiene la primera matrícula no grabada en definitivo
     *
     * @param cir
     * @param pm
     * @return
     * @throws DAOException
     */
    protected MatriculaNoGrabadaEnhanced getFirstMatriculaNoGrabada(
            CirculoEnhanced cir, PersistenceManager pm)
            throws DAOException {
        MatriculaNoGrabadaEnhanced rta = null;

        try {

            Query query = pm.newQuery(MatriculaNoGrabadaEnhanced.class);
            query.setOrdering("idMatNoGrabada ascending");
            query.declareParameters("CirculoEnhanced cir");
            query.setFilter("this.circulo==cir");
            Collection col = (Collection) query.execute(cir);

            Iterator iter = col.iterator();

            if (iter.hasNext()) {
                rta = (MatriculaNoGrabadaEnhanced) iter.next();
            } else {
                rta = null;
            }
        } catch (JDOObjectNotFoundException e) {
            rta = null;
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }

        return rta;
    }

    /**
     * Obtiene la anotación temporal que cancela a la anotación dada, si no
     * existe una anotación que la cancela retorna null
     *
     * @param anEnh
     * @param pm
     * @return
     */
    protected AnotacionTMP getAnotacionCanceladoraTMP(AnotacionTMP anEnh,
            PersistenceManager pm) throws DAOException {
        AnotacionTMP rta = null;

        try {
            String idAnota1 = anEnh.getIdAnotacionTmp();
            String idMat = anEnh.getIdMatricula();

            Query query = pm.newQuery(AnotacionTMP.class);
            query.declareVariables("CancelacionTMP cancel");
            query.declareParameters(
                    "String idAnota1, String idMat");
            query.setFilter(
                    "this.anotacionesCancelacionTMP.contains(cancel) && "
                    + " cancel.canceladaTmp.idAnotacionTmp == idAnota1 && cancel.canceladaTmp.idMatricula == idMat");

            Collection col = (Collection) query.execute(idAnota1, idMat);

            Iterator iter = col.iterator();

            if (iter.hasNext()) {
                rta = (AnotacionTMP) iter.next();
            } else {
                rta = null;
            }
        } catch (JDOObjectNotFoundException e) {
            rta = null;
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }

        return rta;
    }

    /**
     * Organiza la información definitiva y temporal del folio en el objeto
     * Folio (Transfer). Simula que toda la información es definitiva
     *
     * @param f Folio trasiente con información temporal y definitiva
     * @return
     * @throws DAOException
     */
    private Folio getMaskedFolio(FolioEnhanced folio) throws DAOException {
        //Se transforma toda la información definitiva:
        Folio rta = (Folio) folio.toTransferObject();

        //Se cambia la información temporal básica del folio si se requiere
        FolioDatosTMP fTMP = folio.getDatosTMP();

        if (fTMP != null) {
            if (fTMP.getNupre() != null) {
                rta.setNupre(fTMP.getNupre());
            }

            if (fTMP.getDeterminaInm() != null) {
                rta.setDeterminaInm(fTMP.getDeterminaInm());
            }

            if (fTMP.getPrivMetros() != null) {
                rta.setPrivMetros(fTMP.getPrivMetros());
            }

            if (fTMP.getPrivCentimetros() != null) {
                rta.setPrivCentimetros(fTMP.getPrivCentimetros());
            }

            if (fTMP.getConsMetros() != null) {
                rta.setConsMetros(fTMP.getConsMetros());
            }

            if (fTMP.getConsCentimetros() != null) {
                rta.setConsCentimetros(fTMP.getConsCentimetros());
            }

            if (fTMP.getCoeficiente() != null) {
                rta.setCoeficiente(fTMP.getCoeficiente());
            }

            if (fTMP.getHectareas() != null) {
                rta.setHectareas(fTMP.getHectareas());
            }

            if (fTMP.getMetros() != null) {
                rta.setMetros(fTMP.getMetros());
            }

            if (fTMP.getCentimetros() != null) {
                rta.setCentimetros(fTMP.getCentimetros());
            }

            if (fTMP.getLindero() != null) {
                rta.setLindero(fTMP.getLindero());
            }

            if (fTMP.getCodCatastral() != null) {
                rta.setCodCatastral(fTMP.getCodCatastral());
            }

            if (fTMP.getCodCatastralAnterior() != null) {
                rta.setCodCatastralAnterior(fTMP.getCodCatastralAnterior());
            }

            // bug: 3580
            if (fTMP.getRadicacion() != null) {
                rta.setRadicacion(fTMP.getRadicacion());
            }

            if (fTMP.getFechaApertura() != null) {
                Date fecha = new Date(fTMP.getFechaApertura().getTime());
                rta.setFechaApertura(fecha);
            }

            if (fTMP.getZonaRegistral() != null) {
                String idZonaAnterior = rta.getZonaRegistral().getIdZonaRegistral();
                rta.setZonaRegistral((ZonaRegistral) (fTMP.getZonaRegistral().toTransferObject()));
            }

            if (fTMP.getEstado() != null) {
                EstadoFolio estado = (EstadoFolio) fTMP.getEstado().toTransferObject();
                estado.setComentario(fTMP.getComentarioCambioEstado());
                rta.setEstado(estado);
            }

            if (fTMP.getTipoPredio() != null) {
                rta.setTipoPredio((TipoPredio) fTMP.getTipoPredio()
                        .toTransferObject());
            }
        }

        //Se setea la complementación si existe una temporal
        if (folio.getComplementacionTMP() != null) {
            rta.setComplementacion((Complementacion) folio.getComplementacionTMP()
                    .getDefinitivo()
                    .toTransferObject());
            if (rta != null && rta.getComplementacion() != null && folio != null && folio.getComplementacion() != null) {
                rta.getComplementacion().setComplementacionConflictiva(folio.getComplementacion().getComplementacionConflictiva());
            }
        }

        //Se setea el documento si existe uno temporal
        if (folio.getDocumentoTMP() != null) {
            rta.setDocumento((Documento) folio.getDocumentoTMP().getDefinitivo()
                    .toTransferObject());
        }

        //Se agregan las direcciones temporales:
        List direccionesTMP = folio.getDireccionesTMPs();
        DireccionTMP dir;
        Direccion dirAux;

        for (Iterator it = direccionesTMP.iterator(); it.hasNext();) {
            dir = (DireccionTMP) it.next();
            dirAux = (Direccion) dir.getDefinitivo().toTransferObject();

            int indiceDir = rta.getDirecciones().indexOf(dirAux);
            Direccion dirToUpdate;
            if (indiceDir != -1) {
                dirToUpdate = (Direccion) rta.getDirecciones().get(indiceDir);
                if (dir.isToDelete()) {
                    rta.removeDireccione(dirToUpdate);
                }
            } else {
                dirAux.setOrden(dir.getOrden());
                rta.addDireccione(dirAux);
            }

        }

        //Se agregan las salvedades temporales:
        List salvedadesTMP = folio.getSalvedadesTMPs();
        SalvedadFolioTMP sal;

        SalvedadFolio local_TrSalvedadFolio;

        for (Iterator it = salvedadesTMP.iterator(); it.hasNext();) {
            sal = (SalvedadFolioTMP) it.next();
            // Bug 05354
            local_TrSalvedadFolio = (SalvedadFolio) sal.getDefinitivo().toTransferObject();
            local_TrSalvedadFolio.setTemporal(true);
            rta.addSalvedade(local_TrSalvedadFolio);

        }

        //Se agregan las anotaciones temporales:
        List anotacionesTMP = null;
        try {
            anotacionesTMP = folio.getAnotacionesTMPs();
        } catch (NullPointerException e) {
            // no tiene anotaciones temporales
        }
        if (anotacionesTMP != null) {
            AnotacionTMP anota;
            List cache;
            Anotacion anotaAux;

            for (Iterator it = anotacionesTMP.iterator(); it.hasNext();) {
                anota = (AnotacionTMP) it.next();
                cache = new ArrayList();
                anotaAux = (Anotacion) anota.getDefinitivo(cache).toTransferObject();

                int indice;
                Anotacion anToUpdate;
                indice = rta.getAnotaciones().indexOf(anotaAux);

                if (indice != -1) {
                    //La anotacion temporal representa una actualización a la anotación
                    //definitiva
                    anToUpdate = (Anotacion) rta.getAnotaciones().get(indice);

                    anToUpdate.setTemporal(true);
                    // anToUpdate.setTemporalConContraparteDefinitiva( true );

                    if (anotaAux.getEstado() != null) {
                        anToUpdate.setEstado(anotaAux.getEstado());
                    }

                    if (anotaAux.getNaturalezaJuridica() != null) {
                        anToUpdate.setNaturalezaJuridica(anotaAux.getNaturalezaJuridica());
                    }

                    if (anotaAux.getTipoAnotacion() != null) {
                        anToUpdate.setTipoAnotacion(anotaAux.getTipoAnotacion());
                    }

                    if (anotaAux.getOrden() != null) {
                        anToUpdate.setOrden(anotaAux.getOrden());
                        anToUpdate.setOrdenLPAD(anotaAux.getOrdenLPAD());
                        reinsertarAnotacionEnOrden(rta, indice);
                    }

                    if (anotaAux.getEspecificacion() != null) {
                        anToUpdate.setEspecificacion(anotaAux.getEspecificacion());
                    }

                    if (anotaAux.getComentario() != null) {
                        anToUpdate.setComentario(anotaAux.getComentario());
                    }

                    if (anotaAux.getValor() != anToUpdate.getValor()) {
                        anToUpdate.setValor(anotaAux.getValor());
                    }

                    if (anotaAux.getFechaRadicacion() != null) {
                        anToUpdate.setFechaRadicacion(anotaAux.getFechaRadicacion());
                    }

                    if (anotaAux.getNumRadicacion() != null) {
                        anToUpdate.setNumRadicacion(anotaAux.getNumRadicacion());
                    }

                    //Se setea el documento si existe uno temporal
                    if (anota.getDocumentoTMP() != null) {
                        anToUpdate.setDocumento((Documento) anota.getDocumentoTMP().getDefinitivo()
                                .toTransferObject());
                    }

                    //Miramos los ciudadanos de la anotacion que se deben,
                    //insertar o borrar
                    AnotacionCiudadano anCiudAux;

                    for (Iterator it2 = anotaAux.getAnotacionesCiudadanos()
                            .iterator(); it2.hasNext();) {
                        anCiudAux = (AnotacionCiudadano) it2.next();

                        if (anToUpdate.getAnotacionesCiudadanos().contains(anCiudAux)) {
                            //Se debe actualizar o borrar el ciudadano del objeto
                            if (anCiudAux.isToDelete()) {
                                anToUpdate.removeAnotacionesCiudadano(anCiudAux);
                            }
                        } else {
                            //Se debe agregar el ciudadano
                            anToUpdate.addAnotacionesCiudadano(anCiudAux);
                        }
                    }

                    //Miramos las salvedades de la anotacion que se deben,
                    //insertar o borrar
                    SalvedadAnotacion salAux;

                    for (Iterator it3 = anotaAux.getSalvedades().iterator();
                            it3.hasNext();) {
                        salAux = (SalvedadAnotacion) it3.next();

                        if (anToUpdate.getSalvedades().contains(salAux)) {
                            //Se debe actualizar o borrar el ciudadano del objeto
                            if (salAux.isToDelete()) {
                                anToUpdate.removeSalvedade(salAux);
                            } else {
                                if (salAux.getDescripcion() != null) {
                                    int ind = anToUpdate.getSalvedades().indexOf(salAux);
                                    SalvedadAnotacion salToUpdate = (SalvedadAnotacion) anToUpdate.getSalvedades()
                                            .get(ind);
                                    salToUpdate.setDescripcion(salAux.getDescripcion());
                                }
                            }
                        } else {
                            //Se debe agregar la salvedad
                            anToUpdate.addSalvedade(salAux);
                        }
                    }

                    //Miramos las cancelaciones de la anotacion que se deben,
                    //insertar o borrar
                    Cancelacion anCancelAux;

                    for (Iterator it2 = anotaAux.getAnotacionesCancelacions().iterator();
                            it2.hasNext();) {
                        anCancelAux = (Cancelacion) it2.next();

                        if (anToUpdate.getAnotacionesCancelacions().contains(anCancelAux)) {
                            //Se debe actualizar o borrar la cancelacion
                            if (anCancelAux.isToDelete()) {
                                anToUpdate.removeAnotacionesCancelacion(anCancelAux);
                            }
                        } else {
                            //Se debe agregar el ciudadano
                            anToUpdate.addAnotacionesCancelacion(anCancelAux);
                        }
                    }

                } else {
                    //*if (!anotaAux.getEstado().getIdEstadoAn().equals(CEstadoAnotacion.OBSOLETA)) {
                    anotaAux.setTemporal(true);
                    rta.addAnotacione(anotaAux);
                    //*}
                }
            }
        }

        return rta;
    }

    /**
     * @param rta
     * @param indice
     */
    private void reinsertarAnotacionEnOrden(Folio rta, int indice) {
        long tam = rta.getAnotaciones().size();
        Anotacion anota = (Anotacion) rta.getAnotaciones().get(indice);
        Anotacion aux;
        Anotacion aux2;
        boolean reordenar = false;

        //Precondición: la lista NO es vacía.
        //1. caso: La anotación es la última de la lista: (o solo existe una anotacion)
        if ((tam - 1) == indice) {

            // Bug: ( tam=1, indice =0 )
            if ((tam == 1) && (indice == 0)) {
                aux = (Anotacion) rta.getAnotaciones().get(0);
            } else {

                aux = (Anotacion) rta.getAnotaciones().get(indice - 1);

            } // if

            if (anota.getOrdenLPAD().compareTo(aux.getOrdenLPAD()) < 0) {
                reordenar = true;
            }
        } // 2. caso: La anotación es la primera de la lista (ya existe por lo menos 2 por descarte del caso 1)
        else if (indice == 0) {
            aux = (Anotacion) rta.getAnotaciones().get(1);

            if (anota.getOrdenLPAD().compareTo(aux.getOrdenLPAD()) > 0) {
                reordenar = true;
            }
        } //3. caso: la anotación tiene anotacion anterior y anotacion siguiente
        else {
            aux = (Anotacion) rta.getAnotaciones().get(indice - 1);
            aux2 = (Anotacion) rta.getAnotaciones().get(indice + 1);

            if ((anota.getOrdenLPAD().compareTo(aux.getOrdenLPAD()) < 0)
                    || (anota.getOrdenLPAD().compareTo(aux2.getOrdenLPAD()) > 0)) {
                reordenar = true;
            }
        }

        // Si se puso el flag de reordenar en true se procede a ubicar la anotación
        // dentro de la lista de manera ordenada
        if (reordenar) {
            // 1. Se saca el elemento de la lista:
            rta.removeAnotacione(anota);

            int nuevoTam = rta.getAnotaciones().size();

            // 2. Se busca la posición para insertarlo
            int primero = 0;
            int ultimo = nuevoTam - 1;
            int mitad;
            Anotacion anotaMitad;

            boolean notFound = true;

            while (notFound) {
                if (primero == ultimo) {
                    aux = (Anotacion) rta.getAnotaciones().get(primero);

                    if (anota.getOrdenLPAD().compareTo(aux.getOrdenLPAD()) > 0) {
                        rta.addAnotacion(primero + 1, anota);
                    } else {
                        rta.addAnotacion(primero, anota);
                    }

                    notFound = false;
                } else if (primero == (ultimo - 1)) {
                    //El primero y el ultimo están seguidos, revisamos las posibles maneras de inserción
                    aux = (Anotacion) rta.getAnotaciones().get(ultimo);
                    aux2 = (Anotacion) rta.getAnotaciones().get(primero);

                    //Si el elemento que se quiere insertar es mayor que el último, se inserta después.
                    if (anota.getOrdenLPAD().compareTo(aux.getOrdenLPAD()) > 0) {
                        rta.addAnotacion(ultimo + 1, anota);
                    } //Si el elemento que se quiere insertar es menor que el primero, se inserta antes.
                    else if (anota.getOrdenLPAD().compareTo(aux2.getOrdenLPAD()) < 0) {
                        rta.addAnotacion(primero, anota);
                    } //En otro caso se inserta en la mitad
                    else {
                        rta.addAnotacion(ultimo, anota);
                    }

                    notFound = false;
                } else {
                    //Miramos la anotación de la mitad
                    mitad = (primero + ultimo) / 2;
                    anotaMitad = (Anotacion) rta.getAnotaciones().get(mitad);

                    if (anota.getOrdenLPAD().compareTo(anotaMitad.getOrdenLPAD()) > 0) {
                        primero = mitad;
                    } else {
                        ultimo = mitad;
                    }
                }
            }
        }
    }

    /**
     * Delega el bloqueo de todos los folios asociados al turno Si algún folio
     * no está bloqueado se genera una excepcion guardada en un hashtable donde
     * la llave es el número de matrícula y el valor es la descripción del error
     *
     * @param oid
     * @param usuario
     * @return
     * @throws DAOException
     */
    public LlaveBloqueo delegarBloqueoFolios(TurnoPk oid, Usuario usuario)
            throws DAOException {
        long milisec = 0;
        milisec = new Date().getTime();
        LlaveBloqueo rta = null;

        //rta = delegarBloqueoFoliosJDO(oid, usuario);
        rta = delegarBloqueoFoliosPLSQL(oid, usuario);

        return rta;
    }

    /**
     * Delega el bloqueo de todos los folios asociados al turno Si algún folio
     * no está bloqueado se genera una excepcion guardada en un hashtable donde
     * la llave es el número de matrícula y el valor es la descripción del
     * error.
     *
     * Esta implementación delega la lógica a un procedimiento almacenado en
     * Base de datoas: PCK_SIR_VALIDACIONES.sp_delegar_bloqueo_folios
     * (p_id_workflow IN VARCHAR2, p_id_usuario IN NUMBER, o_errores OUT
     * t_matriculas_val, o_llave_bloqueo OUT NUMBER) ver
     * SIR_DIR/scripts/procedures/delegarBloqueoFolios/PCK_SIR_VALIDACIONES_SPEC.pks
     * SIR_DIR/scripts/procedures/delegarBloqueoFolios/PCK_SIR_VALIDACIONES_BODY.pkb
     *
     */
    private LlaveBloqueo delegarBloqueoFoliosPLSQL(TurnoPk oid, Usuario usuario)
            throws DAOException {
        LlaveBloqueo rta = null;
        Hashtable mapaErrores = null;

        Connection con = null;
        OracleCallableStatement cst = null;

        VersantPersistenceManager pm = null;

        try {
            pm = (VersantPersistenceManager) AdministradorPM.getPM();
            pm.currentTransaction().begin();
            con = pm.getJdbcConnection(null);

            // Declaración del objeto en el que se obtendrán los errores de 
            // validacion: parametro o_errores
            Object[] p2arrobj;

            // Objeto retornado por la BD en el parámetro de salida o_error
            ARRAY p2arr;

            // Lógica de invocación al pl
            cst = (OracleCallableStatement) con.prepareCall("{call PCK_SIR_VALIDACIONES.SP_DELEGAR_BLOQUEO_FOLIOS(?,?,?,?)}");
            cst.setString(1, oid.toString());
            cst.setLong(2, usuario.getIdUsuario());

            // Se registran los parametros de salida del pl
            cst.registerOutParameter(3, OracleTypes.ARRAY, "T_MATRICULAS_VAL");
            cst.registerOutParameter(4, Types.INTEGER);

            // ejecución del PL en la BD
            cst.execute();

            // Colección asociativa que contiene los posibles errores de validación
            p2arr = cst.getARRAY(3);

            if (p2arr != null) {
                mapaErrores = new Hashtable();

                // Se obtiene un arreglo de los objetos tipo T_MATRICULAS_OBJ
                p2arrobj = (Object[]) p2arr.getArray();

                // Los atributos de T_MATRICULAS_OBJ se recuperan como arreglos
                for (int i = 0; i < p2arrobj.length; i++) {
                    Object[] piarrobj = ((STRUCT) p2arrobj[i]).getAttributes();
                    if (piarrobj.length == 2) {
                        mapaErrores.put(piarrobj[0], piarrobj[1]);
                    }
                }
            }

            if (mapaErrores != null && !mapaErrores.isEmpty()) {
                DAOException exc = new DAOException(
                        "Error en validación de delegación de bloqueos de folios");
                exc.setHashErrores(mapaErrores);
                throw exc;
            }

            // El PL retorna el ID_LLAVE del bloqueo creado en el 
            // parametro o_llave_bloqueo
            int llave = cst.getInt(4);

            if (llave != 0) {
                LlaveBloqueoEnhancedPk llavePk = new LlaveBloqueoEnhancedPk();
                llavePk.idLlave = Integer.toString(llave);

                rta = this.getLlaveBloqueo(llavePk.getLlaveBloqueoID());
            } else {
                rta = null;
            }

            pm.currentTransaction().commit();

        } catch (SQLException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            String mensaje = e.getMessage();
            // CODIGO DE EXCEPCION PERSONALIZADO (20000,29999): ERROR DE VALIDACIÓN DE NEGOCIO
            if (e.getErrorCode() >= 20000 && e.getErrorCode() < 30000) {
                mensaje = mensaje.substring(21, mensaje.length());
                int ipos = mensaje.indexOf("ORA-");
                mensaje = mensaje.substring(1, ipos);
                /**
                 * @author Cesar Ramírez
                 * @change: 1156.111.USUARIOS.ROLES.INACTIVOS Obtiene el mensaje
                 * y envía la excepción generada en el DAO
                 *
                 */
                DAOException ex = new DAOException(mensaje);
                ex.addError(mensaje);
                throw ex;
            }
            // Error de Oracle
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(mensaje, e);
        } catch (DAOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            throw e;
        } catch (Exception e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            try {
                if (cst != null) {
                    cst.close();
                }
                if (con != null) {
                    con.close();
                }
            } catch (SQLException ex) {
                ex.printStackTrace();
            }

            pm.close();
        }

        return rta;
    }

    /**
     * Segrega un folio a través de un procedimiento almacenado en PL/SLQ
     *
     * @param datos Datos del folio a segregar
     * @param oid ID el turno a segregar
     * @author : Julio Alcázar Rivas
     * @change : se agrega nuevo param al metodo SalvedadAnotacion salvedad Caso
     * Mantis : 04131
     * @return List con los folios segregados
     * @throws Throwable
     */
    public List segregarFolioPLSQL(Folio datos, TurnoPk oid, SalvedadAnotacion salvedad, String IdAnotacionDef) throws DAOException {
        List foliosSegregados = new ArrayList();

        VersantPersistenceManager pm = (VersantPersistenceManager) AdministradorPM.getPM();
        Connection con = null;
        OracleCallableStatement cst = null;

        try {
            pm.currentTransaction().begin();
            con = pm.getJdbcConnection(null);

            //Lógica de invocación al pl
            cst = (OracleCallableStatement) con.prepareCall("{call SP_SG(?)}");
            cst.setString(1, oid.toString());

            // ejecución del PL en la BD
            cst.execute();

            //TFS 4322: Se comentarea esta porcion de codigo para mejorar el desempeño
            /*foliosSegregados = this.getFoliosDerivadosTMP(datos.getIdMatricula(), pm);
    			
    			FolioDerivadoTMP fdTMP;

                for (Iterator it = foliosSegregados.iterator();
                        it.hasNext();) {
                    fdTMP = (FolioDerivadoTMP) it.next();
                    this.makeTransientAnotacionTMP(fdTMP.getHijoTmp(), pm,
                        new ArrayList());
                    this.makeTransientAnotacionTMP(fdTMP.getPadreTmp(), pm,
                        new ArrayList());
                    pm.makeTransient(fdTMP);
                    rta.add(fdTMP.getDefinitivo(new ArrayList()));
                }*/
 /*
                 * Si el folio tiene salvedades, estas se agregan
                 * */

 /*
                 * @author      :   Julio Alcázar Rivas
                 * @change      :   1) Se obtiene la anotacion temporal AnotacionTMPPk anotacionPk para agregarle la salvedad
                 *                  2) Se modifica el tipo de salvedad de tipo SalvedadFolio por SalvedadAnotacionTMP
                 * Caso Mantis  :   04131
             */
            AnotacionTMP anotacion = null;
            AnotacionTMPPk anotacionPk = new AnotacionTMPPk();
            anotacionPk.idMatricula = datos.getIdMatricula();
            if (IdAnotacionDef != null) {
                anotacionPk.idAnotacionTmp = IdAnotacionDef;
                anotacion = this.getAnotacionTMPByID(anotacionPk, pm);
            } else {
                anotacionPk.idAnotacionTmp = Long.toString(datos.getLastIdAnotacion() + 1);
                FolioEnhancedPk fdtId = new FolioEnhancedPk();
                fdtId.idMatricula = datos.getIdMatricula();
                FolioEnhanced folio = this.getFolioByID(fdtId, pm);
                if (folio.getLastIdAnotacionTMP() > datos.getLastIdAnotacion()) {
                    anotacionPk.idAnotacionTmp = Long.toString(folio.getLastIdAnotacionTMP());
                }

                anotacion = this.getAnotacionTMPByID(anotacionPk, pm);
            }
            if (salvedad != null) {
                Usuario usu = this.getUsuarioBloqueoFolio(new FolioPk(datos.getIdMatricula()));
                UsuarioEnhanced us = this.getUsuarioByID(new UsuarioEnhancedPk(new Long(usu.getIdUsuario()).toString()), pm);
                SalvedadAnotacionTMP salvTmp = new SalvedadAnotacionTMP();
                salvTmp.setDescripcion(salvedad.getDescripcion());
                salvTmp.setIdMatricula(salvedad.getIdMatricula());
                salvTmp.setNumRadicacion(salvedad.getNumRadicacion());
                this.addSalvedadToAnotacionTMP(anotacion, salvTmp, us, pm);
                pm.makePersistent(salvTmp);
            }

            pm.currentTransaction().commit();

        } catch (SQLException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            foliosSegregados = null;
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage());
        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            foliosSegregados = null;
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (DAOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            foliosSegregados = null;
            throw e;
        } catch (Exception e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            foliosSegregados = null;
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            try {
                if (cst != null) {
                    cst.close();
                }
                if (con != null) {
                    con.close();
                }
            } catch (SQLException e) {
            }

            pm.close();
        }

        return foliosSegregados;
    }

    /**
     * Delega el bloqueo de todos los folios asociados al turno Si algún folio
     * no está bloqueado se genera una excepcion guardada en un hashtable donde
     * la llave es el número de matrícula y el valor es la descripción del error
     *
     * @param oid
     * @param usuario
     * @return
     * @throws DAOException
     */
    private LlaveBloqueo delegarBloqueoFoliosJDO(TurnoPk oid, Usuario usuario)
            throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        EstadoFolio aux = null;
        LlaveBloqueoEnhanced llave = null;
        String matricula;
        Hashtable ht = new Hashtable();

        LlaveBloqueoEnhancedPk rta;
        UsuarioEnhanced us = UsuarioEnhanced.enhance(usuario);
        UsuarioEnhancedPk usId = new UsuarioEnhancedPk();
        usId.idUsuario = us.getIdUsuario();

        BloqueoFolioEnhanced bloqueo = null;
        TurnoEnhanced turno;
        List matriculas;
        SolicitudFolioEnhanced sf;

        try {
            pm.currentTransaction().setOptimistic(false);
            pm.currentTransaction().begin();

            //Validación del turno:
            turno = this.getTurnoByID(new TurnoEnhancedPk(oid), pm);

            if (turno == null) {
                throw new DAOException(
                        "No se encontró el turno con el ID especificado");
            }

            //Se obtiene la lista de folios asociados al turno
            List folios = turno.getSolicitud().getSolicitudFolios();

            /*
            if (folios.size() == 0) {
            throw new DAOException("El turno no tiene matrículas asociadas");
            }*/
            //Validación del usuario
            us = this.getUsuarioByID(usId, pm);

            if (us == null) {
                throw new DAOException("El usuario especificado no existe");
            }

            if (turno.getModoBloqueo() == CModoBloqueo.NORMAL) {
                //Las matrículas se deben bloquear de manera normal
                //es decir validando si los folios están bloqueados
                //por otro usuario
                llave = this.bloquearFolios(turno, us, pm);
            } else {
                //Las matriculas se deben bloquear tomando el bloqueo
                //de otro usuario
                if (turno.getModoBloqueo() == CModoBloqueo.DELEGAR_USUARIO) {
                    //Este modo tiene que validar que el usuario
                    //destino tiene que ser el mismo del usuario
                    //que lo bloquea
                    if (turno.getUsuarioDestino() == null) {
                        throw new DAOException(
                                "El bloqueo debe validar usuario destino y no lo tiene en el turno");
                    }

                    if (turno.getUsuarioDestino().getIdUsuario() != us.getIdUsuario()) {
                        throw new DAOException(
                                "El usuario no puede tomar el bloqueo de los folios puesto que no es el usuario destino, el usuario autorizado para tomar el bloqueo es: "
                                + turno.getUsuarioDestino().getUsername());
                    }
                } else if (turno.getModoBloqueo() != CModoBloqueo.DELEGAR_CUALQUIERA) {
                    //Este es el último modo que se valida, si es diferente se
                    //lanza excepción
                    throw new DAOException("Modo de bloqueo inválido: turno: "
                            + turno.getIdWorkflow());
                }

                //En este punto podemos quitarle el bloqueo al usuario actual
                //y delegárselo al usuario que lo está requiriendo
                //Se crea una nueva llave de bloqueo
                llave = this.crearLlaveBloqueo(pm);

                //Se agrega la llave de bloqueo al usuario
                us.addLlavesBloqueo(llave);

                //Se recorre la lista de matrículas, se hacen las validaciones para cada una
                for (Iterator itr = folios.iterator(); itr.hasNext();) {
                    sf = (SolicitudFolioEnhanced) itr.next();
                    matricula = sf.getIdMatricula();

                    FolioEnhanced folio = sf.getFolio();

                    //Se valida que la matrícula se encuentre bloqueada y se obtiene
                    //el objeto bloqueoFolio
                    bloqueo = this.getBloqueoFolio(matricula, pm);

                    if (bloqueo != null) {

                        TurnoEnhancedPk turnoId = new TurnoEnhancedPk();
                        turnoId.anio = turno.getAnio();
                        turnoId.idCirculo = turno.getIdCirculo();
                        turnoId.idProceso = turno.getIdProceso();
                        turnoId.idTurno = turno.getIdTurno();
                        TurnoEnhanced turnoDerivado = this.getTurnoDependiente(turnoId, pm);
                        TurnoEnhanced turnoPadre = this.getTurnoPadre(turnoId, pm);

                        //se validar que el bloqueo lo tenga por lo menos el mismo usuario
                        boolean usuTieneBloqueoFolio = false;

                        //La matricula esta bloqueada
                        //Validamos que el usuario sea dueño del bloqueo del folio
                        UsuarioEnhanced usuAux = this.getUsuarioByLlaveBloqueo(bloqueo.getLlaveBloqueo(),
                                pm);

                        if (usuAux == null) {
                            throw new DAOException(
                                    "Error en la obtención del usuario a partir de la llave de bloqueo");
                        }

                        //En caso que el usuario sea el dueño del bloqueo lo deja pasar
                        if (usuAux.getIdUsuario() == us.getIdUsuario()) {
                            usuTieneBloqueoFolio = true;
                        }

                        //Se valida que se encuentre bloqueado en el mismo turno
                        if (!usuTieneBloqueoFolio) {
                            if (!turno.getIdWorkflow().equals(bloqueo.getIdWorkflowBloqueo())
                                    && (turnoPadre == null || !turnoPadre.getIdWorkflow().equals(bloqueo.getIdWorkflowBloqueo()))
                                    && (turnoDerivado == null || !turnoDerivado.getIdWorkflow().equals(bloqueo.getIdWorkflowBloqueo()))) {
                                ht.put(matricula, "La matrícula está bloqueada en otro turno: " + bloqueo.getIdWorkflowBloqueo());
                            }
                        }

                        if (!usuTieneBloqueoFolio) {
                            //Se desbloquea la matricula
                            BloqueoFolioEnhanced viejo = (BloqueoFolioEnhanced) auditoria.clonarEnhanced(bloqueo);
                            bloqueo.setFechaDesbloqueo(new Date());
                            // Asocia la matricula a la nueva llave de bloqueo
                            BloqueoFolioEnhanced bl = new BloqueoFolioEnhanced();
                            bl.setFechaBloqueo(new Date());
                            bl.setFolio(folio);
                            bl.setLlaveBloqueo(llave);
                            bl.setIdWorkflowBloqueo(turno.getIdWorkflow());
                            pm.makePersistent(bl);
                        }
                    } else {
                        //SE SETEAN LAS SECUENCIAS DE LAS LISTAS TEMPORALES:
                        this.resetSecuenciasTemporalesFolio(folio, pm);

                        //Asocia la matricula a la nueva llave de bloqueo
                        BloqueoFolioEnhanced bl = new BloqueoFolioEnhanced();
                        bl.setFechaBloqueo(new Date());
                        bl.setFolio(folio);
                        bl.setLlaveBloqueo(llave);
                        bl.setIdWorkflowBloqueo(turno.getIdWorkflow());
                        pm.makePersistent(bl);
                    }

                }

                if (ht.size() > 0) {
                    DAOException exc = new DAOException(
                            "Error en validación de delegación de bloqueos de folios");
                    exc.setHashErrores(ht);
                    throw exc;
                }
            }

            //Se cambia el modo de bloqueo de nuevo a normal
            turno.setModoBloqueo(CModoBloqueo.NORMAL);

            pm.currentTransaction().commit();

            if (llave != null) {
                rta = (LlaveBloqueoEnhancedPk) pm.getObjectId(llave);

                return this.getLlaveBloqueo(rta.getLlaveBloqueoID());
            } else {
                return null;
            }
        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (DAOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            throw e;
        } catch (Exception e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }
    }

    /**
     * Delega el bloqueo de todos los folios asociados al turno
     *
     * @param oid
     * @param usuario
     * @return
     * @throws DAOException
     */
    public LlaveBloqueo delegarBloqueoFoliosObligatorio(TurnoPk oid, Usuario usuario)
            throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        EstadoFolio aux = null;
        LlaveBloqueoEnhanced llave = null;
        String matricula;
        Hashtable ht = new Hashtable();

        LlaveBloqueoEnhancedPk rta;
        UsuarioEnhanced us = UsuarioEnhanced.enhance(usuario);
        UsuarioEnhancedPk usId = new UsuarioEnhancedPk();
        usId.idUsuario = us.getIdUsuario();

        BloqueoFolioEnhanced bloqueo = null;
        TurnoEnhanced turno;
        List matriculas;
        SolicitudFolioEnhanced sf;

        try {
            pm.currentTransaction().setOptimistic(false);
            pm.currentTransaction().begin();

            //Validación del turno:
            turno = this.getTurnoByID(new TurnoEnhancedPk(oid), pm);

            if (turno == null) {
                throw new DAOException(
                        "No se encontró el turno con el ID especificado");
            }

            // Se tien que validar que sea el menor
            boolean isMenor = true;
            List turnosQueCompartenFolios = this.getTurnosRegistroCompartenFolios(turno, turno.getIdCirculo(), pm);

            //Ahora se revisa si alguno de esos turnos tiene fecha anterior al turno actual
            //y se encuentra entre calificación y firma
            List turnosQueNoHanSidoFirmados = new ArrayList();
            TurnoEnhanced turnoToValidate;
            for (Iterator it2 = turnosQueCompartenFolios.iterator(); it2.hasNext();) {
                turnoToValidate = (TurnoEnhanced) it2.next();

                //1. Si el turno ya está finalizado NO se tiene en cuenta
                if (turnoToValidate.getFechaFin() != null) {
                    continue;
                }

                //2. Si el turno no tiene fecha anterior no se tiene en cuenta
                if (turnoToValidate.getFechaInicio().after(turno.getFechaInicio())) {
                    continue;
                }

                isMenor = false;
            }

            if (isMenor) {
                //Se obtiene la lista de folios asociados al turno
                List folios = turno.getSolicitud().getSolicitudFolios();

                //Validación del usuario
                us = this.getUsuarioByID(usId, pm);

                if (us == null) {
                    throw new DAOException("El usuario especificado no existe");
                }

                //En este punto podemos quitarle el bloqueo al usuario actual
                //y delegárselo al usuario que lo está requiriendo
                //Se crea una nueva llave de bloqueo
                llave = this.crearLlaveBloqueo(pm);

                //Se agrega la llave de bloqueo al usuario
                us.addLlavesBloqueo(llave);

                //Se recorre la lista de matrículas, se hacen las validaciones para cada una
                for (Iterator itr = folios.iterator(); itr.hasNext();) {
                    sf = (SolicitudFolioEnhanced) itr.next();
                    matricula = sf.getIdMatricula();

                    FolioEnhanced folio = sf.getFolio();

                    //Se valida que la matrícula se encuentre bloqueada y se obtiene
                    //el objeto bloqueoFolio
                    bloqueo = this.getBloqueoFolio(matricula, pm);

                    if (bloqueo != null) {

                        TurnoEnhancedPk turnoId = new TurnoEnhancedPk();
                        turnoId.anio = turno.getAnio();
                        turnoId.idCirculo = turno.getIdCirculo();
                        turnoId.idProceso = turno.getIdProceso();
                        turnoId.idTurno = turno.getIdTurno();

                        //se validar que el bloqueo lo tenga por lo menos el mismo usuario
                        boolean usuTieneBloqueoFolio = false;

                        //La matricula esta bloqueada
                        //Validamos que el usuario sea dueño del bloqueo del folio
                        UsuarioEnhanced usuAux = this.getUsuarioByLlaveBloqueo(bloqueo.getLlaveBloqueo(),
                                pm);

                        if (usuAux == null) {
                            throw new DAOException(
                                    "Error en la obtención del usuario a partir de la llave de bloqueo");
                        }

                        //En caso que el usuario sea el dueño del bloqueo lo deja pasar
                        if (usuAux.getIdUsuario() == us.getIdUsuario()) {
                            usuTieneBloqueoFolio = true;
                        }

                        if (usuTieneBloqueoFolio && bloqueo.getIdWorkflowBloqueo() != null && !bloqueo.getIdWorkflowBloqueo().equals(turno.getIdWorkflow())) {
                            //Se desbloquea la matricula
                            BloqueoFolioEnhanced viejo = (BloqueoFolioEnhanced) auditoria.clonarEnhanced(bloqueo);
                            bloqueo.setFechaDesbloqueo(new Date());

                            // Asocia la matricula a la nueva llave de bloqueo
                            BloqueoFolioEnhanced bl = new BloqueoFolioEnhanced();
                            bl.setFechaBloqueo(new Date());
                            bl.setFolio(folio);
                            bl.setLlaveBloqueo(llave);
                            bl.setIdWorkflowBloqueo(turno.getIdWorkflow());
                            pm.makePersistent(bl);

                        }
                    }
                }
            }
            pm.currentTransaction().commit();

            if (llave != null) {
                rta = (LlaveBloqueoEnhancedPk) pm.getObjectId(llave);
                return this.getLlaveBloqueo(rta.getLlaveBloqueoID());
            }
        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (DAOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            throw e;
        } catch (Exception e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }
        return null;
    }

    /**
     * Obtiene una solicitudFolio dado la solicitud y el folio persistentes, si
     * no encuentra ninguna relación retorna null
     *
     * @param sol
     * @param fol
     * @param pm
     * @return
     * @throws DAOException
     */
    protected SolicitudFolioEnhanced getSolicitudFolio(SolicitudEnhanced sol, FolioEnhanced fol,
            PersistenceManager pm) throws DAOException {
        SolicitudFolioEnhanced rta = null;

        try {

            //Se establece como criterio de búsqueda el identificador
            //de la Matrícula.
            Query query = pm.newQuery(SolicitudFolioEnhanced.class);
            query.declareParameters("SolicitudEnhanced sol, FolioEnhanced fol");
            query.setFilter("solicitud==sol && folio==fol");
            query.setOrdering("solicitud.fecha descending, idSolicitud descending");

            Collection col = (Collection) query.execute(sol, fol);

            Iterator iter = col.iterator();

            if (iter.hasNext()) {
                rta = (SolicitudFolioEnhanced) iter.next();
            }

        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (Throwable t) {
            Log.getInstance().error(JDOGenieFolioDAO.class, t.getMessage());
            throw new DAOException(t.getMessage(), t);
        }

        return rta;
    }

    /**
     * Delega el bloqueo de un folio dentro de un turno al usuario especificado
     *
     * @param oid
     * @param usuario
     * @param fid
     * @return
     * @throws DAOException
     */
    public LlaveBloqueo delegarBloqueoFolio(TurnoPk oid, Usuario usuario, FolioPk fid)
            throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        EstadoFolio aux = null;
        LlaveBloqueoEnhanced llave = null;
        LlaveBloqueo llaveRta = null;
        String matricula;
        Hashtable ht = new Hashtable();

        LlaveBloqueoEnhancedPk rta;
        UsuarioEnhanced us = UsuarioEnhanced.enhance(usuario);
        UsuarioEnhancedPk usId = new UsuarioEnhancedPk();
        usId.idUsuario = us.getIdUsuario();

        BloqueoFolioEnhanced bloqueo = null;
        TurnoEnhanced turno;
        List matriculas;
        SolicitudFolioEnhanced sf;

        try {
            //pm.currentTransaction().setOptimistic(false);
            pm.currentTransaction().begin();

            //Validación del turno:
            turno = this.getTurnoByID(new TurnoEnhancedPk(oid), pm);

            if (turno == null) {
                throw new DAOException(
                        "No se encontró el turno con el ID especificado");
            }

            //Se obtiene el folio
            FolioEnhanced folio = this.getFolioByID(new FolioEnhancedPk(fid), pm);

            if (folio == null) {
                throw new DAOException("El folio NO existe");
            }

            matricula = folio.getIdMatricula();

            //Se valida que el folio esté asociado al turno
            SolicitudFolioEnhanced solFol = this.getSolicitudFolio(turno.getSolicitud(), folio, pm);

            if (solFol == null) {
                throw new DAOException("El folio NO está asociado al turno");
            }

            //Validación del usuario
            us = this.getUsuarioByID(usId, pm);

            if (us == null) {
                throw new DAOException("El usuario especificado no existe");
            }

            if (turno.getModoBloqueo() == CModoBloqueo.NORMAL) {
                //Las matrículas se deben bloquear de manera normal
                //es decir validando si los folios están bloqueados
                //por otro usuario
                List mats = new ArrayList();
                mats.add(matricula);
                llaveRta = this.bloquearFolios(mats, usuario, oid);

            } else {
                //Las matriculas se deben bloquear tomando el bloqueo
                //de otro usuario
                if (turno.getModoBloqueo() == CModoBloqueo.DELEGAR_USUARIO) {
                    //Este modo tiene que validar que el usuario
                    //destino tiene que ser el mismo del usuario
                    //que lo bloquea
                    if (turno.getUsuarioDestino() == null) {
                        throw new DAOException(
                                "El bloqueo debe validar usuario destino y no lo tiene en el turno");
                    }

                    if (turno.getUsuarioDestino().getIdUsuario() != us.getIdUsuario()) {
                        throw new DAOException(
                                "El usuario no puede tomar el bloqueo de los folios puesto que no es el usuario destino, el usuario autorizado para tomar el bloqueo es: "
                                + turno.getUsuarioDestino().getUsername());
                    }
                } else if (turno.getModoBloqueo() != CModoBloqueo.DELEGAR_CUALQUIERA) {
                    //Este es el último modo que se valida, si es diferente se
                    //lanza excepción
                    throw new DAOException("Modo de bloqueo inválido: turno: "
                            + turno.getIdWorkflow());
                }

                //En este punto podemos quitarle el bloqueo al usuario actual
                //y delegárselo al usuario que lo está requiriendo
                //Se crea una nueva llave de bloqueo
                llave = this.crearLlaveBloqueo(pm);

                //Se agrega la llave de bloqueo al usuario
                us.addLlavesBloqueo(llave);

                //Se valida que la matrícula se encuentre bloqueada y se obtiene
                //el objeto bloqueoFolio
                bloqueo = this.getBloqueoFolio(matricula, pm);

                if (bloqueo != null) {

                    // se validar que el bloqueo lo tenga por lo menos el mismo usuario
                    boolean usuTieneBloqueoFolio = false;

                    //La matricula esta bloqueada
                    //Validamos que el usuario sea dueño del bloqueo del folio
                    UsuarioEnhanced usuAux = this.getUsuarioByLlaveBloqueo(bloqueo.getLlaveBloqueo(),
                            pm);

                    if (usuAux == null) {
                        throw new DAOException(
                                "Error en la obtención del usuario a partir de la llave de bloqueo");
                    }

                    //En caso que el usuario sea el dueño del bloqueo lo deja pasar
                    if (usuAux.getIdUsuario() == us.getIdUsuario()) {
                        usuTieneBloqueoFolio = true;
                    }

                    //Se valida que se encuentre bloqueado en el mismo turno
                    if (!usuTieneBloqueoFolio) {
                        //Se valida que se encuentre bloqueado en el mismo turno
                        if (!turno.getIdWorkflow().equals(bloqueo.getIdWorkflowBloqueo())) {
                            ht.put(matricula, "La matrícula está bloqueada en otro turno: " + bloqueo.getIdWorkflowBloqueo());
                        }
                    }

                    //Se desbloquea la matricula
                    BloqueoFolioEnhanced viejo = (BloqueoFolioEnhanced) auditoria.clonarEnhanced(bloqueo);
                    bloqueo.setFechaDesbloqueo(new Date());

                } else {
                    //SE SETEAN LAS SECUENCIAS DE LAS LISTAS TEMPORALES:
                    this.resetSecuenciasTemporalesFolio(folio, pm);
                }

                //Asocia la matricula a la nueva llave de bloqueo
                BloqueoFolioEnhanced bl = new BloqueoFolioEnhanced();
                bl.setFechaBloqueo(new Date());
                bl.setFolio(folio);
                bl.setLlaveBloqueo(llave);
                bl.setIdWorkflowBloqueo(turno.getIdWorkflow());
                pm.makePersistent(bl);

                if (ht.size() > 0) {
                    DAOException exc = new DAOException(
                            "Error en validación de delegación de bloqueos de folios");
                    exc.setHashErrores(ht);
                    throw exc;
                }
            }

            pm.currentTransaction().commit();

            if (llaveRta != null) {
                return llaveRta;
            } else if (llave != null) {
                rta = (LlaveBloqueoEnhancedPk) pm.getObjectId(llave);
                return this.getLlaveBloqueo(rta.getLlaveBloqueoID());
            } else {
                return null;
            }
        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (DAOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            throw e;
        } catch (Exception e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }
    }

    /**
     * Resetea las secuencias temporales de folio si no existe información
     * temporal.
     *
     * @param folio
     * @param pm
     * @throws DAOException
     */
    private void resetSecuenciasTemporalesFolio(FolioEnhanced folio, PersistenceManager pm) throws DAOException {
        //Se debe validar que el folio NO tenga información en temporal para setear las
        //respectivas secuencias

        Log.getInstance().debug(JDOGenieFolioDAO.class, "**************************************************************");
        Log.getInstance().debug(JDOGenieFolioDAO.class, "SE ESTAN ACTUALIZANDO LAS SECUENCIAS PARA EL FOLIO : " + (folio != null ? folio.getIdMatricula() : "NULL"));
        Log.getInstance().debug(JDOGenieFolioDAO.class, "ANTES LASTIDANOTACION : " + (folio != null ? "" + folio.getLastIdAnotacion() : "NULL"));
        Log.getInstance().debug(JDOGenieFolioDAO.class, "ANTES LASTIDANOTACIONTMP : " + (folio != null ? "" + folio.getLastIdAnotacionTMP() : "NULL"));

        if (this.getCountAnotacionesTMPFolio(folio, pm) == 0) {
            folio.setLastIdAnotacionTMP(folio.getLastIdAnotacion());
        }

        if (folio.getDireccionesTMPs().size() == 0) {
            folio.setLastIdDireccionTMP(folio.getLastIdDireccion());
        }

        if (folio.getSalvedadesTMPs().size() == 0) {
            folio.setLastIdSalvedadTMP(folio.getLastIdSalvedad());
        }

        Log.getInstance().debug(JDOGenieFolioDAO.class, "DESPUES LASTIDANOTACION : " + (folio != null ? "" + folio.getLastIdAnotacion() : "NULL"));
        Log.getInstance().debug(JDOGenieFolioDAO.class, "DESPUES LASTIDANOTACIONTMP : " + (folio != null ? "" + folio.getLastIdAnotacionTMP() : "NULL"));
        Log.getInstance().debug(JDOGenieFolioDAO.class, "**************************************************************");

    }

    /**
     * Copia la anotación indicada con el ID idAnotacion (definitiva o temporal)
     * al folio indicado con el ID idFolioDestino. El usuario debe tener el
     * bloqueo del folio. CONDICIONES DEPENDIENDO DE LA ANOTACION A COPIAR:
     * Cancelada: Se copia junto con su canceladora Canceladora: No se copia (Se
     * lanza excepción, en el la lista de errores del DAOException) Derivada o
     * generadora: Solo copia la anotación, sin relaciones a otros folios
     * Normal: Se copia normalmente
     *
     * @param idAnotacion
     * @param foliosID lista de objetos Folio.ID
     * @param usuario Usuario que esta realizando la copia de anotaciones
     * @param copiarComentario Booleano que determina si se debe copiar o no el
     * comentario de la anotación origen
     * @return la anotación generada
     * @throws DAOException
     */
    public boolean copiarAnotacion(AnotacionPk idAnota, List foliosID, Usuario usuario, boolean copiarComentario)
            throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        List errores = new ArrayList();
        DAOException exc = new DAOException("Error copiado la anotación");
        AnotacionTMP nuevaAnotacion;
        FolioPk idFolioDestino;
        try {
            //Se busca entre las anotaciones temporales
            AnotacionTMPPk tid = new AnotacionTMPPk();
            tid.idAnotacionTmp = idAnota.idAnotacion;
            tid.idMatricula = idAnota.idMatricula;

            AnotacionTMP anotaTMPVal = this.getAnotacionTMPByID(tid, pm);

            if (anotaTMPVal == null) {
                errores.add("No se encontró la anotación temporal a copiar");
                exc.setErrores(errores);
                throw exc;
            }

            //pm.currentTransaction().setOptimistic(false);
            pm.currentTransaction().begin();

            //Se trae a persistente el usuario porque se necesita en el servicio
            //que inserta la anotación
            UsuarioEnhancedPk usID = new UsuarioEnhancedPk();
            usID.idUsuario = usuario.getIdUsuario();
            UsuarioEnhanced us = this.getUsuarioByID(usID, pm);

            //Se recorre la lista de foliosID para insertar la anotación transiente
            //a cada uno de ellos
            for (Iterator it = foliosID.iterator(); it.hasNext();) {
                idFolioDestino = (FolioPk) it.next();
                FolioEnhanced folioDestino = this.getFolioByID(new FolioEnhancedPk(idFolioDestino), pm);
                if (folioDestino == null) {
                    if (pm.currentTransaction().isActive()) {
                        pm.currentTransaction().rollback();
                    }
                    errores.add("El folio no existe: " + idFolioDestino.idMatricula);
                    exc.setErrores(errores);
                    throw exc;
                } else {
                    try {
                        //Se valida el bloqueo
                        this.validarBloqueoFolio(folioDestino, usuario, pm);
                    } catch (DAOException e) {
                        if (pm.currentTransaction().isActive()) {
                            pm.currentTransaction().rollback();
                        }
                        errores.add(e.getMessage());
                        exc.setErrores(errores);
                        throw exc;
                    }

                    //Se valida la anotación a copiar:
                    Anotacion anotaToCopy = new Anotacion();
                    anotaToCopy.setIdAnotacion(idAnota.idAnotacion);
                    anotaToCopy.setIdMatricula(idAnota.idMatricula);

                    //Se crea el folio transiente donde va a quedar la anotación temporal
                    //nueva que se crea a partir de la otra
                    FolioEnhanced folioTransiente = new FolioEnhanced();

                    try {
                        this.heredarAnotacion(anotaToCopy, folioTransiente, false, copiarComentario, pm, anotaTMPVal.getIdWorkflow());
                    } catch (DAOException e) {
                        if (pm.currentTransaction().isActive()) {
                            pm.currentTransaction().rollback();
                        }
                        exc.setErrores(e.getErrores());
                        throw exc;
                    }

                    //En este punto tenemos un folio Transiente con una anotación
                    //en su lista que está lista para añadirse al folio persistente
                    if (folioTransiente.getAnotacionesTMPs().isEmpty()) {
                        if (pm.currentTransaction().isActive()) {
                            pm.currentTransaction().rollback();
                        }
                        errores.add("El folio Transiente no tiene la anotación temporal dentro de su lista");
                        exc.setErrores(errores);
                        throw exc;
                    }

                    //Se trae la anotación copiada en memoria como anotación temporal
                    nuevaAnotacion = (AnotacionTMP) folioTransiente.getAnotacionesTMPs().get(0);

                    //Se llama al servicio que ingresa una anotación transiente temporal
                    //a un folio persistente:
                    try {
                        nuevaAnotacion.setIdAnotacionTmp(null);

                        //Asignación de orden:
                        nuevaAnotacion.setOrden(String.valueOf(this.getNextOrdenAnotacion(
                                folioDestino, pm)));

                        this.addAnotacionTMPToFolio(folioDestino, nuevaAnotacion, us, null, pm);
                        pm.makePersistent(nuevaAnotacion);
                    } catch (DAOException e) {
                        if (pm.currentTransaction().isActive()) {
                            pm.currentTransaction().rollback();
                        }
                        errores.add(e.getMessage());
                        exc.setErrores(errores);
                        Log.getInstance().error(JDOGenieFolioDAO.class, e);
                        throw exc;
                    }
                }
            }
            pm.currentTransaction().commit();

        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (DAOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            throw e;
        } catch (Throwable e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }
        return true;
    }

    /**
     * Engloba un folio a partir de unos folios Fuentes y una tabla con
     * anotaciones heredadas
     *
     * @param foliosFuentes folios a englobar
     * @param nuevoFolio folio a partir del cual se sacará la información
     * geográfica y contendrá la dirección a añadir al nuevo folio
     * @param usuario usuario actual
     * @param tabla tabla con la lista de anotaciones a heredar de cada folio
     * fuente
     * @param anotacion anotación nueva o existente de algún folio padre (con
     * IDs seteados) la cuál va a encadenar los folios padres con el hijo
     * @param informacionAdicional información adicional del englobe: LOTE,
     * PORCENTAJE, DESCRIPCION Y AREA
     * @param copiarComentarioEnglobe Permite determinar si se debe o no copiar
     * el comentario de la anotación origen a las nuevas anotaciones de los
     * nuevos folios.
     * @param copiarComentarioHeredadas Permite determinar si se debe o no
     * copiar el comentario de las anotaciones a heredar en los nuevos folios
     * @return
     * @throws Throwable
     */
    public Folio englobarFolio(List foliosFuentes, Folio folioBase, Usuario usuario, List tabla, Anotacion anotacion, FolioDerivado informacionAdicional,
            boolean copiarComentarioEnglobe, boolean copiarComentarioHeredadas, TurnoPk oid) throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        boolean rta = false;
        UsuarioEnhanced us = new UsuarioEnhanced();
        BloqueoFolioEnhanced bloqueo = new BloqueoFolioEnhanced();
        Folio folioBloqueado = new Folio();
        AnotacionTMP anotacionBase = null;
        FolioEnhanced folio;
        List listaDerivados = new ArrayList();
        Hashtable ht = new Hashtable();
        FolioEnhanced folioBaseTurno = FolioEnhanced.enhance(folioBase);

        TurnoEnhancedPk toid = new TurnoEnhancedPk();
        TurnoEnhanced turnoe = null;

        if (oid != null) {
            toid.anio = oid.anio;
            toid.idCirculo = oid.idCirculo;
            toid.idProceso = oid.idProceso;
            toid.idTurno = oid.idTurno;
            turnoe = this.getTurnoByID(toid, pm);
        }

        if (folioBaseTurno.getTurnosFolios().isEmpty()) {
            throw new DAOException("El folio debe tener un turno asociado");
        }

        try {
            //Se valida que existe el usuario.
            UsuarioEnhancedPk uid = new UsuarioEnhancedPk();
            uid.idUsuario = usuario.getIdUsuario();

            us = this.getUsuarioByID(uid, pm);

            if (us == null) {
                throw new DAOException("El usuario especificado no existe: "
                        + uid.idUsuario);
            }

            //Se válida que todos los folios recibidos se encuentren bloqueados, y además
            //que el usuario sea dueño de los bloqueos de todos los folios.
            for (int i = 0; i < foliosFuentes.size(); i++) {
                folioBloqueado = (Folio) foliosFuentes.get(i);
                bloqueo = this.getBloqueoFolio(folioBloqueado.getIdMatricula(),
                        pm);

                if (bloqueo == null) {
                    throw new DAOException(
                            "La matricula no se encuentra bloqueada");
                }

                //Validamos que el usuario sea dueño del bloqueo del folio
                UsuarioEnhanced usuAux = this.getUsuarioByLlaveBloqueo(bloqueo.getLlaveBloqueo(),
                        pm);

                if (usuAux == null) {
                    throw new DAOException(
                            "Error en la obtención del usuario a partir de la llave de bloqueo");
                }

                if (usuAux.getIdUsuario() != us.getIdUsuario()) {
                    throw new DAOException(
                            "El usuario no es dueño del bloqueo del folio " + folioBloqueado.getIdMatricula()
                            + ". El turno asociado a la matrícula es: " + bloqueo.getIdWorkflowBloqueo());
                }
            }

            //Sacamos el folio Base persistente
            FolioEnhancedPk fid = new FolioEnhancedPk();
            fid.idMatricula = folioBase.getIdMatricula();

            FolioEnhanced folioBaseEnh = this.getFolioByID(fid, pm);

            if (folioBaseEnh == null) {
                throw new DAOException("El folio base NO existe: " + folioBase.getIdMatricula());
            }

            AnotacionTMPPk anotaIDExistente = null;
            //Verificamos si la anotación base existe
            NaturalezaJuridicaEnhancedPk natJurId = new NaturalezaJuridicaEnhancedPk();
            natJurId.idNaturalezaJuridica = anotacion.getNaturalezaJuridica().getIdNaturalezaJuridica();
            /*
                    *  @author Carlos Torres
                    *  @chage   se asigna valor a la propiedad version
                    *  @mantis 12705: Acta - Requerimiento No 056_453_Modificiación_de_Naturaleza_Jurídica
             */
            natJurId.version = anotacion.getNaturalezaJuridica().getVersion();
            NaturalezaJuridicaEnhanced natTemp = getNaturalezaJuridica(natJurId, pm);

            if (anotacion.getIdAnotacion() != null) {
                //Se quiere usar una anotación temporal para englobar
                anotaIDExistente = new AnotacionTMPPk();
                anotaIDExistente.idAnotacionTmp = anotacion.getIdAnotacion();
                anotaIDExistente.idMatricula = anotacion.getIdMatricula();

                anotacionBase = this.getAnotacionTMPByID(anotaIDExistente, pm);

                if (anotacionBase == null) {
                    throw new DAOException("La anotación temporal que se quiere usar NO existe");
                }
                anotacionBase.setEspecificacion(natTemp.getNombre());
            } else {
                //La anotación que se quiere usar es nueva
                anotacionBase = new AnotacionTMP(anotacion);

                //Verificamos que la anotación tenga documento asociado:
                if (anotacionBase.getDocumento() == null) {
                    throw new DAOException("La anotación nueva base NO tiene documento asociado");
                }
                anotacionBase.setEspecificacion(natTemp.getNombre());
            }

            //Una vez realizadas las validaciones se inicia la transacción
            pm.currentTransaction().begin();

            //Crear el nuevo Folio. Se crea basado en el folio base
            folio = new FolioEnhanced();

            //Se copia la referencia al turno
            folio.addTurnosFolio((TurnoFolioEnhanced) folioBaseTurno.getTurnosFolios().get(0));

            //Se copia la información geográfica:
            folio.setZonaRegistral(folioBaseEnh.getZonaRegistral());

            //Se copia la complementacion, se crea una nueva para que
            //se copie y NO se asocie
            //Complementación según ajuste 4629
            ComplementacionEnhanced com = new ComplementacionEnhanced();
            com.setComplementacion(informacionAdicional.getDescripcion());

            folio.setComplementacion(com);
            /*
            if(folioBaseEnh.getComplementacion()!=null){
				ComplementacionEnhanced com = new ComplementacionEnhanced();
				com.setComplementacion(folioBaseEnh.getComplementacion().getComplementacion());
				folio.setComplementacion(com);
            }*/

            //El documento se saca de la anotación base
            folio.setDocumento(anotacionBase.getDocumento());

            folio.setTipoPredio(folioBaseEnh.getTipoPredio());

            folio.setCodCatastral(folioBaseEnh.getCodCatastral());

            //Se copian las direcciones al nuevo folio
            List direcciones = folioBase.getDirecciones();
            if (direcciones != null && !direcciones.isEmpty()) {
                Iterator itDirecciones = direcciones.iterator();
                Direccion dirAux;
                while (itDirecciones.hasNext()) {
                    dirAux = (Direccion) itDirecciones.next();
                    folio.addDireccione(DireccionEnhanced.enhance(dirAux));
                }
            }

            List anotacionesHeredar = tabla;
            Anotacion anotaHereda;
            for (Iterator itr2 = anotacionesHeredar.iterator(); itr2.hasNext();) {
                anotaHereda = (Anotacion) itr2.next();
                try {
                    this.heredarAnotacion(anotaHereda, folio, true, copiarComentarioHeredadas, pm, anotacionBase.getIdWorkflow());
                } catch (DAOException e) {
                    String id_anotacion = "";
                    if (anotaHereda != null) {
                        if (anotaHereda.getIdAnotacion() != null) {
                            id_anotacion = anotaHereda.getIdAnotacion();
                        }
                        if (anotaHereda.getOrden() != null) {
                            id_anotacion = anotaHereda.getOrden();
                        }
                    }
                    id_anotacion = anotaHereda.getIdMatricula() + ", Anotación No. " + id_anotacion;
                    ht.put(id_anotacion, e.getErrores());
                }
            }

            if (ht.size() > 0) {
                if (pm.currentTransaction().isActive()) {
                    pm.currentTransaction().rollback();
                }
                DAOException ex = new DAOException("Error en la herencia de anotaciones");
                ex.setHashErrores(ht);
                throw ex;
            }

            //Se seteal el nombre del lote:
            folio.setNombreLote(informacionAdicional.getLote());
            folio.setHectareas(informacionAdicional.getHectareas());
            folio.setMetros(informacionAdicional.getMetros());
            folio.setCentimetros(informacionAdicional.getCentimetros());

            //Una vez se tengan copiados los datos se crea el folio:
            boolean result = this.crearFolio(folio, us, pm, turnoe, true);

            //El flag en true del anterior método nos asegura la siguiente linea
            TurnoFolioEnhanced turnoF = (TurnoFolioEnhanced) folio.getTurnosFolios().get(0);

            //Se construye el lindero
            String lindero = this.contruirLindero(new FolioDerivadoTMP(informacionAdicional), folio.getDocumento(), pm);
            folio.setLindero(lindero);

            if (!result) {
                throw new DAOException("No se pudo crear el folio");
            }

            //El folio creado debe ser bloqueado con la misma llave en que se
            //tienen bloqueadas las demás matriculas
            BloqueoFolioEnhanced bf = new BloqueoFolioEnhanced();
            bf.setFechaBloqueo(new Date());
            bf.setFolio(folio);
            bf.setLlaveBloqueo(bloqueo.getLlaveBloqueo());
            bf.setIdWorkflowBloqueo(turnoF.getTurno().getIdWorkflow());
            pm.makePersistent(bf);

            //Se inicializan atributos de la anotación temporal.
            AnotacionTMP anTemp2 = new AnotacionTMP(anotacionBase.getDefinitivo(new ArrayList()), new ArrayList());

            if (!copiarComentarioEnglobe) {
                anTemp2.setComentario(null);
            }

            //Tipo Anotación.
            TipoAnotacionEnhanced tipoAnot2 = new TipoAnotacionEnhanced();
            tipoAnot2.setIdTipoAnotacion(CTipoAnotacion.DERIVADO);
            anTemp2.setTipoAnotacion(tipoAnot2);

            //Naturaleza Jurídica.
            /*
            NaturalezaJuridicaEnhanced natJur2 = new NaturalezaJuridicaEnhanced();
            natJur2.setIdNaturalezaJuridica(CNaturalezaJuridica.ENGLOBE);
             */
            //Asignación de orden:
            anTemp2.setOrden(String.valueOf(this.getNextOrdenAnotacion(
                    folio, pm)));

            anTemp2.setNaturalezaJuridica(anotacionBase.getNaturalezaJuridica());
            anTemp2.setEspecificacion(anotacionBase.getEspecificacion());

            //Se agrega la anotación temporal al nuevo folio.
            /*
             * @author      :   Julio Alcázar Rivas
             * @change      :   se eliminan las salvedades de la anotacion del nuevo folio
             *                  estas solo deben aparecer en los folios padres
             * Caso Mantis  :   04131
             */
            anTemp2.removeAllSalvedadesTMP();
            this.addAnotacionTMPToFolio(folio, anTemp2, us, turnoe, pm);
            pm.makePersistent(anTemp2);

            //Se crea una anotación temporal para cada una de los folios.
            for (int j = 0; j < foliosFuentes.size(); j++) {
                folioBloqueado = (Folio) foliosFuentes.get(j);

                //Obtenemos el folio persistente
                fid = new FolioEnhancedPk();
                fid.idMatricula = folioBloqueado.getIdMatricula();

                FolioEnhanced folioPadre = this.getFolioByID(fid, pm);

                if (folio == null) {
                    throw new DAOException("El folio no existe");
                }

                //Se inicializan atributos de la anotación temporal.
                AnotacionTMP anTemp = null;

                //Se verifica si la anotación base existe y se debe asociar en vez de crear
                boolean crearNuevaAnotacion = true;
                if (anotaIDExistente != null) {
                    if (folioPadre.getIdMatricula().equals(anotaIDExistente.idMatricula)) {
                        anTemp = anotacionBase;
                        crearNuevaAnotacion = false;
                    }
                }

                if (crearNuevaAnotacion) {

                    //Se inicializan atributos de la anotación temporal.
                    anTemp = new AnotacionTMP(anotacionBase.getDefinitivo(new ArrayList()), new ArrayList());
                    //Tipo Anotación.
                    TipoAnotacionEnhanced tipoAnot = new TipoAnotacionEnhanced();
                    tipoAnot.setIdTipoAnotacion(CTipoAnotacion.GENERADORA);
                    anTemp.setTipoAnotacion(tipoAnot);

                    //Naturaleza Jurídica.
                    /*
					 NaturalezaJuridicaEnhanced natJur = new NaturalezaJuridicaEnhanced();
					 natJur.setIdNaturalezaJuridica(CNaturalezaJuridica.ENGLOBE);
                     */
                    //Asignación de orden:
                    anTemp.setOrden(String.valueOf(this.getNextOrdenAnotacion(
                            folioPadre, pm)));

                    anTemp.setNaturalezaJuridica(anotacionBase.getNaturalezaJuridica());
                    anTemp.setEspecificacion(anotacionBase.getEspecificacion());
                    this.addAnotacionTMPToFolio(folioPadre, anTemp, us, turnoe, pm);
                    pm.makePersistent(anTemp);
                }

                //Crear un Folio Derivado Temporal para cada una de las anotaciones.
                FolioDerivadoTMP folioDerivado = new FolioDerivadoTMP(informacionAdicional);
                folioDerivado.setPadreTmp(anTemp);
                folioDerivado.setHijoTmp(anTemp2);
                pm.makePersistent(folioDerivado);
            }

            pm.currentTransaction().commit();
            pm.makeTransient(folio);

        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (DAOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            throw e;
        } catch (Throwable e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        return (Folio) folio.toTransferObject();
    }

    /**
     * Obtiene y avanza la secuencia de la tabla especificada (TOMADO de
     * FORSETTI)
     *
     * @param tableName Nombre de la tabla de la cual se quiere obtener el
     * secuencial.
     * @param pm Persistence Manager de la transacción.
     * @return El secuencial requerido.
     * @throws DAOException
     */
    protected long getSecuencial(String tableName, PersistenceManager pm) throws DAOException {
        long rta = -1;

        boolean transaccionIndependiente = false;
        VersantPersistenceManager pm2 = null;

        Connection con = null;
        PreparedStatement pst = null;
        ResultSet rs = null;

        HermodProperties hprop = HermodProperties.getInstancia();
        String secuencias = hprop.getProperty(
                HermodProperties.SECUENCIALES_POR_SECUENCIA);
        boolean usarSecuencia = false;

        if (secuencias != null) {
            String[] secuenciasSplit = secuencias.split(";");
            for (int i = 0; i < secuenciasSplit.length; i++) {
                if (secuenciasSplit[i].equals(tableName)) {
                    usarSecuencia = true;
                    break;
                }
            }
        }

        if (pm == null) {
            transaccionIndependiente = true;
        }

        if (tableName != null) {
            try {
                if (transaccionIndependiente) {
                    pm = AdministradorPM.getPM();
                    pm.currentTransaction().setOptimistic(false);
                    pm.currentTransaction().begin();
                }

                if (usarSecuencia) {
                    String sql = "SELECT SEC_" + (tableName.length() > 26 ? tableName.substring(0, 26) : tableName) + ".nextval FROM DUAL";

                    pm2 = (VersantPersistenceManager) pm;

                    con = pm2.getJdbcConnection(null);
                    pst = con.prepareStatement(sql);
                    rs = pst.executeQuery();

                    if (rs.next()) {
                        rta = rs.getLong(1);
                    } else {
                        throw new DAOException("No se encontró la secuencia");
                    }

                } else {

                    //Se hace el cambio de tipo de bloqueo pesimista para
                    //que se bloquee la tabla la cual  nos
                    //provee el secuencial
                    pm2 = (VersantPersistenceManager) pm;
                    pm2.setDatastoreTxLocking(VersantPersistenceManager.LOCKING_ALL);
                    pm = pm2;

                    SecuenciasEnhancedPk sid = new SecuenciasEnhancedPk();
                    sid.tableName = tableName;

                    SecuenciasEnhanced s = this.getSecuenciaByID(sid, pm);
                    s.setLastUsedId(s.getLastUsedId() + 1);

                    //Volvemos a setear el tipo de bloqueo pesimista
                    //para que no nos bloquee los siquientes registros
                    //consultados
                    pm2.setDatastoreTxLocking(VersantPersistenceManager.LOCKING_NONE);

                    rta = s.getLastUsedId(); // + 1;
                }

                if (transaccionIndependiente) {
                    pm.currentTransaction().commit();
                }

            } catch (JDOObjectNotFoundException e) {
                pm2.setDatastoreTxLocking(VersantPersistenceManager.LOCKING_NONE);
                if (transaccionIndependiente) {
                    if ((pm != null) && (pm.currentTransaction().isActive())) {
                        pm.currentTransaction().rollback();
                    }
                }
                throw new DAOException("No se encontró el registro de la secuencia", e);
            } catch (JDOException e) {
                pm2.setDatastoreTxLocking(VersantPersistenceManager.LOCKING_NONE);
                if (transaccionIndependiente) {
                    if ((pm != null) && (pm.currentTransaction().isActive())) {
                        pm.currentTransaction().rollback();
                    }
                }
                throw new DAOException("Error obteniendo el registro de la secuencia", e);
            } catch (DAOException e) {
                pm2.setDatastoreTxLocking(VersantPersistenceManager.LOCKING_NONE);
                if (transaccionIndependiente) {
                    if ((pm != null) && (pm.currentTransaction().isActive())) {
                        pm.currentTransaction().rollback();
                    }
                }
                throw new DAOException("Error obteniendo el registro de la secuencia", e);
            } catch (Exception e) {
                pm2.setDatastoreTxLocking(VersantPersistenceManager.LOCKING_NONE);
                if (transaccionIndependiente) {
                    if ((pm != null) && (pm.currentTransaction().isActive())) {
                        pm.currentTransaction().rollback();
                    }
                }
                throw new DAOException("Error obteniendo el registro de la secuencia", e);
            } finally {
                pm2.setDatastoreTxLocking(VersantPersistenceManager.LOCKING_NONE);
                try {
                    if (rs != null) {
                        rs.close();
                    }
                    if (pst != null) {
                        pst.close();
                    }
                    if (con != null) {
                        con.close();
                    }
                } catch (SQLException e) {
                }

                if (transaccionIndependiente) {
                    if (pm != null) {
                        pm.close();
                    }
                }
            }
        }

        return rta;
    }

    /**
     * Determina si una matricula tiene por lo menos una anotación temporal
     *
     * @param matricula
     * @return
     * @throws DAOException
     */
    public boolean hasAnotacionesTMP(FolioPk oid) throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();

        try {
            FolioEnhanced folio = this.getFolioByID(new FolioEnhancedPk(oid),
                    pm);

            if (folio.getAnotacionesTMPs().size() > 0) {
                return true;
            } else {
                return false;
            }
        } catch (DAOException e) {
            throw e;
        } finally {
            pm.close();
        }
    }

    /**
     * Bloquea los todos los folios asociados a un turno
     *
     * @param oid
     * @param usuario
     * @return
     * @throws DAOException
     */
    public LlaveBloqueo bloquearFolios(TurnoPk oid, Usuario usuario)
            throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        EstadoFolio aux = null;
        LlaveBloqueoEnhanced llave = null;
        String matricula;
        Hashtable ht = new Hashtable();

        List matsToLock = new ArrayList();

        LlaveBloqueoEnhancedPk rta;
        UsuarioEnhanced us = UsuarioEnhanced.enhance(usuario);
        UsuarioEnhancedPk usId = new UsuarioEnhancedPk();
        usId.idUsuario = us.getIdUsuario();

        BloqueoFolioEnhanced bloqueo = null;
        TurnoEnhanced turno;
        List matriculas;
        SolicitudFolioEnhanced sf;

        try {
            pm.currentTransaction().setOptimistic(false);
            pm.currentTransaction().begin();

            //Validación del turno:
            turno = this.getTurnoByID(new TurnoEnhancedPk(oid), pm);

            if (turno == null) {
                throw new DAOException(
                        "No se encontró el turno con el ID especificado");
            }

            //Se obtiene la lista de folios asociados al turno
            List folios = turno.getSolicitud().getSolicitudFolios();

            if (folios.size() == 0) {
                throw new DAOException("El turno no tiene matrículas asociadas");
            }

            //Validación del usuario
            us = this.getUsuarioByID(usId, pm);

            if (us == null) {
                throw new DAOException("El usuario especificado no existe");
            }

            //Se bloquean los folios utilizando el método normal de bloqueo
            llave = this.bloquearFolios(turno, us, pm);

            pm.currentTransaction().commit();

            if (llave != null) {
                rta = (LlaveBloqueoEnhancedPk) pm.getObjectId(llave);

                return this.getLlaveBloqueo(rta.getLlaveBloqueoID());
            } else {
                return null;
            }
        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (DAOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            throw e;
        } catch (Exception e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }
    }

    /**
     * Bloquea los todos los folios asociados a un turno
     *
     * @param oid
     * @param usuario
     * @return
     * @throws DAOException
     */
    protected LlaveBloqueoEnhanced bloquearFolios(TurnoEnhanced turno,
            UsuarioEnhanced us, PersistenceManager pm) throws DAOException {
        EstadoFolio aux = null;
        LlaveBloqueoEnhanced llave = null;
        String matricula;
        Hashtable ht = new Hashtable();

        List matsToLock = new ArrayList();

        LlaveBloqueoEnhancedPk rta;

        BloqueoFolioEnhanced bloqueo = null;
        List matriculas;
        SolicitudFolioEnhanced sf;

        try {
            List folios = turno.getSolicitud().getSolicitudFolios();

            //Se recorre la lista de matrículas, se hacen las validaciones para cada una
            for (Iterator itr = folios.iterator(); itr.hasNext();) {
                sf = (SolicitudFolioEnhanced) itr.next();
                matricula = sf.getIdMatricula();

                //Se valida que la matrícula se encuentre bloqueada y se obtiene
                //el objeto bloqueoFolio
                bloqueo = this.getBloqueoFolio(matricula, pm);

                if (bloqueo != null) {
                    //La matricula esta bloqueada
                    //Validamos que el usuario sea dueño del bloqueo del folio
                    UsuarioEnhanced usuAux = this.getUsuarioByLlaveBloqueo(bloqueo.getLlaveBloqueo(),
                            pm);

                    if (usuAux == null) {
                        throw new DAOException(
                                "Error en la obtención del usuario a partir de la llave de bloqueo");
                    }

                    //En caso que el usuario no sea el dueño del bloqueo actual se especifica
                    //que la matricula está bloqueada
                    if (usuAux.getIdUsuario() != us.getIdUsuario()) {
                        String msm = "";

                        if (bloqueo.getIdWorkflowBloqueo() != null) {
                            msm = " en el turno "
                                    + bloqueo.getIdWorkflowBloqueo();
                        }

                        ht.put(matricula,
                                "La matricula se encuentra bloqueada por el usuario "
                                + usuAux.getUsername() + msm);
                    }

                    //Si el usuario es el dueño del bloqueo actual no se agrega la matricula
                    //a la lista de matriculas para bloquear
                } else {
                    //La matrícula no está bloqueada
                    matsToLock.add(matricula);
                }
            }

            if (ht.size() > 0) {
                DAOException exc = new DAOException(
                        "Error en validación de bloqueo de folios");
                exc.setHashErrores(ht);
                throw exc;
            }

            if (matsToLock.size() > 0) {
                llave = this.crearLlaveBloqueo(pm);
                us.addLlavesBloqueo(llave);

                for (Iterator itr2 = matsToLock.iterator(); itr2.hasNext();) {
                    matricula = (String) itr2.next();

                    FolioEnhanced folio = this.getFolioByMatricula(matricula, pm);
                    BloqueoFolioEnhanced bl = new BloqueoFolioEnhanced();
                    bl.setFechaBloqueo(new Date());
                    bl.setFolio(folio);
                    bl.setLlaveBloqueo(llave);
                    bl.setIdWorkflowBloqueo(turno.getIdWorkflow());

                    //SE SETEAN LAS SECUENCIAS DE LAS LISTAS TEMPORALES:
                    this.resetSecuenciasTemporalesFolio(folio, pm);

                    pm.makePersistent(bl);
                }

                return llave;
            } else {
                return null;
            }
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }
    }

    /**
     * Desbloquea todos los folios asociados a un turno, si en el turno existe
     * algún folio que no esté bloqueado se produce una excepción
     *
     * @param oid
     * @param usuario
     * @return
     * @throws DAOException
     */
    public boolean desbloquearFolios(TurnoPk oid, Usuario usuario)
            throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        EstadoFolio aux = null;
        LlaveBloqueoEnhanced llave = null;
        String matricula;
        Hashtable ht = new Hashtable();

        LlaveBloqueoEnhancedPk rta;
        UsuarioEnhanced us = UsuarioEnhanced.enhance(usuario);
        UsuarioEnhancedPk usId = new UsuarioEnhancedPk();
        usId.idUsuario = us.getIdUsuario();

        BloqueoFolioEnhanced bloqueo = null;
        TurnoEnhanced turno;
        List matriculas;
        SolicitudFolioEnhanced sf;

        try {
            //pm.currentTransaction().setOptimistic(false);
            pm.currentTransaction().begin();

            //Validación del turno:
            turno = this.getTurnoByID(new TurnoEnhancedPk(oid), pm);

            if (turno == null) {
                throw new DAOException(
                        "No se encontró el turno con el ID especificado");
            }

            //Se obtiene la lista de folios asociados al turno
            List folios = turno.getSolicitud().getSolicitudFolios();

            /*
            if (folios.size() == 0) {
            throw new DAOException("El turno no tiene matrículas asociadas");
            }*/
            //Validación del usuario
            us = this.getUsuarioByID(usId, pm);

            if (us == null) {
                throw new DAOException("El usuario especificado no existe");
            }

            //Se recorre la lista de matrículas, se hacen las validaciones para cada una
            for (Iterator itr = folios.iterator(); itr.hasNext();) {
                sf = (SolicitudFolioEnhanced) itr.next();
                matricula = sf.getIdMatricula();

                //Se valida que la matrícula se encuentre bloqueada y se obtiene
                //el objeto bloqueoFolio
                bloqueo = this.getBloqueoFolio(matricula, pm);

                if (bloqueo == null) {
                    ht.put(matricula, "La matricula no se encuentra bloqueada");
                } else {
                    UsuarioEnhanced usuAux = this.getUsuarioByLlaveBloqueo(bloqueo.getLlaveBloqueo(),
                            pm);

                    //Se valida que el usuario dado sea el que tenga bloqueado el folio
                    if (usuAux == null) {
                        ht.put(matricula,
                                "Error en la obtención del usuario dueño del bloqueo");
                    } else if (usuAux.getIdUsuario() != us.getIdUsuario()) {
                        ht.put(matricula,
                                "El usuario no es el dueño del bloqueo de la matrícula");
                    } else {
                        BloqueoFolioEnhanced viejo = (BloqueoFolioEnhanced) auditoria.clonarEnhanced(bloqueo);
                        bloqueo.setFechaDesbloqueo(new Date());

                    }
                }
            }

            if (ht.size() > 0) {
                DAOException exc = new DAOException(
                        "Error en validación de desbloqueo de folios");
                exc.setHashErrores(ht);
                throw exc;
            }

            pm.currentTransaction().commit();

            return true;
        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (DAOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            throw e;
        } catch (Exception e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }
    }

    /**
     * Desbloquea todos los folios asociados a un turno, si en el turno existe
     * algún folio que no esté bloqueado se produce una excepción no valida que
     * el bloqueo lo tenga un usuario.
     *
     * @param oid
     * @param usuario
     * @return
     * @throws DAOException
     */
    public boolean desbloquearFoliosTurno(TurnoPk oid, Usuario usuario)
            throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        EstadoFolio aux = null;
        LlaveBloqueoEnhanced llave = null;
        String matricula;
        Hashtable ht = new Hashtable();

        LlaveBloqueoEnhancedPk rta;
        UsuarioEnhanced us = UsuarioEnhanced.enhance(usuario);
        UsuarioEnhancedPk usId = new UsuarioEnhancedPk();
        usId.idUsuario = us.getIdUsuario();

        BloqueoFolioEnhanced bloqueo = null;
        TurnoEnhanced turno;
        List matriculas;
        SolicitudFolioEnhanced sf;

        try {
            //pm.currentTransaction().setOptimistic(false);
            pm.currentTransaction().begin();

            //Validación del turno:
            turno = this.getTurnoByID(new TurnoEnhancedPk(oid), pm);

            if (turno == null) {
                throw new DAOException(
                        "No se encontró el turno con el ID especificado");
            }

            //Se obtiene la lista de folios asociados al turno
            List folios = turno.getSolicitud().getSolicitudFolios();

            /*
            if (folios.size() == 0) {
            throw new DAOException("El turno no tiene matrículas asociadas");
            }*/
            //Validación del usuario
            us = this.getUsuarioByID(usId, pm);

            if (us == null) {
                throw new DAOException("El usuario especificado no existe");
            }

            //Se recorre la lista de matrículas, se hacen las validaciones para cada una
            for (Iterator itr = folios.iterator(); itr.hasNext();) {
                sf = (SolicitudFolioEnhanced) itr.next();
                matricula = sf.getIdMatricula();

                //Se valida que la matrícula se encuentre bloqueada y se obtiene
                //el objeto bloqueoFolio
                bloqueo = this.getBloqueoFolio(matricula, pm);

                if (bloqueo == null) {
                    //ht.put(matricula, "La matricula no se encuentra bloqueada");
                } else {
                    //UsuarioEnhanced usuAux = this.getUsuarioByLlaveBloqueo(bloqueo.getLlaveBloqueo(),pm);

                    //Se valida que el usuario dado sea el que tenga bloqueado el folio
                    if (bloqueo.getIdWorkflowBloqueo().equals(turno.getIdWorkflow())) {
                        BloqueoFolioEnhanced viejo = (BloqueoFolioEnhanced) auditoria.clonarEnhanced(bloqueo);
                        bloqueo.setFechaDesbloqueo(new Date());

                    }
                }
            }

            if (ht.size() > 0) {
                DAOException exc = new DAOException(
                        "Error en validación de desbloqueo de folios");
                exc.setHashErrores(ht);
                throw exc;
            }

            pm.currentTransaction().commit();

            return true;
        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (DAOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            throw e;
        } catch (Exception e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }
    }

    /**
     * Desbloquea un folio, si el folio no esta bloqueado se produce una
     * excepción
     *
     * @param folio
     * @return
     * @throws DAOException
     */
    public boolean desbloquearFolio(Folio folio)
            throws DAOException {

        PersistenceManager pm = AdministradorPM.getPM();
        Hashtable ht = new Hashtable();
        String matricula = "";
        matricula = folio.getIdMatricula();

        BloqueoFolioEnhanced bloqueo = null;
        //Se valida que la matrícula se encuentre bloqueada y se obtiene
        //el objeto bloqueoFolio
        bloqueo = this.getBloqueoFolio(matricula, pm);

        try {
            pm.currentTransaction().begin();

            if (bloqueo == null) {
                //ht.put(matricula, "La matricula no se encuentra bloqueada");
            } else {
                BloqueoFolioEnhanced viejo = (BloqueoFolioEnhanced) auditoria.clonarEnhanced(bloqueo);
                bloqueo.setFechaDesbloqueo(new Date());

            }

            if (ht.size() > 0) {
                if (pm.currentTransaction().isActive()) {
                    pm.currentTransaction().rollback();
                }
                DAOException exc = new DAOException(
                        "Error en validación de desbloqueo de folios");
                exc.setHashErrores(ht);
                throw exc;
            }

            pm.currentTransaction().commit();

            return true;
        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (DAOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            throw e;
        } catch (Exception e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }
    }

    /**
     * Actualiza una anotación de un folio. La actualización de la anotación
     * hace referencia a la copia de la anotación y su cambio a estado anulado.
     * Es decir se crea una copia de la anotación, se le pone estado anulado y
     * se inserta como nueva anotación temporal. La anotación original es
     * copiada también a una anotación temporal y se le agregan las
     * modificaciones realizadas
     *
     * @param folio
     * @param auxAn
     * @param pm
     * @return
     * @throws DAOException
     */
    protected boolean actualizarAnotacion(FolioEnhanced folio,
            AnotacionEnhanced auxAn, AnotacionTMP datos, UsuarioEnhanced usuario,
            boolean reordenar, TurnoEnhanced turno, PersistenceManager pm) throws DAOException {
        boolean rta = false;

        try {
            //Se valida primero si ya existe una anotación temporal
            //dentro de las anotaciones temporales del folio que
            //corresponda a la anotación definitiva que se quiere actualizar
            AnotacionTMPPk aTMPid = new AnotacionTMPPk();
            aTMPid.idMatricula = auxAn.getIdMatricula();
            aTMPid.idAnotacionTmp = auxAn.getIdAnotacion();

            AnotacionTMP auxTMP = this.getAnotacionTMPByID(aTMPid, pm);

            if (auxTMP != null) {
                //Se debe actualizar la anotación temporal que corresponde a la
                //anotación definitiva
                this.actualizarAnotacionDefinitivaEnTMP(folio, auxTMP, datos,
                        usuario, reordenar, turno, pm);
            } else {
                /* SE IGNORA TEMPORALMENTE ESTE CODIGO PARA QUE NO META LA ANOTACION DE AUDITORIA

                //Se crea la copia de la anotación y se le cambia el estado a  MODIFICADA
                AnotacionTMP anotaTMP = new AnotacionTMP(auxAn, new ArrayList());

                EstadoAnotacionEnhanced estado = new EstadoAnotacionEnhanced();
                estado.setIdEstadoAn(CEstadoAnotacion.OBSOLETA);
                anotaTMP.setEstado(estado);

                //Se remueven la lista de cancelaciones para que no se copien
                //en la anotación de auditoria, se copian las salvedades y los
                //ciudadanos de la anotacion
                anotaTMP.removeAllAnotacionesCancelacionTMP();

                //anotaTMP.removeAllAnotacionesCiudadanoTMP();
                //anotaTMP.removeAllSalvedadesTMP();
                //Se quita el ID para que inserte la copia
                anotaTMP.setIdAnotacionTmp(null);
                anotaTMP.setIdAnotacionModificada(auxAn.getIdAnotacion());
                anotaTMP.setFechaCreacion(new Date());

                //Se manda a crear la anotación con el usuario null para
                //que conserve al usuario original que creó la anotación
                this.addAnotacionTMPToFolio(folio, anotaTMP, null, pm);
                pm.makePersistent(anotaTMP);
                 */

                //Creamos una anotación temporal con el ID:
                AnotacionTMP anotaTMPOr = new AnotacionTMP();

                //Seteamos el identificador y los atributos básicos para que se pueda crear en
                //Base de datos, se setea también el documento para que eventualmente se pueda editar
                anotaTMPOr.setIdAnotacionTmp(auxAn.getIdAnotacion());
                anotaTMPOr.setEstado(auxAn.getEstado());
                anotaTMPOr.setNaturalezaJuridica(auxAn.getNaturalezaJuridica());
                anotaTMPOr.setModalidad(auxAn.getModalidad());
                anotaTMPOr.setTipoAnotacion(auxAn.getTipoAnotacion());
                anotaTMPOr.setLastIdSalvedad(auxAn.getLastIdSalvedad()); // TODO: OJO

                // se agrega esta linea, ya que, no se estaban borrando las anotaciones
                //temporalorales dado que no existia el id de workflow en el objeto.
                if (turno != null) {
                    anotaTMPOr.setIdWorkflow(turno.getIdWorkflow());
                }

                if (auxAn.getDocumento() != null && turno != null) {
                    auxAn.getDocumento().setCirculo(turno.getIdCirculo());
                }
                anotaTMPOr.setDocumento(auxAn.getDocumento());
                anotaTMPOr.setValor(auxAn.getValor());
                if (datos.getEspecificacion() == null) {
                    anotaTMPOr.setEspecificacion(auxAn.getEspecificacion());
                }
                //Si se quiere actualizar también el orden, copiamos también
                //el actual orden para que lo pueda actualizar con base
                //en el actual
                if (datos.getOrden() != null) {
                    anotaTMPOr.setOrden(auxAn.getOrden());
                }

                //Adicionamos la anotación temporal que representa la anotación
                //definitiva al folio
                this.addAnotacionTMPToFolio(folio, anotaTMPOr, usuario, turno, pm);
                pm.makePersistent(anotaTMPOr);

                //Llamamos al método que actualiza una anotación temporal que
                //representa una anotación definitiva
                this.actualizarAnotacionDefinitivaEnTMP(folio, anotaTMPOr,
                        datos, usuario, reordenar, turno, pm);
            }
        } catch (DAOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw e;
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }

        return rta;
    }

    /**
     * Actualiza una anotación temporal de un folio. Si el flag toDelete está en
     * true elimina la anotación temporal
     *
     * @param folio
     * @param auxAn
     * @param pm
     * @return
     * @throws DAOException
     */
    protected boolean actualizarAnotacionTMP(FolioEnhanced folio,
            AnotacionTMP toUpdate, AnotacionTMP datos, UsuarioEnhanced usuario,
            boolean soloEliminarContraparteTemporal, TurnoEnhanced turno, PersistenceManager pm) throws DAOException {
        boolean rta = false;
        JDOGenieCiudadanoDAO ciudDAO = new JDOGenieCiudadanoDAO();

        try {
            if (datos.isToDelete()) {
                //La anotación temporal se debe eliminar
                //Se comprueba que el tipo de la anotación no sea ni generadora
                //ni derivada puesto que estas anotaciones tienen relación
                //con otras anotaciones a través de folio derivado y estas no
                //se pueden eliminar

                boolean isTipoAnotacionDerivado = CTipoAnotacion.DERIVADO.equals(toUpdate.getTipoAnotacion().getIdTipoAnotacion());

                if (isTipoAnotacionDerivado && !soloEliminarContraparteTemporal) {
                    //Se lanza excepción porque no puede eliminar una anotación de tipo derivada
                    throw new DAOException("No puede eliminar una anotación de tipo DERIVADO, si desea borrar la segregación o englobe debe hacerlo desde la anotación de algún folio matriz");
                }

                // si no es tipo derivado
                // se sigue el flujo normal
                flujoNormal:
                {
                    //Se verifica si la anotación a borrar está siendo cancelada por
                    //otra anotación
                    AnotacionTMP canceladora = this.getAnotacionCanceladoraTMP(toUpdate,
                            pm);

                    if (canceladora != null) {
                        throw new DAOException(
                                "No puede eliminar la anotación, está cancelada por otra anotación temporal con ID: "
                                + canceladora.getOrden());
                    }

                    //Se verifica si la anotación a borrar es de tipo generadora para eliminar
                    //los folios creados
                    if (CTipoAnotacion.GENERADORA.equals(toUpdate.getTipoAnotacion().getIdTipoAnotacion())) {
                        //Concepto para guardar en la tabla de matrícula no grabada
                        String concepto = "Eliminación de anotación temporal generadora (Seg o Eng). ID_ANOTACION_TMP=" + datos.getIdAnotacionTmp();

                        List hijos = toUpdate.getAnotacionesHijosTMPs();
                        FolioDerivadoTMP folDer;
                        FolioEnhanced folioHijoToDelete;
                        AnotacionTMP anotacionHijaToDelete;
                        for (Iterator it = hijos.iterator(); it.hasNext();) {
                            folDer = (FolioDerivadoTMP) it.next();
                            folioHijoToDelete = folDer.getHijoTmp().getFolio();
                            anotacionHijaToDelete = folDer.getHijoTmp();
                            //Se revisa si la anotación hija tiene más padres para eliminar las otras anotaciones
                            //de englobe y los folios derivados respectivos
                            if (anotacionHijaToDelete.getAnotacionesPadreTMPs().size() > 1) {
                                //El padre es de un englobe, se borran las demás anotaciones del englobe y el folio
                                //creado
                                FolioDerivadoTMP folDerPadre;
                                AnotacionTMP anotacionPadreToDelete;
                                for (Iterator it2 = anotacionHijaToDelete.getAnotacionesPadreTMPs().iterator(); it2.hasNext();) {
                                    folDerPadre = (FolioDerivadoTMP) it2.next();
                                    anotacionPadreToDelete = folDerPadre.getPadreTmp();
                                    if (!anotacionPadreToDelete.getIdAnotacionTmp().equals(toUpdate.getIdAnotacionTmp())) {
                                        //Si el padre no es la misma anotación que se está intentando borrar (borrado de anotaciones hermanas)
                                        //La anotación padre en cuestión se borra el final (pm.deletePersistent(toUpdate))
                                        this.reordenarAnotacionesTemporales(anotacionPadreToDelete.getFolio(), anotacionPadreToDelete, pm);
                                        //anotacionPadreToDelete.getFolio().removeAnotacionesTMP(anotacionPadreToDelete);
                                        pm.deletePersistent(anotacionPadreToDelete);
                                    } else {
                                        pm.deletePersistent(folDerPadre);
                                    }
                                }
                                this.deleteFolio(anotacionHijaToDelete.getFolio(), pm, usuario, concepto);
                            } else {
                                //El padre es de una segregación, se borra el folio derivado y el folio creado a partir
                                //de esta segregación
                                pm.deletePersistent(folDer);
                                this.deleteFolio(folioHijoToDelete, pm, usuario, concepto);
                            }

                        }
                    }
                    //Bug 3432 Si la anotación que se está eliminando corresponde a la última, se actualiza el
                    // secuencial de anotaciones temporales.

                    if (toUpdate.getIdAnotacionTmp().equals(String.valueOf(folio.getLastIdAnotacionTMP()))) {
                        folio.setLastIdAnotacionTMP(folio.getLastIdAnotacionTMP() - 1);
                    }

                    AnotacionEnhancedPk anotacionDefinitiva_Id;
                    anotacionDefinitiva_Id = new AnotacionEnhancedPk();
                    anotacionDefinitiva_Id.idMatricula = toUpdate.getIdMatricula();
                    anotacionDefinitiva_Id.idAnotacion = toUpdate.getIdAnotacionTmp();

                    if (null == this.getAnotacionByID(anotacionDefinitiva_Id, pm)) {
                        this.reordenarAnotacionesTemporales(folio, toUpdate, pm);
                    } // if

                    //folio.removeAnotacionesTMP(toUpdate);
                    this.deleteAnotacionTMP(toUpdate, pm);

                    //se eliminaran los ciudadanos temporales
                } // :flujoNormal // Se debe eliminar el ciudadano temporal

                //if (soloEliminarContraparteTemporal) {
                // Se valida que sea el ultimo anotacionCiudadanoTMP 
                //Si hay mas anotacionCiudadanoTemporal
                //Se recorren todos los AnotacionCiudadanoTmp de la anotacion y se verifica si esta el ciudadano en temporal
                List anotacionesCiudadano = datos.getAnotacionesCiudadanoTMPs();
                for (Iterator itr = anotacionesCiudadano.iterator(); itr.hasNext();) {
                    AnotacionCiudadanoTMP anotaCiudadanoTMP = (AnotacionCiudadanoTMP) itr.next();

                    String idCiudadanoTMP = anotaCiudadanoTMP.getIdCiudadano();

                    CiudadanoTMPPk ciudId = new CiudadanoTMPPk();
                    ciudId.idCiudadanoTmp = idCiudadanoTMP;
                    CiudadanoTMP ciudaTMP = ciudDAO.getCiudadanoTMP(ciudId, pm);
                    String idWorkflow = null;

                    if (turno != null) {
                        idWorkflow = turno.getIdWorkflow();
                    }

                    if (ciudaTMP != null && idWorkflow != null) {
                        if (!hasMoreAnotacionCiudadanoTMPbyCiudadanoTMP(idCiudadanoTMP, folio.getIdMatricula(), idWorkflow, pm)) {
                            // Se puede eliminar el CiudadanoTemporal
                            if (ciudaTMP.getNumeroRadicacion() != null && ciudaTMP.getNumeroRadicacion().equals(idWorkflow)) {
                                pm.deletePersistent(ciudaTMP);
                            }
                        }
                    }

                    //}
                    //Si el ciudadano esta en temporal se valida que sea el unico registro en ciudadanoTemporal
                }
            } else {
                //La anotación temporal se debe actualizar con los datos de la anotación "datos"
                if (datos.getComentario() != null) {
                    toUpdate.setComentario(datos.getComentario());
                }

                if (datos.isToUpdateValor()) {
                    toUpdate.setValor(datos.getValor());
                }
                /* JAlcaza caso Mantis 03996 Acta - Requerimiento No 186 - Fechas de radicación y documento turnos de correcciones
                 * No se permitia la actualización de fechas en anotaciones temporales
                 */
                if (datos.getFechaRadicacion() != null) {
                    toUpdate.setFechaRadicacion(datos.getFechaRadicacion());
                }
                
                if (datos.getModalidad() != null) {
                    toUpdate.setModalidad(datos.getModalidad());
                }

                if (datos.getNumRadicacion() != null) {
                    toUpdate.setNumRadicacion(datos.getNumRadicacion());
                }

                if (datos.getOrden() != null) {
                    //Se actualiza en caso que sea diferente al orden actual
                    if (!datos.getOrden().equals(toUpdate.getOrden())) {
                        //1. Se valida el orden insertado
                        long nuevoOrden = this.validarYObtenerOrden(folio,
                                datos.getOrden(), pm);

                        //2. Obtenemos el número con ceros a la izquierda con el fin de compararlo
                        String nuevoOrdenLPAD = this.getLPAD(datos.getOrden());

                        //El orden solo cambia la forma en que está escrito
                        //el número, pero NO afecta el ordenamiento
                        if (!nuevoOrdenLPAD.equals(toUpdate.getOrdenLPAD())) {
                            //El cambio de orden SI afecta el ordenamiento
                            String ordenAnterior = toUpdate.getOrdenLPAD();

                            if (nuevoOrdenLPAD.compareTo(ordenAnterior) > 0) {
                                //El nuevoOrden es mayor que el anterior
                                //Si es mayor, se tienen que actualizar las anotaciones
                                //temporales que le siguen
                                this.actualizarOrdenAnotaciones(folio,
                                        ordenAnterior, nuevoOrdenLPAD, -1, false,
                                        usuario, turno, pm);
                            } else {
                                //El nuevoOrden es menor que el anterior
                                //Si es menor, se tienen que actualizar las anotaciones
                                //temporales y definitivas que la preceden
                                this.actualizarOrdenAnotaciones(folio,
                                        nuevoOrdenLPAD, ordenAnterior, 1, true,
                                        usuario, turno, pm);
                            }
                        }

                        toUpdate.setOrden(datos.getOrden());
                    }
                }

                if (datos.getNaturalezaJuridica() != null) {
                    NaturalezaJuridicaEnhancedPk njId = new NaturalezaJuridicaEnhancedPk();
                    njId.idNaturalezaJuridica = datos.getNaturalezaJuridica()
                            .getIdNaturalezaJuridica();
                    /*
                    *  @author Carlos Torres
                    *  @chage   se asigna valor a la propiedad version
                    *  @mantis 12705: Acta - Requerimiento No 056_453_Modificiación_de_Naturaleza_Jurídica
                     */
                    njId.version = datos.getNaturalezaJuridica().getVersion();

                    NaturalezaJuridicaEnhanced naturaleza = this.getNaturalezaJuridica(njId,
                            pm);

                    if (naturaleza == null) {
                        throw new DAOException(
                                "No encontró la naturaleza jurídica de la anotación con el ID: "
                                + njId.idNaturalezaJuridica);
                    }

                    if (!datos.getNaturalezaJuridica().getIdNaturalezaJuridica()
                            .equals(toUpdate.getNaturalezaJuridica()
                                    .getIdNaturalezaJuridica())) {
                        toUpdate.setNaturalezaJuridica(naturaleza);
//						SE ACTUALIZA LA ESPECIFICACIÓN 
                        toUpdate.setEspecificacion(toUpdate.getNaturalezaJuridica().getNombre());

                        //SE QUITA ESTA VALIDACION POR SOLICITUD DE LA SNR
                        /*
                        if (!this.validarNaturalezaJuridicaAnotacion(folio,
                                    toUpdate, pm)) {
                            throw new DAOException(
                                "No puede inscribir 2 veces una anotación con la misma naturaleza jurídica y el mismo documento");
                        }*/
                    }
                }

                //Se busca si se debe actualizar el documento
                if (datos.getDocumento() != null) {
                    if (turno != null) {
                        datos.getDocumento().setCirculo(turno.getIdCirculo());
                    }
                    this.updateAnotacionDocumento(toUpdate, datos, pm);
                }

                if (datos.getEstado() != null) {
                    EstadoAnotacionEnhancedPk eId = new EstadoAnotacionEnhancedPk();
                    eId.idEstadoAn = datos.getEstado().getIdEstadoAn();

                    EstadoAnotacionEnhanced estado = this.getEstadoAnotacion(eId,
                            pm);

                    if (estado == null) {
                        throw new DAOException(
                                "No encontró el estado de la anotación con el ID: "
                                + eId.idEstadoAn);
                    }

                    toUpdate.setEstado(estado);
                }

                //TODO pendiente si se actualizan datos relacionados al documento
                //y la radicacion
                //Revisamos si se deben actualizar los ciudadanos
                ArrayList ciudadanos = new ArrayList(datos.getAnotacionesCiudadanoTMPs());
                Collections.sort(ciudadanos, new IsToDeleteAnotacionCiudadanoTMPComparator());
                AnotacionCiudadanoTMP ciud;

                for (Iterator itr = ciudadanos.iterator(); itr.hasNext();) {
                    ciud = (AnotacionCiudadanoTMP) itr.next();

                    //Validamos que la anotacion ciudadano tenga el objeto
                    //ciudadano
                    if (ciud.getCiudadano() == null) {
                        throw new DAOException(
                                "La anotación ciudadano debe tener el objeto ciudadano");
                    }

                    //Para cada anotacionCiudadano revisamos si se tiene que
                    //agregar o se tiene que actualizar
                    if ((ciud.getCiudadano().getIdCiudadano() != null)
                            && (ciud.getRolPersona() != null)) {
                        //Se debe actualizar la anotación ciudadano
                        AnotacionCiudadanoTMPPk acid = new AnotacionCiudadanoTMPPk();
                        acid.idAnotacionTmp = toUpdate.getIdAnotacionTmp();
                        acid.idCiudadano = ciud.getIdCiudadano();
                        acid.idMatricula = toUpdate.getIdMatricula();
                        acid.rolPersona = ciud.getRolPersona();

                        AnotacionCiudadanoTMP acTMP = this.getAnotacionCiudadanoTMP(acid,
                                pm);

                        if (acTMP == null) {
                            throw new DAOException(
                                    "No se encontró la anotación ciudadano que se quiere actualizar");
                        }

                        if (ciud.isToDelete()) {
                            toUpdate.removeAnotacionesCiudadanoTMP(acTMP);
                            pm.deletePersistent(acTMP);
                        } else if (ciud.isToUpdate()) {
                            acTMP.setMarcaPropietario(ciud.getMarcaPropietario());
                            acTMP.setParticipacion(ciud.getParticipacion());
                        } else {
                            //Se quiere editar el ciudadano. Desde este punto SOLO se puede editar el
                            //ciudadano si NO existe ninguna anotación definitiva que lo referencie
                            if (!this.isCiudadanoInAnotacionDefinitiva(acTMP.getCiudadano(), pm)) {
                                CiudadanoEnhanced ciudToUpdate = acTMP.getCiudadano();
                                ciudToUpdate.setTipoPersona(ciud.getCiudadano().getTipoPersona());
                                ciudToUpdate.setNombre(ciud.getCiudadano().getNombre());
                                ciudToUpdate.setApellido1(ciud.getCiudadano().getApellido1());
                                ciudToUpdate.setSexo(ciud.getCiudadano().getSexo());
                                ciudToUpdate.setApellido2(ciud.getCiudadano().getApellido2());
                                if (ciud.getCiudadano().getTelefono() != null) {
                                    ciudToUpdate.setTelefono(ciud.getCiudadano().getTelefono());
                                }
                            }
                        }
                    } else {
                        this.addAnotacionCiudadanoToAnotacionTMP(toUpdate,
                                ciud, turno, pm);
                        pm.makePersistent(ciud);
                        toUpdate.addAnotacionesCiudadanoTMP(ciud);
                    }
                    //Ejecutamos el borrado
                    VersantPersistenceManager pm2 = (VersantPersistenceManager) pm;
                    pm2.flush();
                }

                //Revisamos si se deben actualizar o insertar salvedades de anotación
                List salvedades = datos.getSalvedadesTMPs();
                SalvedadAnotacionTMP sal;

                for (Iterator itr = salvedades.iterator(); itr.hasNext();) {
                    sal = (SalvedadAnotacionTMP) itr.next();

                    //Para cada SalvedadAnotacion revisamos si se tiene que
                    //agregar o se tiene que actualizar
                    if (sal.getIdSalvedadAnTmp() != null) {
                        //La salvedad se tiene que actualizar o borrar
                        SalvedadAnotacionTMPPk sid = new SalvedadAnotacionTMPPk();
                        sid.idSalvedadAnTmp = sal.getIdSalvedadAnTmp();
                        sid.idAnotacionTmp = toUpdate.getIdAnotacionTmp();
                        sid.idMatricula = toUpdate.getIdMatricula();

                        SalvedadAnotacionTMP salAux = this.getSalvedadAnotacionTMP(sid,
                                pm);

                        if (salAux == null) {
                            throw new DAOException(
                                    "No se encontró la salvedad de la anotación que se quiere actualizar");
                        }

                        if (sal.isToDelete()) {
                            //Eliminar salvedad
                            toUpdate.removeSalvedadesTMP(salAux);
                            pm.deletePersistent(salAux);
                        } else {
                            //Actualizar salvedad
                            if (sal.getDescripcion() != null) {
                                salAux.setDescripcion(sal.getDescripcion());
                            }
                        }
                    } else {
                        this.addSalvedadToAnotacionTMP(toUpdate, sal, usuario,
                                pm);
                        pm.makePersistent(sal);
                        toUpdate.addSalvedadesTMP(sal);
                    }
                }

                //Revisamos si se deben insertar o eliminar cancelaciones
                List cancelaciones = datos.getAnotacionesCancelacionTMPs();
                CancelacionTMP can;

                for (Iterator itr = cancelaciones.iterator(); itr.hasNext();) {
                    can = (CancelacionTMP) itr.next();

                    //Para cada Cancelacion revisamos si se tiene que
                    //agregar o se tiene que eliminar
                    if (can.isToDelete()) {
                        //La cancelacion se debe eliminar
                        CancelacionTMP toDel = this.getCancelacionTMP(can,
                                toUpdate, pm);

                        if (toDel == null) {
                            throw new DAOException(
                                    "No se encontró la cancelación que se quiere eliminar");
                        }

                        //Eliminar la cancelación
                        toUpdate.removeAnotacionesCancelacionTMP(toDel);
                        pm.deletePersistent(toDel);
                    } else {
                        this.addCancelacionToAnotacionTMP(toUpdate, can,
                                usuario, pm);
                        pm.makePersistent(can);
                        toUpdate.addAnotacionesCancelacionTMP(can);
                    }
                }
            }
        } catch (DAOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw e;
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }

        return rta;
    }

    /**
     * Actualiza una anotación temporal de un folio. Si el flag toDelete está en
     * true elimina la anotación temporal
     *
     * @param folio
     * @param auxAn
     * @param pm
     * @return
     * @throws DAOException
     */
    protected boolean actualizarAnotacionTMPCreacionDirecta(FolioEnhanced folio,
            AnotacionTMP toUpdate, AnotacionTMP datos, UsuarioEnhanced usuario,
            boolean soloEliminarContraparteTemporal, TurnoEnhanced turno, PersistenceManager pm) throws DAOException {
        boolean rta = false;
        JDOGenieCiudadanoDAO ciudDAO = new JDOGenieCiudadanoDAO();
        Anotacion anotacionDatos;

        try {
            if (datos.isToDelete()) {
                //La anotación temporal se debe eliminar
                //Se comprueba que el tipo de la anotación no sea ni generadora
                //ni derivada puesto que estas anotaciones tienen relación
                //con otras anotaciones a través de folio derivado y estas no
                //se pueden eliminar

                boolean isTipoAnotacionDerivado = CTipoAnotacion.DERIVADO.equals(toUpdate.getTipoAnotacion().getIdTipoAnotacion());

                if (isTipoAnotacionDerivado && !soloEliminarContraparteTemporal) {
                    //Se lanza excepción porque no puede eliminar una anotación de tipo derivada
                    throw new DAOException("No puede eliminar una anotación de tipo DERIVADO, si desea borrar la segregación o englobe debe hacerlo desde la anotación de algún folio matriz");
                }

                // si no es tipo derivado
                // se sigue el flujo normal
                flujoNormal:
                {
                    //Se verifica si la anotación a borrar está siendo cancelada por
                    //otra anotación
                    AnotacionTMP canceladora = this.getAnotacionCanceladoraTMP(toUpdate,
                            pm);

                    if (canceladora != null) {
                        throw new DAOException(
                                "No puede eliminar la anotación, está cancelada por otra anotación temporal con ID: "
                                + canceladora.getOrden());
                    }

                    //Se verifica si la anotación a borrar es de tipo generadora para eliminar
                    //los folios creados
                    if (CTipoAnotacion.GENERADORA.equals(toUpdate.getTipoAnotacion().getIdTipoAnotacion())) {
                        //Concepto para guardar en la tabla de matrícula no grabada
                        String concepto = "Eliminación de anotación temporal generadora (Seg o Eng). ID_ANOTACION_TMP=" + datos.getIdAnotacionTmp();

                        List hijos = toUpdate.getAnotacionesHijosTMPs();
                        FolioDerivadoTMP folDer;
                        FolioEnhanced folioHijoToDelete;
                        AnotacionTMP anotacionHijaToDelete;
                        for (Iterator it = hijos.iterator(); it.hasNext();) {
                            folDer = (FolioDerivadoTMP) it.next();
                            folioHijoToDelete = folDer.getHijoTmp().getFolio();
                            anotacionHijaToDelete = folDer.getHijoTmp();
                            //Se revisa si la anotación hija tiene más padres para eliminar las otras anotaciones
                            //de englobe y los folios derivados respectivos
                            if (anotacionHijaToDelete.getAnotacionesPadreTMPs().size() > 1) {
                                //El padre es de un englobe, se borran las demás anotaciones del englobe y el folio
                                //creado
                                FolioDerivadoTMP folDerPadre;
                                AnotacionTMP anotacionPadreToDelete;
                                for (Iterator it2 = anotacionHijaToDelete.getAnotacionesPadreTMPs().iterator(); it2.hasNext();) {
                                    folDerPadre = (FolioDerivadoTMP) it2.next();
                                    anotacionPadreToDelete = folDerPadre.getPadreTmp();
                                    if (!anotacionPadreToDelete.getIdAnotacionTmp().equals(toUpdate.getIdAnotacionTmp())) {
                                        //Si el padre no es la misma anotación que se está intentando borrar (borrado de anotaciones hermanas)
                                        //La anotación padre en cuestión se borra el final (pm.deletePersistent(toUpdate))
                                        this.reordenarAnotacionesTemporales(anotacionPadreToDelete.getFolio(), anotacionPadreToDelete, pm);
                                        //anotacionPadreToDelete.getFolio().removeAnotacionesTMP(anotacionPadreToDelete);
                                        pm.deletePersistent(anotacionPadreToDelete);
                                    } else {
                                        pm.deletePersistent(folDerPadre);
                                    }
                                }
                                this.deleteFolio(anotacionHijaToDelete.getFolio(), pm, usuario, concepto);
                            } else {
                                //El padre es de una segregación, se borra el folio derivado y el folio creado a partir
                                //de esta segregación
                                pm.deletePersistent(folDer);
                                this.deleteFolio(folioHijoToDelete, pm, usuario, concepto);
                            }

                        }
                    }
                    //Bug 3432 Si la anotación que se está eliminando corresponde a la última, se actualiza el
                    // secuencial de anotaciones temporales.

                    if (toUpdate.getIdAnotacionTmp().equals(String.valueOf(folio.getLastIdAnotacionTMP()))) {
                        folio.setLastIdAnotacionTMP(folio.getLastIdAnotacionTMP() - 1);
                    }

                    AnotacionEnhancedPk anotacionDefinitiva_Id;
                    anotacionDefinitiva_Id = new AnotacionEnhancedPk();
                    anotacionDefinitiva_Id.idMatricula = toUpdate.getIdMatricula();
                    anotacionDefinitiva_Id.idAnotacion = toUpdate.getIdAnotacionTmp();

                    if (null == this.getAnotacionByID(anotacionDefinitiva_Id, pm)) {
                        this.reordenarAnotacionesTemporales(folio, toUpdate, pm);
                    } // if

                    //folio.removeAnotacionesTMP(toUpdate);
                    this.deleteAnotacionTMP(toUpdate, pm);

                    //se eliminaran los ciudadanos temporales
                } // :flujoNormal // Se debe eliminar el ciudadano temporal

                //if (soloEliminarContraparteTemporal) {
                // Se valida que sea el ultimo anotacionCiudadanoTMP 
                //Si hay mas anotacionCiudadanoTemporal
                //Se recorren todos los AnotacionCiudadanoTmp de la anotacion y se verifica si esta el ciudadano en temporal
                List anotacionesCiudadano = datos.getAnotacionesCiudadanoTMPs();
                for (Iterator itr = anotacionesCiudadano.iterator(); itr.hasNext();) {
                    AnotacionCiudadanoTMP anotaCiudadanoTMP = (AnotacionCiudadanoTMP) itr.next();

                    String idCiudadanoTMP = anotaCiudadanoTMP.getIdCiudadano();

                    CiudadanoTMPPk ciudId = new CiudadanoTMPPk();
                    ciudId.idCiudadanoTmp = idCiudadanoTMP;
                    CiudadanoTMP ciudaTMP = ciudDAO.getCiudadanoTMP(ciudId, pm);
                    String idWorkflow = null;

                    if (turno != null) {
                        idWorkflow = turno.getIdWorkflow();
                    }

                    if (ciudaTMP != null && idWorkflow != null) {
                        if (!hasMoreAnotacionCiudadanoTMPbyCiudadanoTMP(idCiudadanoTMP, folio.getIdMatricula(), idWorkflow, pm)) {
                            // Se puede eliminar el CiudadanoTemporal
                            if (ciudaTMP.getNumeroRadicacion() != null && ciudaTMP.getNumeroRadicacion().equals(idWorkflow)) {
                                pm.deletePersistent(ciudaTMP);
                            }
                        }
                    }

                    //}
                    //Si el ciudadano esta en temporal se valida que sea el unico registro en ciudadanoTemporal
                }
            } else {
                //La anotación temporal se debe actualizar con los datos de la anotación "datos"
                if (datos.getComentario() != null) {
                    toUpdate.setComentario(datos.getComentario());
                }

                if (datos.isToUpdateValor()) {
                    toUpdate.setValor(datos.getValor());
                }

                if (datos.getEspecificacion() != null) {
                    toUpdate.setEspecificacion(datos.getEspecificacion());
                }

                if (datos.getOrden() != null) {
                    //Se actualiza en caso que sea diferente al orden actual
                    if (!datos.getOrden().equals(toUpdate.getOrden())) {
                        //1. Se valida el orden insertado
                        long nuevoOrden = this.validarYObtenerOrden(folio,
                                datos.getOrden(), pm);

                        //2. Obtenemos el número con ceros a la izquierda con el fin de compararlo
                        String nuevoOrdenLPAD = this.getLPAD(datos.getOrden());

                        //El orden solo cambia la forma en que está escrito
                        //el número, pero NO afecta el ordenamiento
                        if (!nuevoOrdenLPAD.equals(toUpdate.getOrdenLPAD())) {
                            //El cambio de orden SI afecta el ordenamiento
                            String ordenAnterior = toUpdate.getOrdenLPAD();

                            if (nuevoOrdenLPAD.compareTo(ordenAnterior) > 0) {
                                //El nuevoOrden es mayor que el anterior
                                //Si es mayor, se tienen que actualizar las anotaciones
                                //temporales que le siguen
                                this.actualizarOrdenAnotaciones(folio,
                                        ordenAnterior, nuevoOrdenLPAD, -1, false,
                                        usuario, turno, pm);
                            } else {
                                //El nuevoOrden es menor que el anterior
                                //Si es menor, se tienen que actualizar las anotaciones
                                //temporales y definitivas que la preceden
                                this.actualizarOrdenAnotaciones(folio,
                                        nuevoOrdenLPAD, ordenAnterior, 1, true,
                                        usuario, turno, pm);
                            }
                        }

                        toUpdate.setOrden(datos.getOrden());
                    }
                }

                if (datos.getNaturalezaJuridica() != null) {
                    NaturalezaJuridicaEnhancedPk njId = new NaturalezaJuridicaEnhancedPk();
                    njId.idNaturalezaJuridica = datos.getNaturalezaJuridica()
                            .getIdNaturalezaJuridica();
                    /*
                    *  @author Carlos Torres
                    *  @chage   se asigna valor a la propiedad version
                    *  @mantis 12705: Acta - Requerimiento No 056_453_Modificiación_de_Naturaleza_Jurídica
                     */
                    njId.version = datos.getNaturalezaJuridica().getVersion();
                    NaturalezaJuridicaEnhanced naturaleza = this.getNaturalezaJuridica(njId,
                            pm);

                    if (naturaleza == null) {
                        throw new DAOException(
                                "No encontró la naturaleza jurídica de la anotación con el ID: "
                                + njId.idNaturalezaJuridica);
                    }

                    if (!datos.getNaturalezaJuridica().getIdNaturalezaJuridica()
                            .equals(toUpdate.getNaturalezaJuridica()
                                    .getIdNaturalezaJuridica())) {
                        toUpdate.setNaturalezaJuridica(naturaleza);
                        //Se valida que no exista una anotación temporal ya insertada
                        //con la misma naturaleza jurídica y con el mismo documento

                        //SE QUITA ESTA VALIDACION POR SOLICITUD DE LA SNR
                        /*
                        if (!this.validarNaturalezaJuridicaAnotacion(folio,
                                    toUpdate, pm)) {
                            throw new DAOException(
                                "No puede inscribir 2 veces una anotación con la misma naturaleza jurídica y el mismo documento");
                        }*/
                    }
                }

                if (datos.getEstado() != null) {
                    EstadoAnotacionEnhancedPk eId = new EstadoAnotacionEnhancedPk();
                    eId.idEstadoAn = datos.getEstado().getIdEstadoAn();

                    EstadoAnotacionEnhanced estado = this.getEstadoAnotacion(eId,
                            pm);

                    if (estado == null) {
                        throw new DAOException(
                                "No encontró el estado de la anotación con el ID: "
                                + eId.idEstadoAn);
                    }

                    toUpdate.setEstado(estado);
                }

                //Se actualiza el numero de radicacion de la anotacion
                if (datos.getNumRadicacion() != null) {
                    toUpdate.setNumRadicacion(datos.getNumRadicacion());
                }

                //Se actualiza la fecha de radicacion
                if (datos.getFechaRadicacion() != null) {
                    toUpdate.setFechaRadicacion(datos.getFechaRadicacion());
                }

                //Se debe actualizar el documento
                if (datos.getDocumento() != null) {

                    DocumentoEnhanced doc = datos.getDocumento();

                    String idDocumento = getIdDocumentoFromAnotacionTMP(toUpdate.getIdAnotacionTmp(), toUpdate.getIdMatricula(), pm);

                    DocumentoEnhancedPk oid = new DocumentoEnhancedPk();
                    oid.idDocumento = idDocumento;

                    DocumentoEnhanced aux = this.getDocumento(oid, pm);

                    aux.setComentario(datos.getComentario());
                    aux.setNumero(doc.getNumero());
                    aux.setFecha(doc.getFecha());

                    TipoDocumentoEnhancedPk tId = new TipoDocumentoEnhancedPk();
                    tId.idTipoDocumento = datos.getDocumento().getIdDocumento();

                    if (datos.getDocumento().getOficinaOrigen() != null) {
                        JDOGenieZonaRegistralDAO zonaDAO = new JDOGenieZonaRegistralDAO();

                        OficinaOrigenEnhancedPk ofid = new OficinaOrigenEnhancedPk();
                        ofid.idOficinaOrigen = datos.getDocumento().getOficinaOrigen().getIdOficinaOrigen();
                        /*
                          *  @author Carlos Torres
                          *  @chage   se agrega validacion de version diferente
                          *  @mantis 0013414: Acta - Requerimiento No 069_453_Código_Notaria_NC
                         */
                        ofid.version = datos.getDocumento().getOficinaOrigen().getVersion();

                        OficinaOrigenEnhanced oficina = zonaDAO.getOficinaOrigen(ofid, pm);

                        if (oficina == null) {
                            throw new DAOException(
                                    "La oficina origen no existe. IdOficina: " + ofid.idOficinaOrigen);
                        }

                        TipoDocumentoEnhancedPk tdid = new TipoDocumentoEnhancedPk();
                        tdid.idTipoDocumento = datos.getDocumento().getTipoDocumento().getIdTipoDocumento();

                        TipoDocumentoEnhanced tipoDoc = this.getTipoDocumento(tdid, pm);

                        if (tipoDoc == null) {
                            throw new DAOException(
                                    "El tipo de documento no existe. IdTipoDocumento: "
                                    + tdid.idTipoDocumento);
                        }

                        aux.setOficinaOrigen(oficina);
                        aux.setTipoDocumento(tipoDoc);
                        aux.setOficinaInternacional(doc.getOficinaInternacional());

                    }
                    //toUpdate.setDocumento(doc);

                    //updateAnotacionDocumento(toUpdate,datos,pm);
                    // Se debe 
                }

                //Se actualiza los datos de antiguo sistema
//              Se asocia la información de antiguo sistema
                if (datos.getDatosAntiguoSistema() != null) {
                    DatosAntiguoSistemaEnhanced datosAS = datos.getDatosAntiguoSistema();

                    String idDatosAntiguoSis = getIdDatosAntiguoSistemaFromAnotacionTMP(toUpdate.getIdAnotacionTmp(), toUpdate.getIdMatricula(), pm);

                    //Se mira si la información de antiguo sistema ya existe en la base de datos
                    DatosAntiguoSistemaEnhancedPk dASid = new DatosAntiguoSistemaEnhancedPk();
                    dASid.idDatosAntiguoSistema = idDatosAntiguoSis;

                    DatosAntiguoSistemaEnhanced dASVal = this.getDatosAntiguoSistema(dASid, pm);

                    if (dASVal != null) {
                        //Se asocia
                        //datos.setDatosAntiguoSistema(dASVal);
                        dASVal.setComentario(datosAS.getComentario());
                        dASVal.setLibroAnio(datosAS.getLibroAnio());
                        dASVal.setLibroNumero(datosAS.getLibroNumero());
                        dASVal.setLibroPagina(datosAS.getLibroPagina());
                        dASVal.setLibroTipo(datosAS.getLibroTipo());
                        dASVal.setTomoAnio(datosAS.getTomoAnio());
                        dASVal.setTomoMunicipio(datosAS.getTomoMunicipio());
                        dASVal.setTomoNumero(datosAS.getTomoNumero());
                        dASVal.setTomoPagina(datosAS.getTomoPagina());
                    }
                }

                //TODO pendiente si se actualizan datos relacionados al documento
                //y la radicacion
                //Revisamos si se deben actualizar los ciudadanos
                ArrayList ciudadanos = new ArrayList(datos.getAnotacionesCiudadanoTMPs());
                Collections.sort(ciudadanos, new IsToDeleteAnotacionCiudadanoTMPComparator());
                AnotacionCiudadanoTMP ciud;

                for (Iterator itr = ciudadanos.iterator(); itr.hasNext();) {
                    ciud = (AnotacionCiudadanoTMP) itr.next();

                    //Validamos que la anotacion ciudadano tenga el objeto
                    //ciudadano
                    if (ciud.getCiudadano() == null) {
                        throw new DAOException(
                                "La anotación ciudadano debe tener el objeto ciudadano");
                    }

                    //Para cada anotacionCiudadano revisamos si se tiene que
                    //agregar o se tiene que actualizar
                    if ((ciud.getCiudadano().getIdCiudadano() != null)
                            && (ciud.getRolPersona() != null)) {
                        //Se debe actualizar la anotación ciudadano
                        AnotacionCiudadanoTMPPk acid = new AnotacionCiudadanoTMPPk();
                        acid.idAnotacionTmp = toUpdate.getIdAnotacionTmp();
                        acid.idCiudadano = ciud.getIdCiudadano();
                        acid.idMatricula = toUpdate.getIdMatricula();
                        acid.rolPersona = ciud.getRolPersona();

                        AnotacionCiudadanoTMP acTMP = this.getAnotacionCiudadanoTMP(acid,
                                pm);

                        if (acTMP == null) {
                            throw new DAOException(
                                    "No se encontró la anotación ciudadano que se quiere actualizar");
                        }

                        if (ciud.isToDelete()) {
                            toUpdate.removeAnotacionesCiudadanoTMP(acTMP);
                            pm.deletePersistent(acTMP);
                        } else {
                            //Se quiere editar el ciudadano. Desde este punto SOLO se puede editar el
                            //ciudadano si NO existe ninguna anotación definitiva que lo referencie
                            if (!this.isCiudadanoInAnotacionDefinitiva(acTMP.getCiudadano(), pm)) {
                                CiudadanoEnhanced ciudToUpdate = acTMP.getCiudadano();
                                ciudToUpdate.setTipoPersona(ciud.getCiudadano().getTipoPersona());
                                ciudToUpdate.setNombre(ciud.getCiudadano().getNombre());
                                ciudToUpdate.setSexo(ciud.getCiudadano().getSexo());
                                ciudToUpdate.setApellido1(ciud.getCiudadano().getApellido1());
                                ciudToUpdate.setApellido2(ciud.getCiudadano().getApellido2());
                                if (ciud.getCiudadano().getTelefono() != null) {
                                    ciudToUpdate.setTelefono(ciud.getCiudadano().getTelefono());
                                }
                            }
                        }
                    } else {
                        this.addAnotacionCiudadanoToAnotacionTMP(toUpdate,
                                ciud, turno, pm);
                        pm.makePersistent(ciud);
                        toUpdate.addAnotacionesCiudadanoTMP(ciud);
                    }
                    //Ejecutamos el borrado
                    VersantPersistenceManager pm2 = (VersantPersistenceManager) pm;
                    pm2.flush();
                }

                //Revisamos si se deben actualizar o insertar salvedades de anotación
                List salvedades = datos.getSalvedadesTMPs();
                SalvedadAnotacionTMP sal;

                for (Iterator itr = salvedades.iterator(); itr.hasNext();) {
                    sal = (SalvedadAnotacionTMP) itr.next();

                    //Para cada SalvedadAnotacion revisamos si se tiene que
                    //agregar o se tiene que actualizar
                    if (sal.getIdSalvedadAnTmp() != null) {
                        //La salvedad se tiene que actualizar o borrar
                        SalvedadAnotacionTMPPk sid = new SalvedadAnotacionTMPPk();
                        sid.idSalvedadAnTmp = sal.getIdSalvedadAnTmp();
                        sid.idAnotacionTmp = toUpdate.getIdAnotacionTmp();
                        sid.idMatricula = toUpdate.getIdMatricula();

                        SalvedadAnotacionTMP salAux = this.getSalvedadAnotacionTMP(sid,
                                pm);

                        if (salAux == null) {
                            sal.setIdSalvedadAnTmp(null);
                            this.addSalvedadToAnotacionTMP(toUpdate, sal, usuario,
                                    pm);
                            pm.makePersistent(sal);
                            toUpdate.addSalvedadesTMP(sal);
                        } else {
                            if (sal.isToDelete()) {
                                //Eliminar salvedad
                                toUpdate.removeSalvedadesTMP(salAux);
                                pm.deletePersistent(salAux);
                            } else {
                                //Actualizar salvedad
                                if (sal.getDescripcion() != null) {
                                    salAux.setDescripcion(sal.getDescripcion());
                                }
                            }
                        }
                    } else {
                        this.addSalvedadToAnotacionTMP(toUpdate, sal, usuario,
                                pm);
                        pm.makePersistent(sal);
                        toUpdate.addSalvedadesTMP(sal);
                    }
                }

                //Revisamos si se deben insertar o eliminar cancelaciones
                List cancelaciones = datos.getAnotacionesCancelacionTMPs();
                CancelacionTMP can;

                for (Iterator itr = cancelaciones.iterator(); itr.hasNext();) {
                    can = (CancelacionTMP) itr.next();

                    //Para cada Cancelacion revisamos si se tiene que
                    //agregar o se tiene que eliminar
                    if (can.isToDelete()) {
                        //La cancelacion se debe eliminar
                        CancelacionTMP toDel = this.getCancelacionTMP(can,
                                toUpdate, pm);

                        if (toDel == null) {
                            throw new DAOException(
                                    "No se encontró la cancelación que se quiere eliminar");
                        }

                        //Eliminar la cancelación
                        toUpdate.removeAnotacionesCancelacionTMP(toDel);
                        pm.deletePersistent(toDel);
                    } else {
                        this.addCancelacionToAnotacionTMP(toUpdate, can,
                                usuario, pm);
                        pm.makePersistent(can);
                        toUpdate.addAnotacionesCancelacionTMP(can);
                    }
                }
            }
        } catch (DAOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw e;
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }

        return rta;
    }

    /*
     * Metodo que devuelve el identificador de una documento que esta asociado a una anotacion Temporal
     * 
     */
    public String getIdDocumentoFromAnotacionTMP(String idAnotacion, String idMatricula, PersistenceManager pm) throws DAOException {

        String rta = "";
        Connection connection = null;
        PreparedStatement ps = null;
        ResultSet rs = null;

        VersantPersistenceManager jdoPM = null;

        try {

            String consulta
                    = "SELECT ID_DOCUMENTO FROM SIR_NE_ANOTACION_TMP "
                    + "WHERE ID_MATRICULA = ? "
                    + "AND ID_ANOTACION_TMP = ? ";

            jdoPM = (VersantPersistenceManager) pm;

            connection = jdoPM.getJdbcConnection(null);
            ps = connection.prepareStatement(consulta);

            ps.setString(1, idMatricula);
            ps.setString(2, idAnotacion);

            rs = ps.executeQuery();

            while (rs.next()) {
                rta = rs.getString(1);
            }
        } catch (SQLException e) {
            if (jdoPM.currentTransaction().isActive()) {
                jdoPM.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        } catch (JDOObjectNotFoundException e) {
            if (jdoPM.currentTransaction().isActive()) {
                jdoPM.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        } catch (JDOException e) {
            if (jdoPM.currentTransaction().isActive()) {
                jdoPM.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        } catch (Throwable e) {
            if (jdoPM.currentTransaction().isActive()) {
                jdoPM.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        } finally {
            try {
                if (rs != null) {
                    rs.close();
                }
                if (ps != null) {
                    ps.close();
                }
                if (connection != null) {
                    connection.close();
                }
            } catch (SQLException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e);
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
                throw new DAOException(e.getMessage(), e);
            }
        }
        return rta;
    }

    /*
     * Metodo que devuelve el identificador de una documento que esta asociado a una anotacion Temporal
     * 
     */
    public String getIdDatosAntiguoSistemaFromAnotacionTMP(String idAnotacion, String idMatricula, PersistenceManager pm) throws DAOException {

        String rta = "";
        Connection connection = null;
        PreparedStatement ps = null;
        ResultSet rs = null;

        VersantPersistenceManager jdoPM = null;

        try {

            String consulta
                    = "SELECT ID_DATOS_ANT_SISTEMA FROM SIR_NE_ANOTACION_TMP "
                    + "WHERE ID_MATRICULA = ? "
                    + "AND ID_ANOTACION_TMP = ? ";

            jdoPM = (VersantPersistenceManager) pm;

            connection = jdoPM.getJdbcConnection(null);
            ps = connection.prepareStatement(consulta);

            ps.setString(1, idMatricula);
            ps.setString(2, idAnotacion);

            rs = ps.executeQuery();

            while (rs.next()) {
                rta = rs.getString(1);
            }
        } catch (SQLException e) {
            if (jdoPM.currentTransaction().isActive()) {
                jdoPM.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        } catch (JDOObjectNotFoundException e) {
            if (jdoPM.currentTransaction().isActive()) {
                jdoPM.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        } catch (JDOException e) {
            if (jdoPM.currentTransaction().isActive()) {
                jdoPM.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        } catch (Throwable e) {
            if (jdoPM.currentTransaction().isActive()) {
                jdoPM.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        } finally {
            try {
                if (rs != null) {
                    rs.close();
                }
                if (ps != null) {
                    ps.close();
                }
                if (connection != null) {
                    connection.close();
                }
            } catch (SQLException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e);
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
                throw new DAOException(e.getMessage(), e);
            }
        }
        return rta;
    }

    /**
     * Elimina un folio temporal dado su ID, el folio es desasociado del turno
     * al que se encuentre asociado
     *
     * @param folioID
     * @return
     * @throws DAOException
     */
    public boolean deleteFolio(FolioPk folioID, Usuario usuario) throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        try {
            pm.currentTransaction().setOptimistic(false);
            pm.currentTransaction().begin();

            FolioEnhanced fol = this.getFolioByID(new FolioEnhancedPk(folioID), pm);

            if (fol == null) {
                throw new DAOException("El folio no existe: idMatricula: " + folioID.idMatricula);
            }

            //Se valida que el usuario tenga bloqueado el folio:
            this.validarBloqueoFolio(fol, usuario, pm);

            //Obtener usuario persistente
            //Validamos el usuario y si tiene acceso al folio
            //para modificarlo
            UsuarioEnhancedPk uid = new UsuarioEnhancedPk();
            uid.idUsuario = usuario.getIdUsuario();

            UsuarioEnhanced us = this.getUsuarioByID(uid, pm);

            if (us == null) {
                throw new DAOException("El usuario especificado no existe: "
                        + uid.idUsuario);
            }

            BloqueoFolioEnhanced bloqueo = this.getBloqueoFolio(fol.getIdMatricula(),
                    pm);

            String concepto = null;
            if (bloqueo.getIdWorkflowBloqueo() != null) {
                TurnoEnhanced t = this.getTurnoByID(new TurnoEnhancedPk(bloqueo.getIdWorkflowBloqueo()), pm);
                if (t.getIdFase().equals(CFase.ANT_HOJA_RUTA)) {
                    concepto = "Eliminación de matrícula temporal creada en hoja de ruta";
                } else if (t.getIdFase().equals(CFase.CAL_CALIFICACION)) {
                    concepto = "Eliminación de matrícula temporal creada en calificación";
                }
            }

            this.deleteFolio(fol, pm, us, concepto);

            pm.currentTransaction().commit();
        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (DAOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (Exception e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        return true;
    }

    /**
     * Elimina un folio temporal dado su ID, y concepto de eliminacion. No se
     * valida el bloqueo del folio
     *
     * @param folioID, String concepto
     * @return
     * @throws DAOException
     */
    public boolean deleteFolio(FolioPk folioID, String concepto) throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        try {
            pm.currentTransaction().setOptimistic(false);
            pm.currentTransaction().begin();

            FolioEnhanced folio = this.getFolioByID(new FolioEnhancedPk(folioID), pm);

            if (folio == null) {
                throw new DAOException("El folio no existe: idMatricula: " + folioID.idMatricula);
            }
//			Se valida que el folio sea temporal:
            if (folio.isDefinitivo()) {
                throw new DAOException("No se puede eliminar el folio porque es definitivo");
            }

            //Se revisa si el folio tiene solicitudes asociadas
            Query query = pm.newQuery(SolicitudFolioEnhanced.class);
            query.declareParameters("FolioEnhanced fol");
            query.setFilter("this.folio==fol");
            Collection col = (Collection) query.execute(folio);
            for (Iterator iter = col.iterator(); iter.hasNext();) {
                SolicitudFolioEnhanced solicitudfolioenhanced = (SolicitudFolioEnhanced) iter.next();
                pm.deletePersistent(solicitudfolioenhanced);
            }

            FolioDatosTMP folTMP = null;
            try {
                folTMP = folio.getDatosTMP();
            } catch (JDOObjectNotFoundException ex) {
                folTMP = null;
            }

            if (folTMP != null) {
                pm.deletePersistent(folTMP);
            }

            //Se eliminan las anotaciones temporales
            AnotacionTMP anotaTMP;
            for (Iterator it2 = folio.getAnotacionesTMPs().iterator(); it2.hasNext();) {
                anotaTMP = (AnotacionTMP) it2.next();
                this.deleteAnotacionTMP(anotaTMP, pm);
            }

            //Se guarda el registro de la matrícula temporal (No grabada)
            MatriculaNoGrabadaEnhanced matNoGrab = new MatriculaNoGrabadaEnhanced();

            StringTokenizer st = new StringTokenizer(folio.getIdMatricula(), "-");
            matNoGrab.setIdCirculo(st.nextToken());
            matNoGrab.setIdMatNoGrabada(Long.parseLong(st.nextToken()));
            matNoGrab.setDescripcion(concepto);
            matNoGrab.setFechaCreacion(new Date());
            matNoGrab.setIdWorkflow(folio.getRadicacion());
            pm.makePersistent(matNoGrab);
            pm.deletePersistent(folio);
            pm.currentTransaction().commit();
            return true;
        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (DAOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw e;
        } catch (Exception e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }
    }

    /**
     * Elimina un folio persistente en la transacción. Revisa si tiene
     * solicitudes asociadas para eliminar también estas relaciones. Sólo se
     * puede eliminar un folio si éste es temporal
     *
     * @param folio
     * @param pm
     * @param usuario TODO
     * @param concepto TODO
     * @return
     * @throws DAOException
     */
    protected boolean deleteFolio(FolioEnhanced folio, PersistenceManager pm, UsuarioEnhanced usuario, String concepto) throws DAOException {
        try {
            //Se valida que el folio sea temporal:
            if (folio.isDefinitivo()) {
                throw new DAOException("No se puede eliminar el folio porque es definitivo");
            }

            //Se revisa si el folio tiene solicitudes asociadas
            Query query = pm.newQuery(SolicitudFolioEnhanced.class);
            query.declareParameters("FolioEnhanced fol");
            query.setFilter("this.folio==fol");
            Collection col = (Collection) query.execute(folio);
            for (Iterator iter = col.iterator(); iter.hasNext();) {
                SolicitudFolioEnhanced solicitudfolioenhanced = (SolicitudFolioEnhanced) iter.next();
                pm.deletePersistent(solicitudfolioenhanced);
            }

            FolioDatosTMP folTMP = null;
            try {
                folTMP = folio.getDatosTMP();
            } catch (JDOObjectNotFoundException ex) {
                folTMP = null;
            }

            if (folTMP != null) {
                pm.deletePersistent(folTMP);
            }

            //Se eliminan las anotaciones temporales
            AnotacionTMP anotaTMP;
            for (Iterator it2 = folio.getAnotacionesTMPs().iterator(); it2.hasNext();) {
                anotaTMP = (AnotacionTMP) it2.next();
                this.deleteAnotacionTMP(anotaTMP, pm);
            }

            //Se guarda el registro de la matrícula temporal (No grabada)
            MatriculaNoGrabadaEnhanced matNoGrab = new MatriculaNoGrabadaEnhanced();

            //3447 Se obtiene la información del bloqueo del folio para sacar
            //     turno, usuario y fase
            BloqueoFolioEnhanced bloqueo = this.getBloqueoFolio(folio.getIdMatricula(),
                    pm);

            if (bloqueo == null) {
                throw new DAOException("La matricula " + folio.getIdMatricula() + " no se encuentra bloqueada");
            }

            //Validamos que el usuario sea dueño del bloqueo del folio
            UsuarioEnhanced usuAux = this.getUsuarioByLlaveBloqueo(bloqueo.getLlaveBloqueo(),
                    pm);

            if (usuAux == null) {
                throw new DAOException(
                        "Error en la obtención del usuario a partir de la llave de bloqueo");
            }

            if (usuAux.getIdUsuario() != usuario.getIdUsuario()) {
                throw new DAOException(
                        "El usuario no es dueño del bloqueo del folio con matrícula " + folio.getIdMatricula()
                        + ". El turno asociado a la matrícula es: " + bloqueo.getIdWorkflowBloqueo());
            }

            String fase = null;
            if (bloqueo.getIdWorkflowBloqueo() != null) {
                TurnoEnhanced t = this.getTurnoByID(new TurnoEnhancedPk(bloqueo.getIdWorkflowBloqueo()), pm);
                if (t != null) {
                    fase = t.getIdFase();
                }
            }

            StringTokenizer st = new StringTokenizer(folio.getIdMatricula(), "-");
            matNoGrab.setIdCirculo(st.nextToken());
            matNoGrab.setIdMatNoGrabada(Long.parseLong(st.nextToken()));
            matNoGrab.setIdWorkflow(bloqueo.getIdWorkflowBloqueo());
            matNoGrab.setIdFase(fase);
            matNoGrab.setUsuario(usuario);
            matNoGrab.setDescripcion(concepto);
            matNoGrab.setFechaCreacion(new Date());
            pm.makePersistent(matNoGrab);
            Log.getInstance().debug(JDOGenieFolioDAO.class, "@@@FolioDAO; deleteFolio");

            pm.deletePersistent(folio);
            return true;
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }

    }

    /**
     * Elimina una anotación temporal persistente en una transacción. Revisa si
     * tiene datos de antiguo sistema asociados para borrarlos también.
     *
     * @param anotaTMP
     * @param pm
     * @return
     * @throws DAOException
     */
    protected boolean deleteAnotacionTMP(AnotacionTMP anotaTMP, PersistenceManager pm) throws DAOException {
        try {
            //Se revisa si la anotacion tiene datos de antiguo sistema asociados para borrarlos:
            DatosAntiguoSistemaEnhanced datosAntSis = anotaTMP.getDatosAntiguoSistema();
            if (datosAntSis != null) {
                pm.deletePersistent(datosAntSis);
            }

            pm.deletePersistent(anotaTMP);
            return true;
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }

    }

    /**
     * @param can
     * @param toUpdate
     * @param pm
     */
    protected CancelacionTMP getCancelacionTMP(CancelacionTMP can,
            AnotacionTMP cancel, PersistenceManager pm) throws DAOException {
        CancelacionTMP rta = null;

        try {
            AnotacionTMPPk aid = new AnotacionTMPPk();
            aid.idAnotacionTmp = cancel.getIdAnotacionTmp();
            aid.idMatricula = cancel.getIdMatricula();

            cancel = this.getAnotacionTMPByID(aid, pm);

            if (cancel == null) {
                rta = null;
            } else {
                //Se busca si la cancelación temporal que se se busca,
                //cancela a una anotación temporal
                if (can.getCanceladaDef() == null) {
                    throw new DAOException(
                            "La cancelación no tiene objeto cancelada para buscarla");
                }

                String idAnotaTMP = can.getCanceladaDef().getIdAnotacion();
                //*String obsoleto = CEstadoAnotacion.OBSOLETA;
                Query query = pm.newQuery(CancelacionTMP.class);
                query.setIgnoreCache(false);
                query.declareParameters(
                        "String idAnotaTMP, AnotacionTMP cancel");
                query.setFilter("this.canceladora == cancel &&\n"
                        + "this.canceladaTmp.idAnotacionTmp == idAnotaTMP &&\n"
                        + "this.anotacionTemporal==true");

                Collection col = (Collection) query.execute(idAnotaTMP, cancel);
                Iterator iter = col.iterator();

                if (iter.hasNext()) {
                    rta = (CancelacionTMP) iter.next();
                } else {
                    //Si no lo encontró, se busca si cancela a una anotación
                    //definitiva
                    query = pm.newQuery(CancelacionTMP.class);
                    query.setIgnoreCache(false);
                    query.declareParameters(
                            "String idAnotaTMP, AnotacionTMP cancel");
                    query.setFilter("this.canceladora == cancel &&\n"
                            + "this.canceladaDef.idAnotacion == idAnotaTMP &&\n"
                            + "this.anotacionTemporal==false");

                    col = (Collection) query.execute(idAnotaTMP, cancel);
                    iter = col.iterator();

                    if (iter.hasNext()) {
                        rta = (CancelacionTMP) iter.next();
                    }
                }
            }
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        }

        return rta;
    }

    /**
     * @param can
     * @param toUpdate
     * @param pm
     */
    protected boolean hasMoreAnotacionCiudadanoTMPbyCiudadanoTMP(String idCiudadanoTMP, String idCirculo, String idWorkflow, PersistenceManager pm) throws DAOException {

        int numAnotacionCiudadanos = 0;
        boolean rta = false;

        try {
            Query query = pm.newQuery(AnotacionCiudadanoTMP.class);
            query.declareVariables("CiudadanoTMP ciudadanoTMP");
            query.declareParameters("String idCiudadanoTmp, String numRadicacion");
            query.setFilter("this.idCiudadano == ciudadanoTMP.idCiudadanoTmp && \n"
                    + "ciudadanoTMP.idCiudadanoTmp == idCiudadanoTmp && \n"
                    + "ciudadanoTMP.numeroRadicacion == numRadicacion");
            Collection col = (Collection) query.execute(idCiudadanoTMP, idWorkflow);
            for (Iterator iter = col.iterator(); iter.hasNext();) {
                AnotacionCiudadanoTMP anotacionciudadanotmp = (AnotacionCiudadanoTMP) iter.next();
                numAnotacionCiudadanos++;
            }
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        }

        if (numAnotacionCiudadanos > 1) {
            rta = true;
        }

        return rta;
    }

    /**
     * @param can
     * @param toUpdate
     * @param pm
     */
    protected CancelacionEnhanced getCancelacion(CancelacionTMP can,
            AnotacionTMP cancel, PersistenceManager pm) throws DAOException {
        CancelacionEnhanced rta = null;
        AnotacionEnhanced canceladora;
        try {
            AnotacionEnhancedPk aid = new AnotacionEnhancedPk();
            aid.idAnotacion = cancel.getIdAnotacionTmp();
            aid.idMatricula = cancel.getIdMatricula();

            canceladora = this.getAnotacionByID(aid, pm);

            if (canceladora == null) {
                rta = null;
            } else {

                /* @author: Guillermo Cabrera.
                             * @change: Esta generando la excepción del caso Mantis 2558, ya que se esta validando
                             * solamente la cancelación definitiva.
                             * se comentarea y se modifica por el codigo lineas: 21270 a 21277.
                             *
                                //Se busca si la cancelación temporal que se se busca,
				//cancela a una anotación temporal
                            if (can.getCanceladaDef() == null)
                                {
					throw new DAOException(
						"La cancelación no tiene objeto cancelada para buscarla");
				}

                             String idAnota=can.getCanceladaDef().getIdAnotacion();
                             *
                 */
                /**
                 * @author: Guillermo Cabrera.
                 * @change: se evalua las anotaciones canceladas definitivas y
                 * temporales en caso de que el objeto sea diferente a null se
                 * obtiene el id de la anotacion cancelada. en caso de que los
                 * dos objetos sean nulos se envia la excepción. CASO MANTIS
                 * 2558 Requerimiento No 127
                 *
                 */
                String idAnota;

                if (can.getCanceladaDef() != null) {
                    idAnota = can.getCanceladaDef().getIdAnotacion();
                } else if (can.getCanceladaTmp() != null) {
                    idAnota = can.getCanceladaTmp().getIdAnotacionTmp();
                } else {
                    throw new DAOException("La cancelación no tiene objeto cancelada para buscarla");
                }

                //*String obsoleto = CEstadoAnotacion.OBSOLETA;
                Query query = pm.newQuery(CancelacionEnhanced.class);
                query.setIgnoreCache(false);
                query.declareParameters(
                        "String idAnota, AnotacionEnhanced cancel");
                query.setFilter("this.canceladora == cancel &&\n"
                        + "this.cancelada.idAnotacion == idAnota");

                Collection col = (Collection) query.execute(idAnota, canceladora);
                Iterator iter = col.iterator();

                if (iter.hasNext()) {
                    rta = (CancelacionEnhanced) iter.next();
                }
            }

        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        }

        return rta;
    }

    /**
     * Obtiene una AnotacionCiudadanoTMP dado su identificador, método usado en
     * transacciones se debe dar el PersistenceManager
     *
     * @param oid
     * @return objeto EstadoFolio
     * @throws DAOException
     */
    protected AnotacionCiudadanoTMP getAnotacionCiudadanoTMP(
            AnotacionCiudadanoTMPPk oid, PersistenceManager pm)
            throws DAOException {
        AnotacionCiudadanoTMP rta = null;

        if ((oid.idAnotacionTmp != null) && (oid.idCiudadano != null)
                && (oid.idMatricula != null) && (oid.rolPersona != null)) {
            try {
                rta = (AnotacionCiudadanoTMP) pm.getObjectById(oid, true);
            } catch (JDOObjectNotFoundException e) {
                rta = null;
            } catch (JDOException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                throw new DAOException(e.getMessage(), e);
            }
        }

        return rta;
    }

    /**
     * Obtiene una SalvedadAnotacionTMP dado su identificador, método usado en
     * transacciones se debe dar el PersistenceManager
     *
     * @param oid
     * @param pm
     * @return
     * @throws DAOException
     */
    protected SalvedadAnotacionTMP getSalvedadAnotacionTMP(
            SalvedadAnotacionTMPPk oid, PersistenceManager pm)
            throws DAOException {
        SalvedadAnotacionTMP rta = null;

        if ((oid.idAnotacionTmp != null) && (oid.idSalvedadAnTmp != null)
                && (oid.idMatricula != null)) {
            try {
                rta = (SalvedadAnotacionTMP) pm.getObjectById(oid, true);
            } catch (JDOObjectNotFoundException e) {
                rta = null;
            } catch (JDOException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                throw new DAOException(e.getMessage(), e);
            }
        }

        return rta;
    }

    /**
     * Obtiene un turno de correcciones activo que tenga asociado el folio dado,
     * si no existe un turno de correción activo con el folio asociado retorna
     * null
     *
     * @param oid
     * @return
     * @throws DAOException
     */
    public Turno getTurnoCorreccionActivoFolio(FolioPk oid)
            throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        TurnoEnhanced rta = null;
        String idCorreccion = CProceso.PROCESO_CORRECCIONES;
        Turno aux = null;

        try {
            pm.currentTransaction().setOptimistic(false);
            pm.currentTransaction().begin();

            FolioEnhanced fol = this.getFolioByID(new FolioEnhancedPk(oid), pm);

            if (fol != null) {
                Query query = pm.newQuery(SolicitudFolioEnhanced.class);
                query.declareVariables("TurnoEnhanced turno");
                query.declareParameters("FolioEnhanced fol");
                query.setFilter(
                        "folio==fol && turno.solicitud == solicitud && "
                        + "turno.idCirculo==this.solicitud.circulo && "
                        + "turno.fechaFin==null && solicitud.proceso.idProceso== "
                        + idCorreccion);

                Collection col = (Collection) query.execute(fol);
                Iterator iter = col.iterator();

                if (!iter.hasNext()) {
                    rta = null;
                } else {
                    SolicitudFolioEnhanced solfol = (SolicitudFolioEnhanced) iter.next();
                    rta = this.getTurnoBySolicitud(solfol.getSolicitud(), pm);
                    pm.makeTransient(rta);
                }

                query.closeAll();
            }
        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().commit();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (Exception e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().commit();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().commit();
            }

            pm.close();
        }

        if (rta != null) {
            aux = (Turno) rta.toTransferObject();
        }

        return aux;
    }

    /**
     *
     * @param fol
     * @param pm
     * @return
     * @throws DAOException
     */
    protected List getTurnosCorreccionActivoFolio(FolioEnhanced fol, TurnoEnhanced turnoNoValidar,
            PersistenceManager pm) throws DAOException {
        TurnoEnhanced rta = null;
        String idCorreccion = CProceso.PROCESO_CORRECCIONES;
        Turno aux = null;
        List lista = new ArrayList();
        Collection col;

        try {
            if (fol != null) {
                String filtro = "1==1 ";

                if (turnoNoValidar.getIdProceso() == Long.parseLong(idCorreccion)) {
                    filtro = filtro + "&& this.idWorkflow != idWorkNoVal";
                    filtro = filtro + "&& this.fechaInicio < fechaInicioNoVal";
                }

                filtro = filtro + "&& this.idProceso == 3 "
                        + "&& this.fechaFin == null "
                        + "&& this.idFase != \"COS_ENTREGAR_ASOCIADOS\" "
                        + "&& this.idCirculo == this.solicitud.circulo "
                        + "&& this.solicitud.idSolicitud == solFolio.idSolicitud "
                        + "&& solFolio.idMatricula == idMatricula";

                Query query = pm.newQuery(TurnoEnhanced.class);
                query.declareVariables("SolicitudFolioEnhanced solFolio");

                if (turnoNoValidar.getIdProceso() == Long.parseLong(idCorreccion)) {
                    query.declareParameters("String idMatricula, String idWorkNoVal, Date fechaInicioNoVal");
                } else {
                    query.declareParameters("String idMatricula, String idWorkNoVal");
                }

                query.setFilter(filtro);

                if (turnoNoValidar.getIdProceso() == Long.parseLong(idCorreccion)) {
                    col = (Collection) query.execute(fol.getIdMatricula(), turnoNoValidar.getIdWorkflow(), turnoNoValidar.getFechaInicio());
                } else {
                    col = (Collection) query.execute(fol.getIdMatricula(), turnoNoValidar.getIdWorkflow());
                }

                Iterator iter = col.iterator();

                while (iter.hasNext()) {
                    TurnoEnhanced tauxEnh = (TurnoEnhanced) iter.next();

                    Turno taux = new Turno();
                    taux.setIdTurno(tauxEnh.getIdTurno());
                    taux.setIdProceso(tauxEnh.getIdProceso());
                    taux.setIdCirculo(tauxEnh.getIdCirculo());
                    taux.setAnio(tauxEnh.getAnio());
                    taux.setIdWorkflow(tauxEnh.getIdWorkflow());
                    taux.setIdFase(tauxEnh.getIdFase());

                    lista.add(taux);
                }
            }
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }

        return lista;
    }

    /**
     *
     * @param fol
     * @param pm
     * @return
     * @throws DAOException
     */
    public List getTurnosCorreccionActivosFolio(Folio fol, Turno turnoNoValidar) throws DAOException {

        PersistenceManager pm = AdministradorPM.getPM();
        TurnoEnhanced rta = null;
        String idCorreccion = CProceso.PROCESO_CORRECCIONES;
        Turno aux = null;
        List lista = new ArrayList();

        try {
            pm.currentTransaction().setOptimistic(false);
            pm.currentTransaction().begin();
            if (fol != null) {
                String filtro = "1==1 ";

                if (turnoNoValidar.getIdProceso() == Long.parseLong(idCorreccion)) {
                    filtro = filtro + " && this.idWorkflow != idWorkNoVal";
                }
                filtro = filtro + "&& this.idProceso == 3 "
                        + "&& this.fechaFin == null "
                        + "&& this.idFase != \"COS_ENTREGAR_ASOCIADOS\" "
                        + "&& this.idCirculo == this.solicitud.circulo "
                        + "&& this.solicitud.idSolicitud == solFolio.idSolicitud "
                        + "&& solFolio.idMatricula == idMatricula";

                Query query = pm.newQuery(TurnoEnhanced.class);
                query.declareVariables("SolicitudFolioEnhanced solFolio");
                query.declareParameters("String idMatricula, String idWorkNoVal");
                query.setFilter(filtro);

                Collection col = (Collection) query.execute(fol.getIdMatricula(), turnoNoValidar.getIdWorkflow());

                Iterator iter = col.iterator();

                while (iter.hasNext()) {
                    TurnoEnhanced tauxEnh = (TurnoEnhanced) iter.next();

                    Turno taux = new Turno();
                    taux.setIdTurno(tauxEnh.getIdTurno());
                    taux.setIdProceso(tauxEnh.getIdProceso());
                    taux.setIdCirculo(tauxEnh.getIdCirculo());
                    taux.setAnio(tauxEnh.getAnio());
                    taux.setIdWorkflow(tauxEnh.getIdWorkflow());
                    taux.setIdFase(tauxEnh.getIdFase());

                    lista.add(taux);
                }
            }
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (Exception e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().commit();
            }

            pm.close();
        }

        return lista;
    }

    /**
     * Retorna una lista con los turnos de correciones asociados a una matricula
     * y que esten activos. No valida los turnos anteriores al turno como
     * parametro
     *
     * @param fol
     * @param pm
     * @return
     * @throws DAOException
     */
    protected List getTurnosNoAnterioresCorreccionActivoFolio(FolioEnhanced fol, TurnoEnhanced turnoNoValidar,
            PersistenceManager pm) throws DAOException {
        TurnoEnhanced rta = null;
        String idCorreccion = CProceso.PROCESO_CORRECCIONES;
        Turno aux = null;
        List lista = new ArrayList();

        try {
            if (fol != null) {
                String filtro = "folio==fol ";

                if (turnoNoValidar.getIdProceso() == Long.parseLong(idCorreccion)) {
                    filtro = filtro + " && turno.idWorkflow!=idWorkNoVal";
                }
                filtro = filtro + " && turno.solicitud == solicitud &&\n "
                        + "turno.idCirculo==solicitud.circulo &&\n "
                        + "turno.fechaFin==null && solicitud.proceso.idProceso== " + idCorreccion;

                Query query = pm.newQuery(SolicitudFolioEnhanced.class);
                query.declareVariables("TurnoEnhanced turno");
                query.declareParameters("FolioEnhanced fol, String idWorkNoVal");
                query.setFilter(filtro);

                Collection col = (Collection) query.execute(fol, turnoNoValidar.getIdWorkflow());

                Iterator iter = col.iterator();

                while (iter.hasNext()) {
                    SolicitudFolioEnhanced solfol = (SolicitudFolioEnhanced) iter.next();
                    rta = this.getTurnoBySolicitud(solfol.getSolicitud(), pm);

                    Turno taux = new Turno();
                    taux.setIdTurno(rta.getIdTurno());
                    taux.setIdProceso(rta.getIdProceso());
                    taux.setIdCirculo(rta.getIdCirculo());
                    taux.setAnio(rta.getAnio());
                    taux.setIdWorkflow(rta.getIdWorkflow());
                    taux.setIdFase(rta.getIdFase());

                    //Si esta en entrega no pone problema
                    if (!taux.getIdFase().equals(CFase.COS_ENTREGAR_ASOCIADOS)) {
                        lista.add(taux);
                    }
                }
            }
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }

        return lista;
    }

    /**
     * Retorna el turno asociado a la solicitud, si no existe el turno retorna
     * null
     *
     * @param sol
     * @param pm
     * @return
     * @throws DAOException
     */
    protected TurnoEnhanced getTurnoBySolicitud(SolicitudEnhanced sol,
            PersistenceManager pm) throws DAOException {
        TurnoEnhanced rta = null;

        try {
            Query query = pm.newQuery(TurnoEnhanced.class);

            if (sol != null && sol.getCirculo() != null && sol.getCirculo().getIdCirculo() != null) {
                query.declareParameters("SolicitudEnhanced sol, String circulo");
            } else {
                query.declareParameters("SolicitudEnhanced sol");
            }
            if (sol != null && sol.getCirculo() != null && sol.getCirculo().getIdCirculo() != null) {
                query.setFilter("this.solicitud == sol && this.idCirculo == circulo");
            } else {
                query.setFilter("this.solicitud == sol");
            }

            Collection col = null;
            if (sol != null && sol.getCirculo() != null && sol.getCirculo().getIdCirculo() != null) {
                col = (Collection) query.execute(sol, sol.getCirculo().getIdCirculo());
            } else {
                col = (Collection) query.execute(sol);
            }

            if (col.size() == 0) {
                rta = null;
            } else {
                for (Iterator iter = col.iterator(); iter.hasNext();) {
                    rta = (TurnoEnhanced) iter.next();
                }

                query.closeAll();
            }
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        }

        return rta;
    }

    /**
     * Retorna el turno asociado a la solicitud, si no existe el turno retorna
     * null
     *
     * @param sol
     * @return
     * @throws DAOException
     */
    public Turno getTurnoBySolicitud(SolicitudPk sol)
            throws DAOException {
        TurnoEnhanced rta = null;
        Turno turno = null;
        PersistenceManager pm = AdministradorPM.getPM();

        try {
            pm.currentTransaction().setOptimistic(false);
            pm.currentTransaction().begin();

            SolicitudEnhanced solEnh = null;

            SolicitudEnhancedPk sid = new SolicitudEnhancedPk();
            sid.idSolicitud = sol.idSolicitud;

            try {
                solEnh = (SolicitudEnhanced) pm.getObjectById(sid, true);
            } catch (JDOObjectNotFoundException e) {
                rta = null;
            } catch (JDOException e) {
                if (pm.currentTransaction().isActive()) {
                    pm.currentTransaction().rollback();
                }
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
                throw new DAOException(e.getMessage(), e);
            }

            rta = getTurnoBySolicitud(solEnh, pm);
            pm.makeTransient(rta);
        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        } catch (Exception e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        } finally {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().commit();
            }

            pm.close();
        }

        if (rta != null) {
            turno = (Turno) rta.toTransferObject();
        }

        return turno;
    }

    /**
     * Si el turno va a deshacer los cambios temporales del folio valida si
     * existe otros turnos que tengan fecha de inicio anterior y que no hayan
     * pasado por la fase de firmar que es la fase posterior a calificación y
     * que ya hayan sido calificados. Ademas valida si existen turnos de
     * correciones entre la fase de correccion simple y revisar y aprobar. Si
     * hay algún error en la validación se lanzará una excepción en donde la
     * hastable interna tiene como llave la matricula y como valor la lista de
     * turnos que tienen el folio
     *
     * @param oid
     * @throws DAOException
     */
    public void validarPrincipioPrioridadDeshacerCambiosTemporales(TurnoPk oid)
            throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        TurnoEnhanced turno = null;
        Turno aux = null;
        List arreglo = new ArrayList();
        String mensajeError = "Existen turnos activos: ";

        Hashtable ht = new Hashtable();

        try {
            pm.currentTransaction().setOptimistic(false);
            pm.currentTransaction().begin();

            turno = this.getTurnoByID(new TurnoEnhancedPk(oid), pm);

            if (turno == null) {
                throw new DAOException("No se encontró el turno");
            }

            List folios = turno.getSolicitud().getSolicitudFolios();
            SolicitudFolioEnhanced sf;
            List turnosRegistro;
            List turnosCorreccion;

            List turnosValidados;
            Turno t;

            for (Iterator itr = folios.iterator(); itr.hasNext();) {
                sf = (SolicitudFolioEnhanced) itr.next();

                /**
                 * Saca los turnos de registro y de correciones activos
                 */
                turnosRegistro = this.getTurnosAnterioresAsociadosSinFaseFirmar(sf.getFolio(),
                        turno.getFechaInicio(), pm);

                turnosCorreccion = this.getTurnosNoAnterioresCorreccionActivoFolio(sf.getFolio(), turno, pm);

                /**
                 * Se valida que los turnos de registro asociados a la matricula
                 * no se hayan calificado
                 */
                Turno turnoToVal;
                turnosValidados = new ArrayList();
                for (Iterator turToVal = turnosRegistro.iterator(); turToVal.hasNext();) {
                    turnoToVal = (Turno) turToVal.next();
                    if (this.isTurnoCalificado(turnoToVal.getIdWorkflow())) {
                        turnosValidados.add(turnoToVal);
                    }
                }

                /**
                 * Se valida que los turnos de correcciones activos no tengan
                 * bloqueada la matricula
                 */
                for (Iterator turToVal = turnosCorreccion.iterator(); turToVal.hasNext();) {
                    turnoToVal = (Turno) turToVal.next();
                    TurnoEnhanced turnoEnhanced = TurnoEnhanced.enhance(turnoToVal);
                    if (this.isBloqueadoByTurno(turnoEnhanced, sf.getFolio(), pm)) {
                        turnosValidados.add(turnoToVal);
                    }
                }

                if (turnosValidados.size() > 0) {
                    ht.put(sf.getFolio().getIdMatricula(),
                            (mensajeError + this.getListaTurnos(turnosValidados)));
                }
            }

            if (ht.size() > 0) {
                DAOException exc = new DAOException(
                        "Validación de principio de prioridad");
                exc.setHashErrores(ht);
                throw exc;
            }
        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (DAOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw e;
        } catch (Exception e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().commit();
            }

            pm.close();
        }
    }

    /**
     * Valida el principio de prioridad según Art. 22 Dto 1250/70 Si el turno va
     * a entrar a calificación este servicio se puede utilizar para validar si
     * existe otros turnos que tengan fecha de inicio anterior y que no hayan
     * pasado por la fase de firmar que es la fase posterior a calificación Si
     * hay algún error en la validación se lanzará una excepción en donde la
     * hastable interna tiene como llave la matricula y como valor la lista de
     * turnos que tienen el folio
     *
     * @param oid
     * @throws DAOException
     */
    public void validarPrincipioPrioridadCalificacion(TurnoPk oid, Usuario usuario)
            throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        TurnoEnhanced turno = null;
        Turno aux = null;
        List arreglo = new ArrayList();
        String mensajeError = "Existen turnos activos anteriores que aun no han sido calificados: ";

        Hashtable ht = new Hashtable();

        try {
            pm.currentTransaction().setOptimistic(false);
            pm.currentTransaction().begin();

            turno = this.getTurnoByID(new TurnoEnhancedPk(oid), pm);

            if (turno == null) {
                throw new DAOException("No se encontró el turno");
            }

            UsuarioEnhancedPk uid = new UsuarioEnhancedPk();
            uid.idUsuario = usuario.getIdUsuario();

            UsuarioEnhanced us = this.getUsuarioByID(uid, pm);

            if (us == null) {
                throw new DAOException("El usuario especificado no existe: "
                        + uid.idUsuario);
            }

            List folios = turno.getSolicitud().getSolicitudFolios();
            SolicitudFolioEnhanced sf;
            List turnos;
            List turnosValidados;
            Turno t;

            for (Iterator itr = folios.iterator(); itr.hasNext();) {
                sf = (SolicitudFolioEnhanced) itr.next();
                turnos = this.getTurnosAnterioresAsociadosSinFaseFirmarIDTurno(sf.getFolio(),
                        turno.getIdTurno(), turno.getAnio(), pm);

                //Validamos cada turno: Si el turno está en alguna de las fases de calificación y
                //el calificador es el mismo usuario que ingresa por parámetros, el turno no debería tenerse
                //en cuenta como prioridad
                Turno turnoToVal;
                turnosValidados = new ArrayList();
                for (Iterator turToVal = turnos.iterator(); turToVal.hasNext();) {
                    turnoToVal = (Turno) turToVal.next();

                    /*if(!this.isTurnoActualmenteCalificadoByUsuario(turnoToVal, us, pm)){
						turnosValidados.add(turnoToVal);
					}*/
                    if (!this.isTurnoCalificado(turnoToVal.getIdWorkflow()) && Integer.parseInt(turnoToVal.getIdTurno()) < Integer.parseInt(turno.getIdTurno())) {
                        turnosValidados.add(turnoToVal);
                    }

                }

                if (turnosValidados.size() > 0) {
                    ht.put(sf.getFolio().getIdMatricula(),
                            (mensajeError + this.getListaTurnos(turnosValidados)));
                }
            }

            if (ht.size() > 0) {
                DAOException exc = new DAOException(
                        "Error en la validación de principio de prioridad");
                exc.setHashErrores(ht);
                throw exc;
            }
        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (DAOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw e;
        } catch (Exception e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().commit();
            }

            pm.close();
        }
    }

    /**
     * Valida el principio de prioridad Digitaciono Si el turno va a entrar a
     * Digitación este servicio se puede utilizar para validar si existe otros
     * turnos que tengan fecha de inicio anterior y que esten en esta fase Si
     * hay algún error en la validación se lanzará una excepción en donde la
     * hastable interna tiene como llave la matricula y como valor la lista de
     * turnos que tienen el folio
     *
     * @param oid
     * @throws DAOException
     */
    public void validarPrincipioPrioridadDigitacion(TurnoPk oid, Usuario usuario)
            throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        TurnoEnhanced turno = null;
        Turno aux = null;
        List arreglo = new ArrayList();
        String mensajeError = "Existen turnos activos anteriores que estan en Digitación: ";

        Hashtable ht = new Hashtable();

        try {
            pm.currentTransaction().setOptimistic(false);
            pm.currentTransaction().begin();

            turno = this.getTurnoByID(new TurnoEnhancedPk(oid), pm);

            if (turno == null) {
                throw new DAOException("No se encontró el turno");
            }

            UsuarioEnhancedPk uid = new UsuarioEnhancedPk();
            uid.idUsuario = usuario.getIdUsuario();

            UsuarioEnhanced us = this.getUsuarioByID(uid, pm);

            if (us == null) {
                throw new DAOException("El usuario especificado no existe: "
                        + uid.idUsuario);
            }

            List folios = turno.getSolicitud().getSolicitudFolios();
            SolicitudFolioEnhanced sf;
            List turnos;
            List turnosValidados;
            Turno t;

            for (Iterator itr = folios.iterator(); itr.hasNext();) {
                sf = (SolicitudFolioEnhanced) itr.next();
                turnos = this.getTurnosAnterioresAsociadosSinFaseFirmar(sf.getFolio(),
                        turno.getFechaInicio(), pm);

                //Validamos cada turno: Si el turno está en digitación
                Turno turnoToVal;
                turnosValidados = new ArrayList();
                //TurnoEnhanced turnoVal = null;
                for (Iterator turToVal = turnos.iterator(); turToVal.hasNext();) {
                    turnoToVal = (Turno) turToVal.next();

                    /*Turno.ID turnoID = new Turno.ID();
					turnoID.idCirculo = turnoToVal.getIdCirculo();
					turnoID.idProceso = turnoToVal.getIdProceso();
					turnoID.idTurno = turnoToVal.getIdTurno();
					turnoID.anio = turnoToVal.getAnio();
					
					turnoVal = this.getTurnoByID(new TurnoEnhanced.ID(turnoID), pm);
					//	2. Si el turno no tiene fecha anterior no se tiene en cuenta
           		 	if(turnoVal.getFechaInicio().after(turno.getFechaInicio())){
           		 		continue;
           		 	}*/
                    if (!(turnoToVal.getIdFase().equals(CFase.CAL_DIGITACION))) {
                        continue;
                    }

                    // En caso que hayan pasado todas estas validaciones se concluye que el turno
                    //   es un turno anterior de registro que comparte folios con el que se está validando
                    //   y se encuentra en digitacion.
                    Turno tt = new Turno();
                    tt.setIdWorkflow(turnoToVal.getIdWorkflow());
                    turnosValidados.add(tt);

                }

                if (turnosValidados.size() > 0) {
                    ht.put(sf.getFolio().getIdMatricula(),
                            (mensajeError + this.getListaTurnos(turnosValidados)));
                }
            }

            if (ht.size() > 0) {
                DAOException exc = new DAOException(
                        "Error en la validación de principio de prioridad");
                exc.setHashErrores(ht);
                throw exc;
            }
        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (DAOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw e;
        } catch (Exception e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().commit();
            }

            pm.close();
        }
    }

    /**
     * Valida el principio de prioridad según Art. 22 Dto 1250/70 Si el turno va
     * a entrar a calificación este servicio se puede utilizar para validar si
     * existe otros turnos que tengan fecha de inicio anterior y que no hayan
     * pasado de la fase de calificación Se retorna true si no hay turnos que
     * hayan sido creado previamente o false si los hay.
     *
     * @param oid
     * @param usuario
     * @throws Throwable
     */
    public boolean isTurnoValidoCalificacion(TurnoPk oid, Usuario usuario)
            throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        TurnoEnhanced turno = null;
        Turno aux = null;
        List arreglo = new ArrayList();
        String mensajeError = "Existen turnos activos anteriores que aun no han sido calificados: ";
        boolean rta = true;
        DAOException error = null;

        Hashtable ht = new Hashtable();

        try {
            pm.currentTransaction().setOptimistic(false);
            pm.currentTransaction().begin();

            turno = this.getTurnoByID(new TurnoEnhancedPk(oid), pm);

            if (turno == null) {
                throw new DAOException("No se encontró el turno");
            }

            UsuarioEnhancedPk uid = new UsuarioEnhancedPk();
            uid.idUsuario = usuario.getIdUsuario();

            UsuarioEnhanced us = this.getUsuarioByID(uid, pm);

            if (us == null) {
                throw new DAOException("El usuario especificado no existe: "
                        + uid.idUsuario);
            }

            List folios = turno.getSolicitud().getSolicitudFolios();
            SolicitudFolioEnhanced sf;
            List turnos;
            List turnosValidados;
            Turno t;

            for (Iterator itr = folios.iterator(); itr.hasNext();) {
                sf = (SolicitudFolioEnhanced) itr.next();
                turnos = this.getTurnosAnterioresAsociadosSinFaseFirmar(sf.getFolio(),
                        turno.getFechaInicio(), pm);

                //Validamos cada turno: Si el turno está en alguna de las fases de calificación y
                //el calificador es el mismo usuario que ingresa por parámetros, el turno no debería tenerse
                //en cuenta como prioridad
                Turno turnoToVal;
                turnosValidados = new ArrayList();
                for (Iterator turToVal = turnos.iterator(); turToVal.hasNext();) {
                    turnoToVal = (Turno) turToVal.next();

                    /*if(!this.isTurnoActualmenteCalificadoByUsuario(turnoToVal, us, pm)){
						turnosValidados.add(turnoToVal);
					}*/
 /*if(!this.isTurnoCalificado(turnoToVal.getIdWorkflow())){
						turnosValidados.add(turnoToVal);  este meodo ya estaba el que simplemente voy a cambiar
					}*/
                    if (!this.isTurnoCalificado(turnoToVal.getIdWorkflow())) {
                        turnosValidados.add(turnoToVal);
                    }

                }

                if (turnosValidados.size() > 0) {
                    ht.put(sf.getFolio().getIdMatricula(),
                            (mensajeError + this.getListaTurnos(turnosValidados)));
                }
            }

            if (ht.size() > 0) {
                error = new DAOException("Error en la validación del principio de prioridad de calificación.");
                error.setHashErrores(ht);
                throw error;
            }
            return rta;
        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (DAOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw e;
        } catch (Exception e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().commit();
            }

            pm.close();
        }
    }

    /**
     * Indica si el turno ya fue calificado, para esto verifica si el último
     * turno tiene respuesta inscrito, inscrito parcialmente, devuelto, enviado
     * a Digitación en la fase de calificación.
     *
     * @param fechaTurno
     * @return
     * @throws DAOException
     */
    protected boolean isTurnoCalificado(String idWorkflow)
            throws DAOException {
        Turno aux = null;
        TurnoHistoria calificacion = null;
        boolean rta = false;
        try {
            aux = this.getTurnoByWFId(idWorkflow);
            List historia = aux.getHistorials();

            Iterator it = historia.iterator();
            while (it.hasNext()) {
                TurnoHistoria th = (TurnoHistoria) it.next();
                if (th != null && th.getFase().equals(CFase.CAL_CALIFICACION)) {
                    calificacion = th;
                }

            }

            if (calificacion != null) {
                if (calificacion.getRespuesta() != null) {
                    if (calificacion.getRespuesta().equals(CRespuesta.DEVOLUCION)
                            || calificacion.getRespuesta().equals(CRespuesta.OK)
                            || calificacion.getRespuesta().equals(CRespuesta.INSCRIPCION_PARCIAL)
                            || calificacion.getRespuesta().equals(CRespuesta.DIGITACION)
                            || calificacion.getRespuesta().equals(CRespuesta.PERSONAL)) {
                        rta = true;
                    }
                } else {
                    int lastTurnoHistoria = (int) aux.getLastIdHistoria();
                    TurnoHistoria penultimoth = (TurnoHistoria) aux.getHistorials().get(lastTurnoHistoria - 2);
                    if (penultimoth.getFase().equals(CFase.CAL_DIGITACION)) {
                        rta = true;
                    }
                }

            }

        } catch (Throwable e) {
            throw new DAOException(e.getMessage(), e);
        }

        return rta;
    }

    /**
     * Indica si el turno ya fue calificado, para esto verifica si el último
     * turno tiene respuesta inscrito, inscrito parcialmente, devuelto, enviado
     * a Digitación en la fase de calificación.
     *
     * @param fechaTurno
     * @return
     * @throws DAOException
     */
    protected boolean isTurnoCalificadoConFaseReparto(String idWorkflow)
            throws DAOException {
        Turno aux = null;
        TurnoHistoria calificacion = null;
        boolean rta = false;
        try {
            aux = this.getTurnoByWFId(idWorkflow);
            List historia = aux.getHistorials();

            Iterator it = historia.iterator();
            while (it.hasNext()) {
                TurnoHistoria th = (TurnoHistoria) it.next();
                if (th != null && th.getFase().equals(CFase.CAL_CALIFICACION)) {
                    calificacion = th;
                }

            }

            if (calificacion != null) {
                if (calificacion.getRespuesta() != null) {
                    if (calificacion.getRespuesta().equals(CRespuesta.DEVOLUCION)
                            || calificacion.getRespuesta().equals(CRespuesta.OK)
                            || calificacion.getRespuesta().equals(CRespuesta.INSCRIPCION_PARCIAL)
                            || calificacion.getRespuesta().equals(CRespuesta.DIGITACION)
                            || calificacion.getRespuesta().equals(CRespuesta.PERSONAL)) {
                        rta = true;
                    }
                } else {
                    int lastTurnoHistoria = (int) aux.getLastIdHistoria();
                    TurnoHistoria penultimoth = (TurnoHistoria) aux.getHistorials().get(lastTurnoHistoria - 2);
                    if (penultimoth.getFase().equals(CFase.CAL_DIGITACION) || penultimoth.getFase().equals(CFase.REG_REPARTO)) {
                        rta = true;
                    }
                }

            }

        } catch (Throwable e) {
            throw new DAOException(e.getMessage(), e);
        }

        return rta;
    }

    /**
     * Valida el principio de prioridad para salir de Calificación Si el turno
     * va a entrar a calificación este servicio se puede utilizar para validar
     * si existe otros turnos que tengan fecha de inicio anterior y que no hayan
     * pasado de la fase de calificación Se retorna true si no hay turnos que
     * hayan sido creado previamente o false si los hay.
     *
     * @param oid
     * @param usuario
     * @throws Throwable
     */
    public void isTurnoValidoSalidaCalificacion(TurnoPk oid, Usuario usuario)
            throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        TurnoEnhanced turno = null;
        Turno aux = null;
        List arreglo = new ArrayList();
        String mensajeError = "Existen turnos activos anteriores que aun no han sido calificados: ";
        boolean rta = true;

        Hashtable ht = new Hashtable();

        try {
            pm.currentTransaction().setOptimistic(false);
            pm.currentTransaction().begin();

            turno = this.getTurnoByID(new TurnoEnhancedPk(oid), pm);

            if (turno == null) {
                throw new DAOException("No se encontró el turno");
            }

            UsuarioEnhancedPk uid = new UsuarioEnhancedPk();
            uid.idUsuario = usuario.getIdUsuario();

            UsuarioEnhanced us = this.getUsuarioByID(uid, pm);

            if (us == null) {
                throw new DAOException("El usuario especificado no existe: "
                        + uid.idUsuario);
            }

            List folios = turno.getSolicitud().getSolicitudFolios();
            SolicitudFolioEnhanced sf;
            List turnos;
            List turnosValidados;
            Turno t;

            for (Iterator itr = folios.iterator(); itr.hasNext();) {
                sf = (SolicitudFolioEnhanced) itr.next();
                turnos = this.getTurnosAnterioresAsociadosSinFaseFirmar(sf.getFolio(),
                        turno.getFechaInicio(), pm);

                //Validamos cada turno: Si el turno está en alguna de las fases de calificación y
                //el calificador es el mismo usuario que ingresa por parámetros, el turno no debería tenerse
                //en cuenta como prioridad
                Turno turnoToVal;
                turnosValidados = new ArrayList();
                for (Iterator turToVal = turnos.iterator(); turToVal.hasNext();) {
                    turnoToVal = (Turno) turToVal.next();

                    if (!this.isTurnoCalificadoSalidaCalificacion(turnoToVal.getIdWorkflow())) {
                        turnosValidados.add(turnoToVal);
                    }

                }

                if (turnosValidados.size() > 0) {
                    ht.put(sf.getFolio().getIdMatricula(),
                            (mensajeError + this.getListaTurnos(turnosValidados)));
                }
            }

            if (ht.size() > 0) {
                DAOException exc = new DAOException(
                        "Error en la validación de principio de prioridad");
                exc.setHashErrores(ht);
                throw exc;
            }
        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (DAOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw e;
        } catch (Exception e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().commit();
            }

            pm.close();
        }
    }

    /**
     * Indica si el turno ya fue calificado, para esto verifica si el último
     * turno tiene respuesta inscrito, inscrito parcialmente o devuelto en la
     * fase de calificación.
     *
     * @param fechaTurno
     * @return
     * @throws DAOException
     */
    protected boolean isTurnoCalificadoSalidaCalificacion(String idWorkflow)
            throws DAOException {
        Turno aux = null;
        TurnoHistoria calificacion = null;
        boolean rta = false;
        try {
            aux = this.getTurnoByWFId(idWorkflow);
            List historia = aux.getHistorials();

            Iterator it = historia.iterator();
            while (it.hasNext()) {
                TurnoHistoria th = (TurnoHistoria) it.next();
                if (th != null && th.getFase().equals(CFase.CAL_CALIFICACION)) {
                    calificacion = th;
                }

            }

            if (calificacion != null) {
                if (calificacion.getRespuesta() != null) {
                    if (calificacion.getRespuesta().equals(CRespuesta.DEVOLUCION)
                            || calificacion.getRespuesta().equals(CRespuesta.OK)
                            || calificacion.getRespuesta().equals(CRespuesta.INSCRIPCION_PARCIAL)) {
                        rta = true;
                    }
                }
            }

        } catch (Throwable e) {
            throw new DAOException(e.getMessage(), e);
        }

        return rta;
    }

    /**
     * Valida el principio de prioridad según Incidencia 5063 Si los turnos van
     * a salir de firma y existen otros turnos anteriores (con fechaInicio
     * anterior) que no hayan salido de firma y comparten algún folio se genera
     * una excepcion
     *
     * @param oid
     * @throws DAOException
     */
    public void validarPrincipioPrioridadFirma(List turnos)
            throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        TurnoEnhanced turno = null;
        Turno aux = null;
        List arreglo = new ArrayList();
        String mensajeError = "Existen turnos activos anteriores que comparten folios y no han sido firmados: ";
        boolean notesError = false;

        Hashtable ht = new Hashtable();

        try {
            pm.currentTransaction().begin();

            TurnoPk tid;
            for (Iterator it = turnos.iterator(); it.hasNext();) {
                tid = (TurnoPk) it.next();
                turno = this.getTurnoByID(new TurnoEnhancedPk(tid), pm);

                if (turno == null) {
                    throw new DAOException("No se encontró el turno: " + tid.toString());
                }

                List turnosQueCompartenFolios = this.getTurnosRegistroCompartenFolios(turno, turno.getIdCirculo(), pm);

                //Ahora se revisa si alguno de esos turnos tiene fecha anterior al turno actual
                //y se encuentra entre calificación y firma
                List turnosQueNoHanSidoFirmados = new ArrayList();
                TurnoEnhanced turnoToValidate;
                for (Iterator it2 = turnosQueCompartenFolios.iterator(); it2.hasNext();) {
                    turnoToValidate = (TurnoEnhanced) it2.next();

                    //1. Si el turno ya está finalizado NO se tiene en cuenta
                    if (turnoToValidate.getFechaFin() != null) {
                        continue;
                    }

                    //2. Si el turno no tiene fecha anterior no se tiene en cuenta
                    if (turnoToValidate.getFechaInicio().after(turno.getFechaInicio())) {
                        continue;
                    }
                    
                    HermodService hs = HermodService.getInstance();
                    if(turnoToValidate.getIdFase().equals(CFase.NOT_NOTA_DEVOLUTIVA)
                            || turnoToValidate.getIdFase().equals(CFase.NOT_NOTA_NOTIFICADA)
                            || turnoToValidate.getIdFase().equals(CFase.NOT_RECURSOS_NOTA)){
                     String resp = hs.getStringByQuery(CQueries.getRespFromCalificacion(turno.getIdWorkflow()));
                     if(resp.equals("DEVOLUCION") || resp.equals("INSCRIPCION_PARCIAL")){
                         continue;
                     } else if(resp.equals("OK")){
                        Turno turn = hs.getTurnobyWF(turno.getIdWorkflow());
                        mensajeError = CError.errorAvanzarNotificador(turn); 
                        notesError = true;
                     }
                    }

                    //3. Si el turno NO está entre calificacion y firma no se tiene en cuenta
                    if (!this.isTurnoEntreCalificacionYFirma(turnoToValidate, pm)) {
                        continue;
                    }

                    //4. Finalmente revisamos si el turno está incluido entre la lista ingresada
                    //   de los turnos que están avanzando NO se tiene en cuenta
                    if (this.isTurnoEnLista(turnoToValidate, turnos)) {
                        continue;
                    }

                    //5. En caso que hayan pasado todas estas validaciones se concluye que el turno
                    //   es un turno anterior de registro que comparte folios con el que se está validando
                    //   y se encuentra entre las fases de calificacion y registro.
                    Turno t = new Turno();
                    t.setIdWorkflow(turnoToValidate.getIdWorkflow());
                    turnosQueNoHanSidoFirmados.add(t);
                }

                //Se contruye la entrada en la hashtable en caso de turnos que no han finalizado su firma
                if (!turnosQueNoHanSidoFirmados.isEmpty() && !notesError) {
                    ht.put(tid.toString(),
                            (mensajeError + this.getListaTurnos(turnosQueNoHanSidoFirmados)));
                } else if(notesError){
                    ht.put(tid.toString(),
                            (mensajeError));
                }

            }

            if (ht.size() > 0) {
                DAOException exc = new DAOException(
                        "Error en la validación de principio de prioridad de firma");
                exc.setHashErrores(ht);
                throw exc;
            }

        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (DAOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw e;
        } catch (Exception e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().commit();
            }

            pm.close();
        }
    }

    /**
     * Valida el principio de prioridad Devolucion Si los turnos van a ser
     * devueltos y existen otros turnos posteriores que no hayan salido de firma
     * y comparten algún folio se genera una excepcion
     *
     * @param oid
     * @throws DAOException
     */
    public void validarPrincipioPrioridadDevolucion(List turnos)
            throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        TurnoEnhanced turno = null;
        Turno aux = null;
        List arreglo = new ArrayList();
        String mensajeError = "Existen turnos posteriores que comparten folios que deben devolverse y enviarse a Calificación: ";

        Hashtable ht = new Hashtable();

        try {
            pm.currentTransaction().begin();

            TurnoPk tid;
            for (Iterator it = turnos.iterator(); it.hasNext();) {
                tid = (TurnoPk) it.next();
                turno = this.getTurnoByID(new TurnoEnhancedPk(tid), pm);

                if (turno == null) {
                    throw new DAOException("No se encontró el turno: " + tid.toString());
                }

                List turnosQueCompartenFolios = this.getTurnosRegistroCompartenFolios(turno, turno.getIdCirculo(), pm);

                //Ahora se revisa si alguno de esos turnos tiene fecha anterior al turno actual
                //y se encuentra entre calificación y firma
                List turnosQueNoHanSidoFirmados = new ArrayList();
                TurnoEnhanced turnoToValidate;
                for (Iterator it2 = turnosQueCompartenFolios.iterator(); it2.hasNext();) {
                    turnoToValidate = (TurnoEnhanced) it2.next();

                    //1. Si el turno ya está finalizado NO se tiene en cuenta
                    if (turnoToValidate.getFechaFin() != null) {
                        continue;
                    }

                    //2. Si el turno no tiene fecha posterior no se tiene en cuenta
                    if (!turnoToValidate.getFechaInicio().after(turno.getFechaInicio())) {
                        continue;
                    }

                    //3. Si el turno NO está entre calificacion y firma no se tiene en cuenta
                    if (!this.isTurnoEntreCalificacionYFirma(turnoToValidate, pm)) {
                        continue;
                    }

                    //4. Se el turno este en calificacion no se tiene en cuenta
                    if (turnoToValidate.getIdFase().equals(CFase.CAL_CALIFICACION)) {
                        continue;
                    }

                    makeTransientTurnoConTurnoHistoria(turnoToValidate, pm);
//            		 Se valida que la ultima respuesta de calificacion sea DEVOLUCION O MAYOR VALOR
                    List listaHistorials = turnoToValidate.getHistorials();
                    String respuesta = "";
                    List historialesOrdenados = new ArrayList();
                    historialesOrdenados.addAll(listaHistorials);

                    if (historialesOrdenados != null) {

                        try {
                            Collections.sort(historialesOrdenados, new IdTurnoHistoriaEnhancedComparator());
                        } catch (Exception e) {
                            Log.getInstance().debug(JDOGenieFolioDAO.class, "No se pudieron ordenar el historial del Turno");
                        }

                        int size = historialesOrdenados.size();

                        //Obtener el último turno historia que pasó por la fase de calificación. 
                        //Esto funciona porque se garantiza que el listado de turno historia está organizado por fecha
                        TurnoHistoriaEnhanced ultimoTurnoHistoria = null;
                        for (int i = 0; i < size; i++) {
                            TurnoHistoriaEnhanced turnoHistoria = (TurnoHistoriaEnhanced) historialesOrdenados.get(i);
                            if (turnoHistoria.getFase().equals(CFase.CAL_CALIFICACION)) {
                                ultimoTurnoHistoria = turnoHistoria;
                                respuesta = ultimoTurnoHistoria.getRespuesta();
                            }
                        }
                    }

                    //Validar las respuesta
                    if (respuesta.equals(CRespuesta.DEVOLUCION) || respuesta.equals(CRespuesta.MAYOR_VALOR)) {
                        continue;
                    }

                    //validar que no tenga informacion temporal
                    //5. En caso que hayan pasado todas estas validaciones se concluye que el turno
                    //   es un turno posteriro de registro que comparte folios con el que se está validando
                    //   y se encuentra entre las fases de calificacion y registro.
                    Turno t = new Turno();
                    t.setIdWorkflow(turnoToValidate.getIdWorkflow());
                    turnosQueNoHanSidoFirmados.add(t);
                }

                //Se contruye la entrada en la hashtable en caso de turnos que no han finalizado su firma
                if (!turnosQueNoHanSidoFirmados.isEmpty()) {
                    ht.put(tid.toString(),
                            (mensajeError + this.getListaTurnos(turnosQueNoHanSidoFirmados)));
                }

            }

            if (ht.size() > 0) {
                if (pm.currentTransaction().isActive()) {
                    pm.currentTransaction().rollback();
                }
                DAOException exc = new DAOException(
                        "Error en la validación de principio de prioridad de Devolucion");
                exc.setHashErrores(ht);
                throw exc;
            }

        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (DAOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw e;
        } catch (Exception e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().commit();
            }

            pm.close();
        }
    }

    /**
     * Valida el principio de prioridad Si los turnos van a salir de firma y
     * existen otros turnos anteriores (con fechaInicio anterior) que no hayan
     * salido de firma y comparten algún folio los agrega a una lista
     *
     * @param oid
     * @throws DAOException
     */
    public Hashtable validarPrincipioPrioridadFirmaRelacion(List turnos)
            throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        TurnoEnhanced turno = null;
        Turno aux = null;
        List arreglo = new ArrayList();
        String mensajeError = "Existen turnos activos anteriores que comparten folios y no han sido firmados: ";
        boolean notesError = false;
        Hashtable ht = new Hashtable();

        try {
            pm.currentTransaction().begin();

            TurnoPk tid;
            for (Iterator it = turnos.iterator(); it.hasNext();) {
                tid = (TurnoPk) it.next();
                turno = this.getTurnoByID(new TurnoEnhancedPk(tid), pm);

                if (turno == null) {
                    throw new DAOException("No se encontró el turno: " + tid.toString());
                }

                List turnosQueCompartenFolios = this.getTurnosRegistroCompartenFolios(turno, turno.getIdCirculo(), pm);

                //Ahora se revisa si alguno de esos turnos tiene fecha anterior al turno actual
                //y se encuentra entre calificación y firma
                List turnosQueNoHanSidoFirmados = new ArrayList();
                TurnoEnhanced turnoToValidate;
                for (Iterator it2 = turnosQueCompartenFolios.iterator(); it2.hasNext();) {
                    turnoToValidate = (TurnoEnhanced) it2.next();

                    //1. Si el turno ya está finalizado NO se tiene en cuenta
                    if (turnoToValidate.getFechaFin() != null) {
                        continue;
                    }

                    //2. Si el turno no tiene fecha anterior no se tiene en cuenta
                    if (turnoToValidate.getFechaInicio().after(turno.getFechaInicio())) {
                        continue;
                    }
                    
                    if(turnoToValidate.getIdFase().equals(CFase.NOT_NOTA_DEVOLUTIVA)
                            || turnoToValidate.getIdFase().equals(CFase.NOT_NOTA_NOTIFICADA)
                            || turnoToValidate.getIdFase().equals(CFase.NOT_RECURSOS_NOTA)){
                                                  HermodService hs = HermodService.getInstance();
                     String resp = hs.getStringByQuery(CQueries.getRespFromCalificacion(turno.getIdWorkflow()));
                     if(resp.equals("DEVOLUCION") || resp.equals("INSCRIPCION_PARCIAL")){
                         continue;
                     } else if(resp.equals("OK")){
                        Turno turn = hs.getTurnobyWF(turno.getIdWorkflow());
                        mensajeError = CError.errorAvanzarNotificador(turn); 
                     }
                    }

                    //3. Si el turno NO está entre calificacion y firma no se tiene en cuenta
                    if (!this.isTurnoEntreCalificacionYFirma(turnoToValidate, pm)) {
                        continue;
                    }

                    //4. Finalmente revisamos si el turno está incluido entre la lista ingresada
                    //   de los turnos que están avanzando NO se tiene en cuenta
                    if (this.isTurnoEnLista(turnoToValidate, turnos)) {
                        continue;
                    }

                    //5. En caso que hayan pasado todas estas validaciones se concluye que el turno
                    //   es un turno anterior de registro que comparte folios con el que se está validando
                    //   y se encuentra entre las fases de calificacion y registro.
                    Turno t = new Turno();
                    t.setIdWorkflow(turnoToValidate.getIdWorkflow());
                    turnosQueNoHanSidoFirmados.add(t);
                    //turnosSinFirmar.add(turno);
                }

                //Se contruye la entrada en la hashtable en caso de turnos que no han finalizado su firma
                if (!turnosQueNoHanSidoFirmados.isEmpty() && !notesError) {
                    ht.put(tid.toString(),
                            (mensajeError + this.getListaTurnos(turnosQueNoHanSidoFirmados)));
                } else if(notesError){
                    ht.put(tid.toString(),
                            (mensajeError));
                }

            }

        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (DAOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw e;
        } catch (Exception e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().commit();
            }

            pm.close();
        }

        return ht;
    }

    /**
     * Valida que el turno sea el primero entre turnos que comparten las mismas
     * matricula Si los turnos se van a tomar en firma y existen otros turnos
     * anteriores (con fechaInicio anterior) que no hayan salido de firma y
     * comparten algún folio se genera false
     *
     * @param oid
     * @throws DAOException
     */
    public boolean validarTurnoFirmaPrincipioPrioridad(List turnos)
            throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        TurnoEnhanced turno = null;
        Turno aux = null;
        List arreglo = new ArrayList();
        String mensajeError = "Existen turnos activos anteriores que comparten folios y no han sido firmados: ";
        boolean notesError = false;
        boolean rta = true;

        Hashtable ht = new Hashtable();

        try {
            pm.currentTransaction().begin();

            TurnoPk tid;
            for (Iterator it = turnos.iterator(); it.hasNext();) {
                tid = (TurnoPk) it.next();
                turno = this.getTurnoByID(new TurnoEnhancedPk(tid), pm);

                if (turno == null) {
                    throw new DAOException("No se encontró el turno: " + tid.toString());
                }

                List turnosQueCompartenFolios = this.getTurnosRegistroCompartenFolios(turno, turno.getIdCirculo(), pm);

                //Ahora se revisa si alguno de esos turnos tiene fecha anterior al turno actual
                //y se encuentra entre calificación y firma
                List turnosQueNoHanSidoFirmados = new ArrayList();
                TurnoEnhanced turnoToValidate;
                for (Iterator it2 = turnosQueCompartenFolios.iterator(); it2.hasNext();) {
                    turnoToValidate = (TurnoEnhanced) it2.next();

                    //1. Si el turno ya está finalizado NO se tiene en cuenta
                    if (turnoToValidate.getFechaFin() != null) {
                        continue;
                    }

                    //2. Si el turno no tiene fecha anterior no se tiene en cuenta
                    if (turnoToValidate.getFechaInicio().after(turno.getFechaInicio())) {
                        continue;
                    }

                    //3. Si el turno NO está entre calificacion y firma no se tiene en cuenta
                    if (!this.isTurnoEntreCalificacionYFirma(turnoToValidate, pm)) {
                        continue;
                    }

                    if(turnoToValidate.getIdFase().equals(CFase.NOT_NOTA_DEVOLUTIVA)
                            || turnoToValidate.getIdFase().equals(CFase.NOT_NOTA_NOTIFICADA)
                            || turnoToValidate.getIdFase().equals(CFase.NOT_RECURSOS_NOTA)){
                      
                     HermodService hs = HermodService.getInstance();
                     String resp = hs.getStringByQuery(CQueries.getRespFromCalificacion(turno.getIdWorkflow()));
                     if(resp.equals("DEVOLUCION") || resp.equals("INSCRIPCION_PARCIAL")){
                         continue;
                     } else if(resp.equals("OK")){
                        Turno turn = hs.getTurnobyWF(turno.getIdWorkflow());
                        mensajeError = CError.errorAvanzarNotificador(turn); 
                     } 
                    }

                    //4. Finalmente revisamos si el turno está incluido entre la lista ingresada
                    //   de los turnos que están avanzando NO se tiene en cuenta
                    if (this.isTurnoEnLista(turnoToValidate, turnos)) {
                        continue;
                    }

                    //5. En caso que hayan pasado todas estas validaciones se concluye que el turno
                    //   es un turno anterior de registro que comparte folios con el que se está validando
                    //   y se encuentra entre las fases de calificacion y registro.
                    Turno t = new Turno();
                    t.setIdWorkflow(turnoToValidate.getIdWorkflow());
                    turnosQueNoHanSidoFirmados.add(t);
                }

                //Se contruye la entrada en la hashtable en caso de turnos que no han finalizado su firma
                if (!turnosQueNoHanSidoFirmados.isEmpty() && !notesError) {
                    ht.put(tid.toString(),
                            (mensajeError + this.getListaTurnos(turnosQueNoHanSidoFirmados)));
                }  else if(notesError){
                    ht.put(tid.toString(),
                            (mensajeError));
                }

            }

            if (ht.size() > 0) {
                rta = false;
            }

        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (DAOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw e;
        } catch (Exception e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().commit();
            }

            pm.close();
        }
        return rta;
    }

    /**
     * Indica si el turno se encuentra entre la lista de turnos
     *
     * @param turnoToValidate
     * @param turnos
     * @return
     */
    private boolean isTurnoEnLista(TurnoEnhanced turnoToValidate, List turnos) {
        boolean rta = false;
        TurnoPk tid;
        for (Iterator it = turnos.iterator(); it.hasNext() && !rta;) {
            tid = (TurnoPk) it.next();
            if (turnoToValidate.getIdWorkflow().equals(tid.toString())) {
                rta = true;
            }
        }
        return rta;
    }

    /**
     * Valida si el turno se encuentra en una fase entre calificación y firma de
     * registrador y que lo esté o haya calificado el usuario que entra por
     * parámetros
     *
     * @param turnoToVal
     * @param us
     * @param pm
     * @return
     */
    private boolean isTurnoActualmenteCalificadoByUsuario(Turno turnoToVal, UsuarioEnhanced us, PersistenceManager pm) {
        boolean rta = false;
        String idWorkflowTur = turnoToVal.getIdWorkflow();
        Long idUsuarioVal = new Long(us.getIdUsuario());
        String idFaseCal = CFase.CAL_CALIFICACION;
        String idFaseFirma = CFase.REG_FIRMAR;
        String idCirculo = turnoToVal.getIdCirculo();

        Query query = pm.newQuery(TurnoHistoriaEnhanced.class);
        Collection col = null;

        if (idCirculo == null) {

            query.declareVariables("TurnoHistoriaEnhanced th");
            query.setOrdering("fecha ascending");
            query.declareParameters("String idWorkflowTur, long idUsuarioVal, String idFaseCal, String idFaseFirma");
            query.setFilter("this.turno.idWorkflow == idWorkflowTur &&\n"
                    + "this.fase==idFaseCal &&\n"
                    + "this.usuarioAtiende.idUsuario==idUsuarioVal &&\n"
                    + "( (this.turno.idFase==idFaseFirma) ||\n"
                    + "!(this.turno.historial.contains(th) && th.fase==idFaseFirma) )");
            col = (Collection) query.executeWithArray(new Object[]{idWorkflowTur, idUsuarioVal, idFaseCal, idFaseFirma});

        } else {

            query.declareVariables("TurnoHistoriaEnhanced th");
            query.setOrdering("fecha ascending");
            query.declareParameters("String idWorkflowTur, long idUsuarioVal, String idFaseCal, String idFaseFirma, String idCir");
            query.setFilter("this.turno.idWorkflow == idWorkflowTur &&\n"
                    + "this.turno.idCirculo==idCir &&\n"
                    + "this.fase==idFaseCal &&\n"
                    + "this.usuarioAtiende.idUsuario==idUsuarioVal &&\n"
                    + "( (this.turno.idFase==idFaseFirma) ||\n"
                    + "!(this.turno.historial.contains(th) && th.fase==idFaseFirma) )");
            col = (Collection) query.executeWithArray(new Object[]{idWorkflowTur, idUsuarioVal, idFaseCal, idFaseFirma, idCirculo});

        }

        Iterator iter = col.iterator();
        if (iter.hasNext()) {
            rta = true;
        }
        return rta;
    }

    /**
     * Retorna los turnos de registro de fecha anterior a fechaTurno, que tengan
     * asociado el mismo folio y que no ha pasado por la fase de firmas
     *
     * @param oid
     * @param fechaTurno
     * @return
     * @throws DAOException
     */
    protected List getTurnosAnterioresAsociadosSinFaseFirmar(
            FolioEnhanced fol, Date fechaTurno, PersistenceManager pm)
            throws DAOException {
        TurnoEnhanced rta = null;
        Turno aux = null;
        List arreglo = new ArrayList();
        try {
            if (fol != null) {
                Integer idRegistro = new Integer(CProceso.PROCESO_REGISTRO);
                String idFaseFirmar = CFase.REG_FIRMAR;
                String idAnulado = CTurno.TURNO_ANULADO;

                Query query = pm.newQuery(SolicitudFolioEnhanced.class);
                query.declareVariables(
                        "TurnoEnhanced turno; TurnoHistoriaEnhanced th");
                query.declareParameters(
                        "FolioEnhanced fol, int idRegistro, String idFaseFirmar, String idAnulado, Date fechaTurno");
                query.setFilter("this.folio==fol &&\n"
                        + "turno.solicitud==this.solicitud &&\n"
                        + "turno.idCirculo==this.solicitud.circulo &&\n"
                        + "turno.fechaFin==null && \n"
                        + "turno.anulado!=idAnulado &&\n"
                        + "turno.fechaInicio<fechaTurno &&\n"
                        + "turno.idFase!=idFaseFirmar &&\n"
                        + "solicitud.proceso.idProceso==idRegistro &&\n"
                        + "(!(turno.historial.contains(th) &&\n"
                        + "th.fase==idFaseFirmar))");

                Collection col = (Collection) query.executeWithArray(new Object[]{
                    fol, idRegistro, idFaseFirmar, idAnulado, fechaTurno});

                Iterator iter = col.iterator();

                while (iter.hasNext()) {
                    SolicitudFolioEnhanced solfol = (SolicitudFolioEnhanced) iter.next();
                    rta = this.getTurnoBySolicitud(solfol.getSolicitud(), pm);

                    pm.makeTransient(rta);

                    Turno taux = new Turno();
                    taux.setIdTurno(rta.getIdTurno());
                    taux.setIdProceso(rta.getIdProceso());
                    taux.setIdCirculo(rta.getIdCirculo());
                    taux.setAnio(rta.getAnio());
                    taux.setIdWorkflow(rta.getIdWorkflow());
                    taux.setIdFase(rta.getIdFase());
                    arreglo.add(taux);
                }

                query.closeAll();
            }
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }

        return arreglo;
    }

    /**
     * Retorna los turnos de registro de turno anterior a turnoID, que tengan
     * asociado el mismo folio y que no ha pasado por la fase de firmas
     *
     * @param oid
     * @param fechaTurno
     * @return
     * @throws DAOException
     */
    protected List getTurnosAnterioresAsociadosSinFaseFirmarIDTurno(
            FolioEnhanced fol, String turnoID, String annio, PersistenceManager pm)
            throws DAOException {
        TurnoEnhanced rta = null;
        Turno aux = null;
        List arreglo = new ArrayList();
        try {
            if (fol != null) {
                Integer idRegistro = new Integer(CProceso.PROCESO_REGISTRO);
                String idFaseFirmar = CFase.REG_FIRMAR;
                String idAnulado = CTurno.TURNO_ANULADO;

                Query query = pm.newQuery(SolicitudFolioEnhanced.class);
                query.declareVariables(
                        "TurnoEnhanced turno; TurnoHistoriaEnhanced th");
                query.declareParameters(
                        "FolioEnhanced fol, int idRegistro, String idFaseFirmar, String idAnulado,  String turnoID, String annio");
                query.setFilter("this.folio==fol &&\n"
                        + "turno.solicitud==this.solicitud &&\n"
                        + "turno.idCirculo==this.solicitud.circulo &&\n"
                        + "turno.fechaFin==null && \n"
                        + "turno.anulado!=idAnulado &&\n"
                        + "turno.idTurno<turnoID &&\n"
                        + "turno.anio<=annio &&\n"
                        + "turno.idFase!=idFaseFirmar &&\n"
                        + "solicitud.proceso.idProceso==idRegistro &&\n"
                        + "(!(turno.historial.contains(th) &&\n"
                        + "th.fase==idFaseFirmar))");

                Collection col = (Collection) query.executeWithArray(new Object[]{
                    fol, idRegistro, idFaseFirmar, idAnulado, turnoID, annio
                });

                Iterator iter = col.iterator();

                while (iter.hasNext()) {
                    SolicitudFolioEnhanced solfol = (SolicitudFolioEnhanced) iter.next();
                    rta = this.getTurnoBySolicitud(solfol.getSolicitud(), pm);

                    pm.makeTransient(rta);

                    Turno taux = new Turno();
                    taux.setIdTurno(rta.getIdTurno());
                    taux.setIdProceso(rta.getIdProceso());
                    taux.setIdCirculo(rta.getIdCirculo());
                    taux.setAnio(rta.getAnio());
                    taux.setIdWorkflow(rta.getIdWorkflow());
                    taux.setIdFase(rta.getIdFase());
                    arreglo.add(taux);
                }

                query.closeAll();
            }
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }

        return arreglo;
    }

    /**
     * Retorna los turnos de registro que comparten folios con el folio dado
     *
     * @param fechaTurno
     * @return
     * @throws DAOException
     */
    protected List getTurnosRegistroCompartenFolios(TurnoEnhanced turno, String idCirculo, PersistenceManager pm)
            throws DAOException {
        TurnoEnhanced rta = null;
        Turno aux = null;
        List col = null;
        try {
            String idWork = turno.getIdWorkflow();
            Integer idProcesoRegistro = new Integer(CProceso.PROCESO_REGISTRO);

            Query query = pm.newQuery(TurnoEnhanced.class);
            query.declareVariables("SolicitudFolioEnhanced solFol; TurnoEnhanced turno; SolicitudFolioEnhanced solFol2");
            query.declareParameters("String idWork, Integer idProcesoRegistro, String idCirculo");
            query.setFilter(" this.idCirculo==idCirculo &&\n"
                    + "this.solicitud.solicitudFolios.contains(solFol) &&\n"
                    + "turno.idWorkflow == idWork &&\n"
                    + "turno.anulado == \"" + CTurno.CAMPO_ANULADO_DEFECTO + "\" &&\n"
                    + "turno.idCirculo==idCirculo &&\n"
                    + "turno.solicitud.solicitudFolios.contains(solFol2) &&\n"
                    + "solFol.idMatricula == solFol2.idMatricula &&\n"
                    + "solFol.idSolicitud != solFol2.idSolicitud &&\n"
                    + "solFol.solicitud.proceso.idProceso == idProcesoRegistro");
            col = (List) query.execute(idWork, idProcesoRegistro, idCirculo);
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }

        return col;
    }

    /**
     * Indica si el turno se encuentra en una fase entre calificación y firma
     * (Incluyendo estas fases)
     *
     * @param fechaTurno
     * @return
     * @throws DAOException
     */
    protected boolean isTurnoEntreCalificacionYFirma(TurnoEnhanced turno, PersistenceManager pm)
            throws DAOException {
        Turno aux = null;
        boolean rta = false;
        try {
            String idFaseCal = CFase.CAL_CALIFICACION;
            String idFaseCer = CFase.REG_CERTIFICADOS_ASOCIADOS;
            String idFaseEnt = CFase.REG_ENTREGA;
            String idWork = turno.getIdWorkflow();
            String idCirculo = turno.getIdCirculo();
            Collection col = null;
            Query query = pm.newQuery(TurnoEnhanced.class);

            if (idCirculo == null) {

                query.declareVariables("TurnoHistoriaEnhanced thCal; TurnoHistoriaEnhanced thCer; TurnoHistoriaEnhanced thEnt");
                query.declareParameters("String idFaseCal, String idFaseCer, String idFaseEnt, String idWork");
                query.setFilter("this.idWorkflow == idWork &&\n"
                        + "(this.historial.contains(thCal) && thCal.fase==idFaseCal) &&\n"
                        + "!((this.historial.contains(thCer) && thCer.fase==idFaseCer) || "
                        + "(this.historial.contains(thEnt) && thEnt.fase==idFaseEnt))");

                col = (Collection) query.executeWithArray(new Object[]{idFaseCal, idFaseCer, idFaseEnt, idWork});

            } else {

                query.declareVariables("TurnoHistoriaEnhanced thCal; TurnoHistoriaEnhanced thCer; TurnoHistoriaEnhanced thEnt");
                query.declareParameters("String idFaseCal, String idFaseCer, String idFaseEnt, String idWork, String idCir");
                query.setFilter("this.idWorkflow == idWork &&\n "
                        + "this.idCirculo == idCir &&\n "
                        + "(this.historial.contains(thCal) && thCal.fase==idFaseCal) &&\n"
                        + "!((this.historial.contains(thCer) && thCer.fase==idFaseCer) || "
                        + "(this.historial.contains(thEnt) && thEnt.fase==idFaseEnt))");

                col = (Collection) query.executeWithArray(new Object[]{idFaseCal, idFaseCer, idFaseEnt, idWork, idCirculo});

            }

            Iterator iter = col.iterator();
            if (iter.hasNext()) {
                rta = true;
            }
            query.closeAll();
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }

        if (!rta) {
            rta = this.isTurnoEntreCalificacionYFirmaRestituido(turno.getIdWorkflow());
        }

        return rta;
    }

    /**
     * Indica si el turno se encuentra en una fase entre calificación y firma
     * (Incluyendo estas fases) teniendo en cuenta turnos que fueron
     * restituidos.
     *
     * @param fechaTurno
     * @return
     * @throws DAOException
     */
    protected boolean isTurnoEntreCalificacionYFirmaRestituido(String idWorkflow)
            throws DAOException {
        Turno aux = null;
        TurnoHistoria calificacion = null;
        TurnoHistoria certificadosAsociados = null;
        TurnoHistoria entrega = null;
        boolean rta = false;
        try {
            aux = this.getTurnoByWFId(idWorkflow);
            List historia = aux.getHistorials();

            Iterator it = historia.iterator();
            while (it.hasNext()) {
                TurnoHistoria th = (TurnoHistoria) it.next();
                if (th != null && th.getFase().equals(CFase.CAL_CALIFICACION)) {
                    calificacion = th;
                }
                if (th != null && th.getFase().equals(CFase.REG_CERTIFICADOS_ASOCIADOS)) {
                    certificadosAsociados = th;
                }
                if (th != null && th.getFase().equals(CFase.REG_ENTREGA)) {
                    entrega = th;
                }

            }

            if (calificacion == null) {
                rta = false;
            } else {
                if (calificacion != null && (certificadosAsociados == null && entrega == null)) {
                    rta = true;
                } else {
                    if (calificacion != null && certificadosAsociados != null) {
                        if (calificacion.getFecha().before(certificadosAsociados.getFecha())) {
                            rta = false;
                        } else {
                            rta = true;
                        }
                    } else {
                        if (calificacion != null && entrega != null) {
                            if (calificacion.getFecha().before(entrega.getFecha())) {
                                rta = false;
                            } else {
                                rta = true;
                            }
                        }
                    }
                }
            }

        } catch (Throwable e) {
            throw new DAOException(e.getMessage(), e);
        }

        return rta;
    }

    /**
     * Obtiene un turno dado el identificador de su instancia en workflow,
     *
     * @param wfId Documento de pago con sus atributos numero de cheque y numero
     * de cuenta
     * @return Turno con todos sus atributos.
     * @throws DAOException
     */
    protected Turno getTurnoByWFId(String wfId) throws DAOException {
        TurnoEnhanced tr = null;
        Turno rta = null;
        TurnoEnhancedPk turnoId = new TurnoEnhancedPk(wfId);
        PersistenceManager pm = AdministradorPM.getPM();

        try {
            pm.currentTransaction().begin();
            tr = this.getTurnoByID(turnoId, pm);

            if (tr == null) {
                throw new DAOException("El turno " + wfId + " no existe.");
            }

            this.makeTransientTurnoConTurnoHistoria(tr, pm);

            pm.currentTransaction().commit();
        } catch (DAOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            throw e;
        } catch (Throwable e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }
        if (tr != null) {
            rta = (Turno) tr.toTransferObject();
        }
        return rta;
    }

    /**
     *
     * @param turno
     * @param pm
     * @throws DAOException
     */
    protected void makeTransientTurnoConTurnoHistoria(TurnoEnhanced tr, PersistenceManager pm)
            throws DAOException {
        if (tr != null) {
            try {

                List his = tr.getHistorials();
                Iterator it = his.iterator();

                //Hacer transiente el historial del turno.
                while (it.hasNext()) {
                    TurnoHistoriaEnhanced th = (TurnoHistoriaEnhanced) it.next();

                    //Hacer transiente los recursos asociados al turno historia:
                    RecursoEnhanced recurso;
                    for (Iterator it2 = th.getRecursos().iterator(); it2.hasNext();) {
                        recurso = (RecursoEnhanced) it2.next();
                        pm.makeTransient(recurso.getTipoRecurso());
                        if (recurso.getOficioRespuesta() != null) {
                            pm.makeTransient(recurso.getOficioRespuesta().getTurnoHistoria());
                            pm.makeTransient(recurso.getOficioRespuesta());
                        }

                        pm.makeTransient(recurso);
                    }
                    pm.makeTransient(th.getUsuario());
                    pm.makeTransient(th.getUsuarioAtiende());
                    pm.makeTransient(th.getProceso());
                    pm.makeTransient(th);
                    //th.setNombreFase((fasesDAO.getFaseById(th.getFase())).getNombre());
                }

                pm.makeTransient(tr);
            } catch (JDOException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                throw new DAOException(e.getMessage(), e);
            }
        }
    }

    /**
     * Valida el principio de prioridad para un turno. Se valida que para cada
     * matrícula relacionada no exista un turno de corrección activo con la
     * misma matrícula asociada. Si algún folio asociado al turno presenta esta
     * situación, se lanza una excepción con la hashtable donde la llave es la
     * matrícula y el valor es la lista de turnos de calificación que tienen el
     * folio
     *
     * @param oid
     * @throws DAOException
     */
    public void validarPrincipioPrioridadCorreccion(TurnoPk oid)
            throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        TurnoEnhanced turno = null;
//        Turno aux = null;
        //      List arreglo = new ArrayList();
        String mensajeError = "Existen turnos de corrección activos: ";

        Hashtable ht = new Hashtable();

        try {
            pm.currentTransaction().setOptimistic(false);
            pm.currentTransaction().begin();

            turno = this.getTurnoByID(new TurnoEnhancedPk(oid), pm);

            if (turno == null) {
                throw new DAOException("No se encontró el turno");
            }

            List folios = turno.getSolicitud().getSolicitudFolios();
            SolicitudFolioEnhanced sf;
            List turnos;

            Date horaIni = new Date();

            for (Iterator itr = folios.iterator(); itr.hasNext();) {
                sf = (SolicitudFolioEnhanced) itr.next();
                turnos = this.getTurnosCorreccionActivoFolio(sf.getFolio(), turno, pm);

                if (turnos.size() > 0) {
                    ht.put(sf.getFolio().getIdMatricula(),
                            (mensajeError + (this.getListaTurnos(turnos))));
                }
            }
            Date horaFin = new Date();
            long tiempoTotal = horaFin.getTime() - horaIni.getTime();

            if (tiempoTotal > 100) {
                Log.getInstance().debug(JDOGenieFolioDAO.class, "JDOGenieFolioDAO.validarPrincipioPrioridadCorreccion - FOR - Iterator itr = folios.iterator()");
                Log.getInstance().debug(JDOGenieFolioDAO.class, "Tiempo ciclo completo turno: " + (turno != null ? turno.getIdWorkflow() : "") + " - " + tiempoTotal + " Milisegundos - Cantidad folios a verificar" + (folios != null ? "" + folios.size() : ""));
            }

            if (ht.size() > 0) {
                DAOException exc = new DAOException(
                        "Error en la validación de principio de prioridad de corrección");
                exc.setHashErrores(ht);
                throw exc;
            }
        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (DAOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw e;
        } catch (Exception e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().commit();
            }

            pm.close();
        }
    }

    /**
     *
     * @param turnos
     * @return
     */
    protected String getListaTurnos(List turnos) {

        String mensajeError = new String();
        Turno t;
        Iterator it = turnos.iterator();

        if (it.hasNext()) {
            t = (Turno) it.next();
            mensajeError = mensajeError + t.getIdWorkflow();
        }

        while (it.hasNext()) {
            t = (Turno) it.next();
            mensajeError = mensajeError + ", " + t.getIdWorkflow();
        }

        return mensajeError;
    }

    /**
     *
     * @param folio
     * @param toUpdate
     * @param datos
     * @param pm
     * @return
     * @throws DAOException
     */
    protected boolean actualizarAnotacionDefinitivaEnTMP(FolioEnhanced folio,
            AnotacionTMP toUpdate, AnotacionTMP datos, UsuarioEnhanced usuario,
            boolean reordenar, TurnoEnhanced turno, PersistenceManager pm) throws DAOException {
        boolean rta = false;
        JDOGenieCiudadanoDAO ciudDAO = new JDOGenieCiudadanoDAO();

        try {
            //La anotación temporal se debe actualizar con los datos de la anotación "datos"
            //La anotación NO se puede eliminar, se cambia su estado a ANULADA

            if (datos.isToDelete()) {
                //Se deben eliminar los cambios temporales que estén afectando a esta anotación definitiva
                boolean soloEliminarContraparteTemporal;
                soloEliminarContraparteTemporal = true;
                this.actualizarAnotacionTMP(folio, toUpdate, datos, usuario, soloEliminarContraparteTemporal, turno, pm);
            } else {

                // --------------------------------------------------------------
                if (datos.getComentario() != null) {
                    toUpdate.setComentario(datos.getComentario());
                }

                if (datos.getFechaRadicacion() != null) {
                    toUpdate.setFechaRadicacion(datos.getFechaRadicacion());
                }

                if (datos.getNumRadicacion() != null) {
                    toUpdate.setNumRadicacion(datos.getNumRadicacion());
                }

                if (datos.getEspecificacion() != null) {
                    toUpdate.setEspecificacion(datos.getEspecificacion());
                }
                
                if (datos.getModalidad() != null){
                    toUpdate.setModalidad(datos.getModalidad());
                }

                //Se busca si se debe actualizar el documento
                if (datos.getDocumento() != null) {
                    if (turno != null) {
                        datos.getDocumento().setCirculo(turno.getIdCirculo());
                    }
                    this.updateAnotacionDocumento(toUpdate, datos, pm);
                }

                if (datos.getOrden() != null) {
                    if (reordenar) {
                        //Se actualiza en caso que sea diferente al orden actual
                        if (!datos.getOrden().equals(toUpdate.getOrden())) {
                            //1. Se valida el orden insertado
                            long nuevoOrden = this.validarYObtenerOrden(folio,
                                    datos.getOrden(), pm);

                            //2. Obtenemos el número con ceros a la izquierda con el fin de compararlo
                            String nuevoOrdenLPAD = this.getLPAD(datos.getOrden());

                            //El orden solo cambia la forma en que está escrito
                            //el número, pero NO afecta el ordenamiento
                            if (!nuevoOrdenLPAD.equals(toUpdate.getOrdenLPAD())) {
                                //El cambio de orden SI afecta el ordenamiento
                                String ordenAnterior = toUpdate.getOrdenLPAD();

                                if (nuevoOrdenLPAD.compareTo(ordenAnterior) > 0) {
                                    //El nuevoOrden es mayor que el anterior
                                    //Si es mayor, se tienen que actualizar las anotaciones
                                    //temporales que le siguen
                                    this.actualizarOrdenAnotaciones(folio,
                                            ordenAnterior, nuevoOrdenLPAD, -1, false,
                                            usuario, turno, pm);
                                } else {
                                    //El nuevoOrden es menor que el anterior
                                    //Si es menor, se tienen que actualizar las anotaciones
                                    //temporales y definitivas que la preceden
                                    this.actualizarOrdenAnotaciones(folio,
                                            nuevoOrdenLPAD, ordenAnterior, 1, true,
                                            usuario, turno, pm);
                                }
                            }
                        }
                    }

                    toUpdate.setOrden(datos.getOrden());
                }

                if (datos.isToUpdateValor()) {
                    toUpdate.setValor(datos.getValor());
                }

                /**
                 * Si hubo cambio en la naturaleza juridica la actualiza
                 */
                if (datos.getNaturalezaJuridica() != null) {
                    NaturalezaJuridicaEnhancedPk njId = new NaturalezaJuridicaEnhancedPk();
                    njId.idNaturalezaJuridica = datos.getNaturalezaJuridica()
                            .getIdNaturalezaJuridica();
                    /*
                    *  @author Carlos Torres
                    *  @chage   se asigna valor a la propiedad version
                    *  @mantis 12705: Acta - Requerimiento No 056_453_Modificiación_de_Naturaleza_Jurídica
                     */
                    njId.version = datos.getNaturalezaJuridica().getVersion();
                    NaturalezaJuridicaEnhanced naturaleza = this.getNaturalezaJuridica(njId,
                            pm);

                    if (naturaleza == null) {
                        throw new DAOException(
                                "No encontró la naturaleza jurídica de la anotación con el ID: "
                                + njId.idNaturalezaJuridica);
                    }
                    /*
                    *  @author Carlos Torres
                    *  @chage   se agrega condicion de version
                    *  @mantis 12705: Acta - Requerimiento No 056_453_Modificiación_de_Naturaleza_Jurídica
                     */
                    if (!datos.getNaturalezaJuridica().getIdNaturalezaJuridica()
                            .equals(toUpdate.getNaturalezaJuridica()
                                    .getIdNaturalezaJuridica())
                            || datos.getNaturalezaJuridica().getVersion() != toUpdate.getNaturalezaJuridica().getVersion()) {
                        toUpdate.setNaturalezaJuridica(naturaleza);

                        //SE ACTUALIZA LA ESPECIFICACIÓN SI ES DIFERENTE DE NULL
                        this.revisarYActualizarEspecificacion(toUpdate, pm);

                        //Se valida que no exista una anotación temporal ya insertada
                        //con la misma naturaleza jurídica y con el mismo documento
                        //SE QUITA ESTA VALIDACION POR SOLICITUD DE LA SNR
                        /*
                       if (!this.validarNaturalezaJuridicaAnotacion(folio,
                                   toUpdate, pm)) {
                           throw new DAOException(
                               "No puede inscribir 2 veces una anotación con la misma naturaleza jurídica y el mismo documento");
                       }*/
                    }
                }

                if (datos.getEstado() != null) {
                    EstadoAnotacionEnhancedPk eId = new EstadoAnotacionEnhancedPk();
                    eId.idEstadoAn = datos.getEstado().getIdEstadoAn();

                    EstadoAnotacionEnhanced estado = this.getEstadoAnotacion(eId, pm);

                    if (estado == null) {
                        throw new DAOException(
                                "No encontró el estado de la anotación con el ID: "
                                + eId.idEstadoAn);
                    }

                    toUpdate.setEstado(estado);
                }

                //TODO pendiente si se actualizan datos relacionados al documento
                //y la radicacion
                /**
                 * Cuando se actualiza solamente el campo participacion o
                 * propietario se debe dejar solo un registro del ciudadano en
                 * el vector
                 */
                ArrayList ciudadanosAux = new ArrayList(datos.getAnotacionesCiudadanoTMPs());
                Collections.sort(ciudadanosAux, new IsToDeleteAnotacionCiudadanoTMPComparator());
                ArrayList ciudadanosAuxTemp = new ArrayList(datos.getAnotacionesCiudadanoTMPs());
                ArrayList ciudadanos = new ArrayList();

                /*ArrayList ciudadanosAuxDef=new ArrayList();*/
                for (Iterator i = ciudadanosAux.iterator(); i.hasNext();) {
                    boolean eliminar = false;
                    AnotacionCiudadanoTMP ciudadano = (AnotacionCiudadanoTMP) i.next();
                    //ciudadanosAux.remove(ciudadano);
                    if ((ciudadano.getCiudadano().getIdCiudadano() != null)
                            && (ciudadano.getRolPersona() != null)) {
                        String idCiudadano = ciudadano.getIdCiudadano();
                        String rolPersona = ciudadano.getRolPersona();
                        ciudadanosAuxTemp.remove(ciudadano);
                        for (Iterator i2 = ciudadanosAuxTemp.iterator(); i2.hasNext();) {
                            AnotacionCiudadanoTMP ciudadano2 = (AnotacionCiudadanoTMP) i2.next();
                            // Se busca al ciudadano
                            CiudadanoEnhanced ciudadanoEnh = ciudadano2.getCiudadano();
                            CiudadanoEnhanced ciudaE = ciudDAO.getCiudadanoByDocumento(ciudadanoEnh.getTipoDoc(),
                                    ciudadanoEnh.getDocumento(), false, pm, ciudadanoEnh.getIdCirculo());
                            if (ciudaE != null) {
                                String idCiudadano2 = ciudaE.getIdCiudadano();
                                String rolPersona2 = ciudadano2.getRolPersona();
                                if ((idCiudadano.equals(idCiudadano2)) && (rolPersona2.equals(rolPersona))) {
                                    eliminar = true;
                                    break;
                                }
                            } else {
                                break;
                            }
                        }
                        if (!eliminar) {
                            ciudadanos.add(ciudadano);
                            eliminar = false;
                        }
                    } else {
                        ciudadanos.add(ciudadano);
                    }
                }
                Collections.sort(ciudadanos, new IsToDeleteAnotacionCiudadanoTMPComparator());
//             Revisamos si se deben actualizar los ciudadanos

                AnotacionCiudadanoTMP ciud;

                for (Iterator itr = ciudadanos.iterator(); itr.hasNext();) {
                    ciud = (AnotacionCiudadanoTMP) itr.next();

                    //Validamos que la anotacion ciudadano tenga el objeto
                    //ciudadano
                    if (ciud.getCiudadano() == null) {
                        throw new DAOException(
                                "La anotación ciudadano debe tener el objeto ciudadano");
                    }

                    //Para cada anotacionCiudadano revisamos si se tiene que
                    //agregar o se tiene que actualizar y si ya está en temporal
                    if ((ciud.getCiudadano().getIdCiudadano() != null)
                            && (ciud.getRolPersona() != null)) {
                        //Se debe actualizar la anotación ciudadano
                        AnotacionCiudadanoTMPPk acid = new AnotacionCiudadanoTMPPk();
                        acid.idAnotacionTmp = toUpdate.getIdAnotacionTmp();
                        acid.idCiudadano = ciud.getIdCiudadano();
                        acid.idMatricula = toUpdate.getIdMatricula();
                        acid.rolPersona = ciud.getRolPersona();

                        AnotacionCiudadanoTMP acTMP = this.getAnotacionCiudadanoTMP(acid,
                                pm);

                        if (acTMP != null) {
                            //La anotación ciudadano ya se encuentra en temporal
                            if (ciud.isToDelete()) {
                                //Si la anotación en temporal ya está seteada para eliminarse se lanza
                                //una excepcion
                                if (acTMP.isToDelete()) {
                                    throw new DAOException(
                                            "El ciudadano que está intentando eliminar no existe");
                                }

                                //La anotación ciudadano se debe eliminar si no tiene
                                //correspondencia en definitivo se borra
                                AnotacionCiudadanoEnhancedPk acAux = new AnotacionCiudadanoEnhancedPk();
                                acAux.idAnotacion = toUpdate.getIdAnotacionTmp();
                                acAux.idCiudadano = ciud.getIdCiudadano();
                                acAux.idMatricula = toUpdate.getIdMatricula();
                                acAux.rolPersona = ciud.getRolPersona();

                                AnotacionCiudadanoEnhanced ace = this.getAnotacionCiudadano(acAux,
                                        pm);

                                if (ace != null) {
                                    //Si se tiene una anotacionCiudadano correspondiente en
                                    //definitivo se setea para que se elimine cuando se haga
                                    //definitivo
                                    acTMP.setToDelete(true);
                                } else {
                                    //Se elimina la anotacionCiudadano TMP porque no tiene
                                    //correspondencia en las definitivas
                                    toUpdate.removeAnotacionesCiudadanoTMP(acTMP);
                                    pm.deletePersistent(acTMP);
                                }
                            } else {
                                acTMP.setToDelete(false);
                                if (ciud.isToUpdate()) {
                                    acTMP.setMarcaPropietario(ciud.getMarcaPropietario());
                                    acTMP.setParticipacion(ciud.getParticipacion());
                                }
                            }
                        } else {
                            //Se busca en definitivo
                            AnotacionCiudadanoEnhancedPk acAux = new AnotacionCiudadanoEnhancedPk();
                            acAux.idAnotacion = toUpdate.getIdAnotacionTmp();
                            acAux.idCiudadano = ciud.getIdCiudadano();
                            acAux.idMatricula = toUpdate.getIdMatricula();
                            acAux.rolPersona = ciud.getRolPersona();

                            AnotacionCiudadanoEnhanced ace = this.getAnotacionCiudadano(acAux,
                                    pm);

                            if (ace == null) {
                                throw new DAOException(
                                        "No se encontró la anotación ciudadano que se quiere actualizar");
                            }

                            AnotacionCiudadanoTMP newAnotaCiudTMP = new AnotacionCiudadanoTMP(ace);

                            if (ciud.isToDelete()) {
                                //Se crea la anotacionCiudadano:
                                this.addAnotacionCiudadanoToAnotacionTMP(toUpdate,
                                        newAnotaCiudTMP, turno, pm);
                                pm.makePersistent(newAnotaCiudTMP);
                                newAnotaCiudTMP.setToDelete(true);

                                //Notificación a Lista de ciudadanos (cache)
                                toUpdate.addAnotacionesCiudadanoTMP(newAnotaCiudTMP);
                            } else if (ciud.isToUpdate()) {
                                //Se crea la anotacionCiudadano:
                                this.addAnotacionCiudadanoToAnotacionTMP(toUpdate,
                                        newAnotaCiudTMP, turno, pm);
                                newAnotaCiudTMP.setMarcaPropietario(ciud.getMarcaPropietario());
                                newAnotaCiudTMP.setParticipacion(ciud.getParticipacion());
                                pm.makePersistent(newAnotaCiudTMP);

                                //Notificación a Lista de ciudadanos (cache)
                                toUpdate.addAnotacionesCiudadanoTMP(newAnotaCiudTMP);
                            }
                        }
                    } else {
                        boolean insertar = true;

                        //Verificamos si la anotacionCiudadano que se quiere insertar
                        //ya existe entre las anotaciones temporales como eliminada:
                        CiudadanoEnhanced ciudadano = ciud.getCiudadano();
                        CiudadanoEnhanced cd;

                        if (ciudadano == null) {
                            throw new DAOException(
                                    "La AnotacionCiudadano no tiene ciudadano");
                        }

                        //Se busca al ciudadano
                        cd = ciudDAO.getCiudadanoByDocumento(ciudadano.getTipoDoc(),
                                ciudadano.getDocumento(), false, pm, ciudadano.getIdCirculo());

                        if (cd != null) {
                            //Si encuentra al ciudadano se busca la anotación ciudadano
                            //en la misma anotación con el mismo rol
                            AnotacionCiudadanoTMPPk acid = new AnotacionCiudadanoTMPPk();
                            acid.idAnotacionTmp = toUpdate.getIdAnotacionTmp();
                            acid.idCiudadano = cd.getIdCiudadano();
                            acid.idMatricula = toUpdate.getIdMatricula();
                            acid.rolPersona = ciud.getRolPersona();

                            AnotacionCiudadanoTMP acTMP = this.getAnotacionCiudadanoTMP(acid,
                                    pm);

                            if (acTMP != null) {
                                //Si la encuentra es que ya existe un registro temporal
                                //de ciudadano. Si está configurado para inserción se actualiza
                                //el registro en la base de datos, si está configurado
                                //para eliminación se borra
                                insertar = false;

                                if (acTMP.isToDelete()) {
                                    toUpdate.removeAnotacionesCiudadanoTMP(acTMP);
                                    pm.deletePersistent(acTMP);
                                } else {
                                    //Se debe eliminar la anotacion antigua
                                    pm.deletePersistent(acTMP);
                                    VersantPersistenceManager pm2 = (VersantPersistenceManager) pm;
                                    pm2.flush();
                                    //Se inserta la nueva
                                    this.addAnotacionCiudadanoToAnotacionTMP(toUpdate,
                                            ciud, turno, pm);
                                    pm.makePersistent(ciud);
//                                 Notificación a la lista:
                                    toUpdate.addAnotacionesCiudadanoTMP(ciud);

                                }
                            }
                        } else {
                            insertar = true;
                        }

                        if (insertar) {
                            //Validamos que el ciudadano que se está insertando NO exista
                            //entre los ciudadanos definitivos con el mismo rol
                            //Se busca en definitivo
                            AnotacionCiudadanoEnhancedPk acAux = new AnotacionCiudadanoEnhancedPk();
                            acAux.idAnotacion = toUpdate.getIdAnotacionTmp();
                            acAux.idCiudadano = ciud.getIdCiudadano();; //cd.getIdCiudadano();
                            acAux.idMatricula = toUpdate.getIdMatricula();
                            acAux.rolPersona = ciud.getRolPersona();

                            AnotacionCiudadanoEnhanced ace = this.getAnotacionCiudadano(acAux,
                                    pm);

                            if (ace != null) {
                                throw new DAOException(
                                        "El ciudadano que está intentando insertar ya existe en la anotación con el mismo rol");
                            }

                            //Se debe insertar normalmente
                            this.addAnotacionCiudadanoToAnotacionTMP(toUpdate,
                                    ciud, turno, pm);
                            pm.makePersistent(ciud);

                            //Notificación a la lista:
                            toUpdate.addAnotacionesCiudadanoTMP(ciud);
                        }
                    }

                    //Ejecutamos el borrado
                    VersantPersistenceManager pm2 = (VersantPersistenceManager) pm;
                    pm2.flush();
                }

                //Revisamos si se deben actualizar o insertar salvedades de anotación
                List salvedades = datos.getSalvedadesTMPs();
                SalvedadAnotacionTMP sal;

                for (Iterator itr = salvedades.iterator(); itr.hasNext();) {
                    sal = (SalvedadAnotacionTMP) itr.next();

                    //Para cada SalvedadAnotacion revisamos si se tiene que
                    //agregar o se tiene que actualizar
                    if (sal.getIdSalvedadAnTmp() != null) {
                        //La salvedad se tiene que actualizar o borrar
                        SalvedadAnotacionTMPPk sid = new SalvedadAnotacionTMPPk();
                        sid.idSalvedadAnTmp = sal.getIdSalvedadAnTmp();
                        sid.idAnotacionTmp = toUpdate.getIdAnotacionTmp();
                        sid.idMatricula = toUpdate.getIdMatricula();

                        SalvedadAnotacionTMP salAux = this.getSalvedadAnotacionTMP(sid,
                                pm);

                        if (salAux != null) {
                            //La salvedad se encuentra en temporal
                            if (sal.isToDelete()) {
                                if (salAux.isToDelete()) {
                                    throw new DAOException(
                                            "No se encontró la salvedad que se quiere eliminar");
                                }

                                //La salvedad se debe eliminar, si no tiene correspondencia
                                //en definitivo se borra
                                SalvedadAnotacionEnhancedPk saId = new SalvedadAnotacionEnhancedPk();
                                saId.idSalvedad = sal.getIdSalvedadAnTmp();
                                saId.idAnotacion = toUpdate.getIdAnotacionTmp();
                                saId.idMatricula = toUpdate.getIdMatricula();

                                SalvedadAnotacionEnhanced sa = this.getSalvedadAnotacion(saId,
                                        pm);

                                if (sa != null) {
                                    //Si se tiene una salvedad correspondiente en
                                    //definitivo se setea para que se elimine cuando se haga
                                    //definitivo
                                    salAux.setToDelete(true);
                                } else {
                                    //Se elimina la salvedad porque no tiene correspondencia
                                    //en las salvedades definitivas
                                    toUpdate.removeSalvedadesTMP(salAux);
                                    pm.deletePersistent(salAux);
                                }
                            } else {
                                if (salAux.isToDelete()) {
                                    throw new DAOException(
                                            "No se encontró la salvedad que se quiere actualizar");
                                }

                                //La salvedad se debe actualizar
                                if (sal.getDescripcion() != null) {
                                    salAux.setDescripcion(sal.getDescripcion());
                                }

                                salAux.setToDelete(false);
                            }
                        } else {
                            //Se busca la salvedad en definitivo
                            SalvedadAnotacionEnhancedPk saId = new SalvedadAnotacionEnhancedPk();
                            saId.idSalvedad = sal.getIdSalvedadAnTmp();
                            saId.idAnotacion = toUpdate.getIdAnotacionTmp();
                            saId.idMatricula = toUpdate.getIdMatricula();

                            SalvedadAnotacionEnhanced sa = this.getSalvedadAnotacion(saId,
                                    pm);

                            if (sa == null) {
                                throw new DAOException(
                                        "No se encontró la salvedad de la anotación que se quiere actualizar");
                            }

                            SalvedadAnotacionTMP newSalTMP = new SalvedadAnotacionTMP(sa);

                            //Se crea la salvedad:
                            this.addSalvedadToAnotacionTMP(toUpdate, newSalTMP,
                                    usuario, pm);
                            pm.makePersistent(newSalTMP);
                            toUpdate.addSalvedadesTMP(newSalTMP);

                            if (sal.isToDelete()) {
                                newSalTMP.setToDelete(true);
                            } else {
                                if (sal.getDescripcion() != null) {
                                    newSalTMP.setDescripcion(sal.getDescripcion());
                                }
                            }
                        }
                    } else {
                        this.addSalvedadToAnotacionTMP(toUpdate, sal, usuario, pm);
                        sal.setToDelete(false);
                        pm.makePersistent(sal);

                        toUpdate.addSalvedadesTMP(sal);
                    }
                }

                //SE REVISAN LAS CANCELACIONES:
                //Revisamos si se deben insertar o eliminar cancelaciones
                List cancelaciones = datos.getAnotacionesCancelacionTMPs();
                CancelacionTMP can;

                for (Iterator itr = cancelaciones.iterator(); itr.hasNext();) {
                    can = (CancelacionTMP) itr.next();

                    //Para cada Cancelacion revisamos si se tiene que
                    //agregar o se tiene que eliminar
                    if (can.isToDelete()) {
                        //La cancelacion se debe eliminar
                        //Se comprueba si existe actualmente la cancelación
                        //temporal, ya sea marcada para eliminar o para agregar
                        CancelacionTMP toDel = this.getCancelacionTMP(can,
                                toUpdate, pm);

                        if (toDel != null) {
                            //Existe una cancelación en temporal
                            if (toDel.isToDelete()) {
                                throw new DAOException("La cancelación que desea eliminar no existe.");
                            } else {
                                pm.deletePersistent(toDel);
                            }
                        } else {
                            //No existe una cancelación en temporal
                            //se revisa si existe la cancelación en definitivo
                            //para marcarla para eliminar
                            CancelacionEnhanced cancelDefToDel = this.getCancelacion(can, toUpdate, pm);
                            if (cancelDefToDel == null) {
                                throw new DAOException("La cancelación que desea eliminar no existe");
                            } else {
                                //Se tiene que marcar la cancelación para eliminarse
                                CancelacionTMP cancelTMPMarcada = new CancelacionTMP(cancelDefToDel);
                                cancelTMPMarcada.setIdCancelacionTmp(String.valueOf(toUpdate.getLastIdCancelacion()
                                        + 1));
                                toUpdate.setLastIdCancelacion(toUpdate.getLastIdCancelacion() + 1);
                                cancelTMPMarcada.setCanceladora(toUpdate);
                                cancelTMPMarcada.setToDelete(true);
                                cancelTMPMarcada.setAnotacionTemporal(false);
                                pm.makePersistent(cancelTMPMarcada);
                            }
                        }

                    } else {
                        //Se revisa si ya existe un registro que esté eliminando a la cancelación:
                        CancelacionTMP canAux = this.getCancelacionTMP(can,
                                toUpdate, pm);
                        if (canAux != null) {
                            if (canAux.isToDelete()) {
                                pm.deletePersistent(canAux);
                            } else {
                                throw new DAOException("Ya está cancelando la misma anotación");
                            }
                        } else {
                            this.addCancelacionToAnotacionTMP(toUpdate, can,
                                    usuario, pm);
                            pm.makePersistent(can);
                            toUpdate.addAnotacionesCancelacionTMP(can);
                        }

                    }
                }
                // --------------------------------------------------------------

            } // if

        } catch (DAOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw e;
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }

        return rta;
    }

    /**
     * @param toUpdate
     * @param pm
     */
    private void revisarYActualizarEspecificacion(AnotacionTMP toUpdate, PersistenceManager pm) throws DAOException {

        //Se recupera la anotación
        AnotacionEnhancedPk defID = new AnotacionEnhancedPk();
        defID.idMatricula = toUpdate.getIdMatricula();
        defID.idAnotacion = toUpdate.getIdAnotacionTmp();

        AnotacionEnhanced an = this.getAnotacionByID(defID, pm);

        if (an == null) {
            throw new DAOException("No existe la anotación definitiva correspondiente");
        }

        toUpdate.setEspecificacion(toUpdate.getNaturalezaJuridica().getNombre());

    }

    /**
     * Retorna la lista con los folios hijos del folio especificado (Folio) Si
     * el folio no tiene hijos o no existe retorna una lista vacía
     *
     * @param oid
     * @return
     * @throws DAOException
     */
    public List getFoliosHijos(FolioPk oid) throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        FolioDerivadoEnhanced fd;
        List rta = new ArrayList();
        Folio aux = new Folio();

        try {
            String matriculaPadre = oid.idMatricula;

            Query query = pm.newQuery(FolioDerivadoEnhanced.class);
            query.setOrdering("this.hijo.folio.ordenLPAD ascending");
            query.declareParameters("String matriculaPadre");
            query.setFilter("this.idMatricula== matriculaPadre");

            Collection col = (Collection) query.execute(matriculaPadre);

            for (Iterator iter = col.iterator(); iter.hasNext();) {
                fd = (FolioDerivadoEnhanced) iter.next();
                aux = new Folio();
                aux.setIdMatricula(fd.getIdMatricula1());
                aux.setDefinitivo(true);
                rta.add(aux);
            }

            query.closeAll();
        } catch (JDOObjectNotFoundException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        return rta;
    }

    /**
     * Retorna la lista con los folios hijos del folio especificado (Folio) Si
     * el folio no tiene hijos o no existe retorna una lista vacía
     *
     * @param oid
     * @return
     * @throws DAOException
     */
    public List getFoliosHijosOrdenAnotacion(FolioPk oid) throws DAOException {
        String idMatricula = oid.idMatricula;
        List rta = null;
        try {
            rta = this.getFoliosHijosImplementacionOrdenAnotacion(idMatricula);
        } catch (JDOObjectNotFoundException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }
        return rta;
    }

    /**
     * Retorna la lista con los los folios padre del folio especificado (Folio)
     * Si el folio no tiene padres o no existe retorna una lista vacía
     *
     * @param oid
     * @return
     * @throws DAOException
     */
    public List getFoliosPadre(FolioPk oid) throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        FolioDerivadoEnhanced fd;
        List rta = new ArrayList();
        Folio aux = new Folio();

        try {
            String matriculaHija = oid.idMatricula;

            Query query = pm.newQuery(FolioDerivadoEnhanced.class);
            query.setOrdering("this.padre.folio.ordenLPAD ascending");
            query.declareParameters("String matriculaHija");
            query.setFilter("this.idMatricula1==matriculaHija");

            Collection col = (Collection) query.execute(matriculaHija);

            for (Iterator iter = col.iterator(); iter.hasNext();) {
                fd = (FolioDerivadoEnhanced) iter.next();
                aux = new Folio();
                aux.setIdMatricula(fd.getIdMatricula());
                aux.setDefinitivo(true);
                rta.add(aux);
            }

            query.closeAll();
        } catch (JDOObjectNotFoundException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        return rta;
    }

    /**
     * Retorna la lista de los Folios Derivados Hijos de un folio especificado
     * (Folio) Si el folio no tiene hijos o no existe retorna una lista vacía
     *
     * @param oid
     * @return
     * @throws DAOException
     */
    public List<FolioDerivado> getFoliosDerivadoHijos(FolioPk oid) throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        FolioDerivadoEnhanced fd;
        List<FolioDerivado> rta = new ArrayList();
        FolioDerivado folDerivado = new FolioDerivado();

        try {
            String matriculaPadre = oid.idMatricula;

            Query query = pm.newQuery(FolioDerivadoEnhanced.class);
            query.setOrdering("this.hijo.folio.ordenLPAD ascending");
            query.declareParameters("String matriculaPadre");
            query.setFilter("this.idMatricula== matriculaPadre");

            Collection col = (Collection) query.execute(matriculaPadre);

            for (Iterator iter = col.iterator(); iter.hasNext();) {
                fd = (FolioDerivadoEnhanced) iter.next();
                folDerivado = new FolioDerivado();
                folDerivado.setIdAnotacion(fd.getIdAnotacion());
                folDerivado.setIdMatricula(fd.getIdMatricula());
                folDerivado.setIdAnotacion1(fd.getIdAnotacion1());
                folDerivado.setIdMatricula1(fd.getIdMatricula1());
                folDerivado.setArea(fd.getArea());
                folDerivado.setHectareas(fd.getHectareas());
                folDerivado.setMetros(fd.getMetros());
                folDerivado.setCentimetros(fd.getCentimetros());
                folDerivado.setLote(fd.getLote());
                folDerivado.setPorcentaje(fd.getPorcentaje());
                rta.add(folDerivado);
            }
            query.closeAll();
        } catch (JDOObjectNotFoundException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        return rta;
    }

    /**
     * Obtiene los folios derivadosTMP de la matricula padre con la ultima
     * anotacion generadora del folio padre
     *
     * @param matriculaPadre
     * @return List
     * @throws DAOException
     */
    private List getFoliosDerivadosTMP(String matriculaPadre,
            PersistenceManager pm) throws DAOException {
        FolioDerivadoTMP fd;
        List rta = new ArrayList();

        try {
            FolioEnhanced folioEnhanced = new FolioEnhanced();

            FolioEnhancedPk folioID = new FolioEnhancedPk();
            folioID.idMatricula = matriculaPadre;

            folioEnhanced = this.getFolioByID(folioID, pm);

            String idAnotacionPadre = String.valueOf(this.getNextOrdenAnotacion(
                    folioEnhanced, pm) - 1);

            Query query = pm.newQuery(FolioDerivadoTMP.class);
            query.setOrdering("this.hijoTmp.folio.ordenLPAD ascending");
            query.declareParameters("String matriculaPadre, String idAnotacionPadre");
            query.setFilter("this.idMatricula == matriculaPadre && this.idAnotacionTmp == idAnotacionPadre");

            Collection col = (Collection) query.execute(matriculaPadre, idAnotacionPadre);

            for (Iterator iter = col.iterator(); iter.hasNext();) {
                fd = (FolioDerivadoTMP) iter.next();
                rta.add(fd);
            }
            query.closeAll();
        } catch (JDOObjectNotFoundException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }

        return rta;
    }

    /**
     * Retorna la lista con los los folios Derivados padre del folio
     * especificado (Folio) Si el folio no tiene padres o no existe retorna una
     * lista vacía
     *
     * @param oid
     * @return
     * @throws DAOException
     */
    public List getFoliosDerivadoPadre(FolioPk oid) throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        FolioDerivadoEnhanced fd;
        List rta = new ArrayList();
        FolioDerivado folDerivado = new FolioDerivado();

        try {
            String matriculaHija = oid.idMatricula;

            Query query = pm.newQuery(FolioDerivadoEnhanced.class);
            query.setOrdering("this.padre.folio.ordenLPAD ascending");
            query.declareParameters("String matriculaHija");
            query.setFilter("this.idMatricula1==matriculaHija");

            Collection col = (Collection) query.execute(matriculaHija);

            for (Iterator iter = col.iterator(); iter.hasNext();) {
                fd = (FolioDerivadoEnhanced) iter.next();
                folDerivado = new FolioDerivado();
                folDerivado.setIdAnotacion(fd.getIdAnotacion());
                folDerivado.setIdMatricula(fd.getIdMatricula());
                folDerivado.setIdAnotacion1(fd.getIdAnotacion1());
                folDerivado.setIdMatricula1(fd.getIdMatricula1());
                rta.add(folDerivado);
            }

            query.closeAll();
        } catch (JDOObjectNotFoundException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        return rta;
    }

    /**
     * Retorna la lista de los Folios Derivados Hijos de un folio especificado
     * (Folio) Si el folio no tiene hijos o no existe retorna una lista vacía
     *
     * @param oid
     * @return
     * @throws DAOException
     */
    public List getFoliosDerivadoHijos(FolioPk oid, Usuario usuario) throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        FolioDerivadoEnhanced fd;
        FolioDerivadoTMP fdTMP;
        List rta = new ArrayList();
        FolioDerivado folDerivado = new FolioDerivado();
        FolioEnhanced datos;

        try {

            datos = this.getFolioByID(new FolioEnhancedPk(oid), pm);

//        	validamos el bloqueo del folio
            if (usuario != null) {
                this.validarBloqueoFolio(datos, usuario, pm);
            }

            String matriculaPadre = oid.idMatricula;

            Query query = pm.newQuery(FolioDerivadoEnhanced.class);
            query.setOrdering("this.hijo.folio.ordenLPAD ascending");
            query.declareParameters("String matriculaPadre");
            query.setFilter("this.idMatricula== matriculaPadre");

            Collection col = (Collection) query.execute(matriculaPadre);

            for (Iterator iter = col.iterator(); iter.hasNext();) {
                fd = (FolioDerivadoEnhanced) iter.next();
                folDerivado = new FolioDerivado();
                folDerivado.setIdAnotacion(fd.getIdAnotacion());
                folDerivado.setIdMatricula(fd.getIdMatricula());
                folDerivado.setIdAnotacion1(fd.getIdAnotacion1());
                folDerivado.setIdMatricula1(fd.getIdMatricula1());
                rta.add(folDerivado);
            }

            //  Se obtienen los temporales
            query = pm.newQuery(FolioDerivadoTMP.class);
            query.setOrdering("this.hijoTmp.folio.ordenLPAD ascending");
            query.declareParameters("String matriculaPadre");
            query.setFilter("this.idMatricula== matriculaPadre");

            col = (Collection) query.execute(matriculaPadre);

            for (Iterator iter = col.iterator(); iter.hasNext();) {
                fdTMP = (FolioDerivadoTMP) iter.next();
                folDerivado = new FolioDerivado();
                folDerivado.setIdAnotacion(fdTMP.getIdAnotacionTmp());
                folDerivado.setIdMatricula(fdTMP.getIdMatricula());
                folDerivado.setIdAnotacion1(fdTMP.getIdAnotacion1Tmp());
                folDerivado.setIdMatricula1(fdTMP.getIdMatricula1());

                if (fdTMP.isToDelete()) {
                    rta.remove(folDerivado);
                } else {
                    rta.add(folDerivado);
                }
            }

            query.closeAll();
        } catch (JDOObjectNotFoundException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        return rta;
    }

    /**
     * Retorna la lista con los los folios Derivados padre del folio
     * especificado (Folio) Si el folio no tiene padres o no existe retorna una
     * lista vacía
     *
     * @param oid
     * @return
     * @throws DAOException
     */
    public List getFoliosDerivadoPadre(FolioPk oid, Usuario usuario) throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        FolioDerivadoEnhanced fd;
        FolioDerivadoTMP fdTMP;
        List rta = new ArrayList();
        FolioDerivado folDerivado = new FolioDerivado();
        FolioEnhanced datos;

        try {

            datos = this.getFolioByID(new FolioEnhancedPk(oid), pm);

            // validamos el bloqueo del folio
            if (usuario != null) {
                this.validarBloqueoFolio(datos, usuario, pm);
            }

            String matriculaHija = oid.idMatricula;

            Query query = pm.newQuery(FolioDerivadoEnhanced.class);
            query.setOrdering("this.padre.folio.ordenLPAD ascending");
            query.declareParameters("String matriculaHija");
            query.setFilter("this.idMatricula1==matriculaHija");

            Collection col = (Collection) query.execute(matriculaHija);

            for (Iterator iter = col.iterator(); iter.hasNext();) {
                fd = (FolioDerivadoEnhanced) iter.next();
                folDerivado = new FolioDerivado();
                folDerivado.setIdAnotacion(fd.getIdAnotacion());
                folDerivado.setIdMatricula(fd.getIdMatricula());
                folDerivado.setIdAnotacion1(fd.getIdAnotacion1());
                folDerivado.setIdMatricula1(fd.getIdMatricula1());
                rta.add(folDerivado);
            }

            // Se obtienen los temporales
            query = pm.newQuery(FolioDerivadoTMP.class);
            query.setOrdering("this.padreTmp.folio.ordenLPAD ascending");
            query.declareParameters("String matriculaHija");
            query.setFilter("this.idMatricula1==matriculaHija");

            col = (Collection) query.execute(matriculaHija);

            for (Iterator iter = col.iterator(); iter.hasNext();) {
                fdTMP = (FolioDerivadoTMP) iter.next();
                folDerivado = new FolioDerivado();
                folDerivado.setIdAnotacion(fdTMP.getIdAnotacionTmp());
                folDerivado.setIdMatricula(fdTMP.getIdMatricula());
                folDerivado.setIdAnotacion1(fdTMP.getIdAnotacion1Tmp());
                folDerivado.setIdMatricula1(fdTMP.getIdMatricula1());

                if (fdTMP.isToDelete()) {
                    rta.remove(folDerivado);
                } else {
                    rta.add(folDerivado);
                }
            }

            query.closeAll();
        } catch (JDOObjectNotFoundException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        return rta;
    }

    /* (non-Javadoc)
             * @see gov.sir.forseti.dao.FolioDAO#eliminarEstadoFolio(gov.sir.core.negocio.modelo.EstadoFolio, Usuario usuario)
     */
    public boolean eliminarEstadoFolio(EstadoFolio dato, Usuario usuario)
            throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        EstadoFolioEnhanced eliminada = EstadoFolioEnhanced.enhance(dato);

        try {
            pm.currentTransaction().setOptimistic(false);
            pm.currentTransaction().begin();

            //	Traer Objeto Persistente
            EstadoFolioEnhancedPk idEnh = new EstadoFolioEnhancedPk();
            idEnh.idEstado = eliminada.getIdEstado();

            EstadoFolioEnhanced objPers = (EstadoFolioEnhanced) pm.getObjectById(idEnh,
                    true);

            if (objPers == null) {
                throw new DAOException("No existe el EstadoFolio con el id "
                        + dato.getIdEstado());
            }

            pm.deletePersistent(objPers);
            pm.currentTransaction().commit();
        } catch (Throwable e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        return true;
    }

    /* (non-Javadoc)
     * @see gov.sir.forseti.dao.FolioDAO#eliminarTipoOficina(gov.sir.core.negocio.modelo.TipoOficina, Usuario usuario)
     */
    public boolean eliminarTipoOficina(TipoOficina dato, Usuario usuario)
            throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        TipoOficinaEnhanced eliminada = TipoOficinaEnhanced.enhance(dato);

        try {
            pm.currentTransaction().setOptimistic(false);
            pm.currentTransaction().begin();

            //	Traer Objeto Persistente
            TipoOficinaEnhancedPk idEnh = new TipoOficinaEnhancedPk();
            idEnh.idTipoOficina = dato.getIdTipoOficina();

            TipoOficinaEnhanced objPers = (TipoOficinaEnhanced) pm.getObjectById(idEnh,
                    true);

            if (objPers == null) {
                throw new DAOException(
                        "No existe el Tipo de Oficina con el id "
                        + dato.getIdTipoOficina());
            }

            pm.deletePersistent(objPers);
            pm.currentTransaction().commit();
        } catch (Throwable e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        return true;
    }

    /* (non-Javadoc)
     * @see gov.sir.forseti.dao.FolioDAO#eliminarTipoDocumento(gov.sir.core.negocio.modelo.TipoDocumento, Usuario usuario)
     */
    public boolean eliminarTipoDocumento(TipoDocumento dato, Usuario usuario)
            throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        TipoDocumentoEnhanced eliminada = TipoDocumentoEnhanced.enhance(dato);

        try {
            pm.currentTransaction().setOptimistic(false);
            pm.currentTransaction().begin();

            //	Traer Objeto Persistente
            TipoDocumentoEnhancedPk idEnh = new TipoDocumentoEnhancedPk();
            idEnh.idTipoDocumento = dato.getIdTipoDocumento();

            TipoDocumentoEnhanced objPers = (TipoDocumentoEnhanced) pm.getObjectById(idEnh,
                    true);

            if (objPers == null) {
                throw new DAOException(
                        "No existe el Tipo de Documento con el id "
                        + dato.getIdTipoDocumento());
            }

            pm.deletePersistent(objPers);
            pm.currentTransaction().commit();
        } catch (Throwable e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        return true;
    }

    /* (non-Javadoc)
     * @see gov.sir.forseti.dao.FolioDAO#eliminarTipoPredio(gov.sir.core.negocio.modelo.TipoPredio)
     */
    public boolean eliminarTipoPredio(TipoPredio dato)
            throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        TipoPredioEnhanced eliminada = TipoPredioEnhanced.enhance(dato);

        try {
            pm.currentTransaction().setOptimistic(false);
            pm.currentTransaction().begin();

            //	Traer Objeto Persistente
            TipoPredioEnhancedPk idEnh = new TipoPredioEnhancedPk();
            idEnh.idPredio = dato.getIdPredio();

            TipoPredioEnhanced objPers = (TipoPredioEnhanced) pm.getObjectById(idEnh,
                    true);

            if (objPers == null) {
                throw new DAOException("No existe el Tipo de Predio con el id "
                        + dato.getIdPredio());
            }

            pm.deletePersistent(objPers);
            pm.currentTransaction().commit();
        } catch (Throwable e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        return true;
    }

    /* (non-Javadoc)
     * @see gov.sir.forseti.dao.FolioDAO#eliminarGrupoNaturalezaJuridica(gov.sir.core.negocio.modelo.GrupoNaturalezaJuridica)
     */
    public boolean eliminarGrupoNaturalezaJuridica(GrupoNaturalezaJuridica dato)
            throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        GrupoNaturalezaJuridicaEnhanced eliminada = GrupoNaturalezaJuridicaEnhanced.enhance(dato);

        try {
            pm.currentTransaction().setOptimistic(false);
            pm.currentTransaction().begin();

            //	Traer Objeto Persistente
            GrupoNaturalezaJuridicaEnhancedPk idEnh = new GrupoNaturalezaJuridicaEnhancedPk();
            idEnh.idGrupoNatJuridica = dato.getIdGrupoNatJuridica();

            GrupoNaturalezaJuridicaEnhanced objPers = (GrupoNaturalezaJuridicaEnhanced) pm.getObjectById(idEnh,
                    true);

            if (objPers == null) {
                throw new DAOException(
                        "No existe el Grupo de Naturaleza Jurídica con el id "
                        + dato.getIdGrupoNatJuridica());
            }

            pm.deletePersistent(objPers);
            pm.currentTransaction().commit();
        } catch (Throwable e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        return true;
    }

    /* (non-Javadoc)
     * @see gov.sir.forseti.dao.FolioDAO#eliminarNaturalezaJuridica(gov.sir.core.negocio.modelo.NaturalezaJuridica, Usuario usuario)
     */
    public boolean eliminarNaturalezaJuridica(NaturalezaJuridica dato, Usuario usuario)
            throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        NaturalezaJuridicaEnhanced eliminada = NaturalezaJuridicaEnhanced.enhance(dato);

        try {
            pm.currentTransaction().setOptimistic(false);
            pm.currentTransaction().begin();

            //	Traer Objeto Persistente
            NaturalezaJuridicaEnhancedPk idEnh = new NaturalezaJuridicaEnhancedPk();
            idEnh.idNaturalezaJuridica = dato.getIdNaturalezaJuridica();

            NaturalezaJuridicaEnhanced objPers = (NaturalezaJuridicaEnhanced) pm.getObjectById(idEnh,
                    true);

            if (objPers == null) {
                throw new DAOException(
                        "No existe la Naturaleza Jurídica con el id "
                        + dato.getIdNaturalezaJuridica());
            }

            objPers.getGrupoNaturalezaJuridica().removeNaturalezaJuridica(objPers);
            pm.deletePersistent(objPers);
            pm.currentTransaction().commit();
        } catch (Throwable e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        return true;
    }

    /* (non-Javadoc)
     * @see gov.sir.forseti.dao.FolioDAO#eliminarEstadoAnotacion(gov.sir.core.negocio.modelo.EstadoAnotacion)
     */
    public boolean eliminarEstadoAnotacion(EstadoAnotacion dato)
            throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        EstadoAnotacionEnhanced eliminada = EstadoAnotacionEnhanced.enhance(dato);

        try {
            pm.currentTransaction().setOptimistic(false);
            pm.currentTransaction().begin();

            //	Traer Objeto Persistente
            EstadoAnotacionEnhancedPk idEnh = new EstadoAnotacionEnhancedPk();
            idEnh.idEstadoAn = dato.getIdEstadoAn();

            EstadoAnotacionEnhanced objPers = (EstadoAnotacionEnhanced) pm.getObjectById(idEnh,
                    true);

            if (objPers == null) {
                throw new DAOException(
                        "No existe el estado de anotación con el id "
                        + dato.getIdEstadoAn());
            }

            pm.deletePersistent(objPers);
            pm.currentTransaction().commit();
        } catch (Throwable e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        return true;
    }

    /* (non-Javadoc)
     * @see gov.sir.forseti.dao.FolioDAO#eliminarDominioNaturalezaJuridica(gov.sir.core.negocio.modelo.DominioNaturalezaJuridica)
     */
    public boolean eliminarDominioNaturalezaJuridica(
            DominioNaturalezaJuridica dato) throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        DominioNaturalezaJuridicaEnhanced eliminada = DominioNaturalezaJuridicaEnhanced.enhance(dato);

        try {
            pm.currentTransaction().setOptimistic(false);
            pm.currentTransaction().begin();

            //	Traer Objeto Persistente
            DominioNaturalezaJuridicaEnhancedPk idEnh = new DominioNaturalezaJuridicaEnhancedPk();
            idEnh.idDominioNatJur = dato.getIdDominioNatJur();

            DominioNaturalezaJuridicaEnhanced objPers = (DominioNaturalezaJuridicaEnhanced) pm.getObjectById(idEnh,
                    true);

            if (objPers == null) {
                throw new DAOException(
                        "No existe el dominio de Naturaleza Jurídica con el id "
                        + dato.getIdDominioNatJur());
            }

            pm.deletePersistent(objPers);
            pm.currentTransaction().commit();
        } catch (Throwable e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        return true;
    }

    /**
     *
     * @param oid
     * @param pm
     * @return
     * @throws DAOException
     */
    protected AnotacionCiudadanoEnhanced getAnotacionCiudadano(
            AnotacionCiudadanoEnhancedPk oid, PersistenceManager pm)
            throws DAOException {
        AnotacionCiudadanoEnhanced rta = null;

        if ((oid.idAnotacion != null) && (oid.idCiudadano != null)
                && (oid.idMatricula != null)
                && (oid.rolPersona != null)) {
            try {
                rta = (AnotacionCiudadanoEnhanced) pm.getObjectById(oid, true);
            } catch (JDOObjectNotFoundException e) {
                rta = null;
            } catch (JDOException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                throw new DAOException(e.getMessage(), e);
            }
        }

        return rta;
    }

    /**
     * Obtiene una SalvedadAnotacionEnhanced dado su identificador, método usado
     * en transacciones se debe dar el PersistenceManager
     *
     * @param oid
     * @param pm
     * @return
     * @throws DAOException
     */
    protected SalvedadAnotacionEnhanced getSalvedadAnotacion(
            SalvedadAnotacionEnhancedPk oid, PersistenceManager pm)
            throws DAOException {
        SalvedadAnotacionEnhanced rta = null;

        if ((oid.idAnotacion != null) && (oid.idSalvedad != null)
                && (oid.idMatricula != null)) {
            try {
                rta = (SalvedadAnotacionEnhanced) pm.getObjectById(oid, true);
            } catch (JDOObjectNotFoundException e) {
                rta = null;
            } catch (JDOException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                throw new DAOException(e.getMessage(), e);
            }
        }

        return rta;
    }

    /**
     * Valida la terminación de calificación dependiendo del tipo de validación
     * que se pasa
     *
     * @param oid Identificador del turno
     * @param tipoValidacion Tipo de validación: T TODOS_FOLIOS_UNA_ANOTACION:
     * Valida que todos los folios asociados al turno tengan por lo menos una
     * anotacion temporal UN_FOLIO_UNA_ANOTACION: Valida que por lo menos un
     * folio del turno contenga una anotación
     * @see gov.sir.core.negocio.modelo.constantes.CTipoRevisionCalificacion
     * @return true: Se cumple la validación, false: NO se cumple la validación
     * @throws DAOException
     */
    public boolean validarTerminacionCalificacion(TurnoPk oid,
            String tipoValidacion) throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        FolioDerivadoEnhanced fd;
        boolean rta = false;

        SolicitudFolioEnhanced solicitudFolioEnhanced = null;
        Iterator iter = null;
        AnotacionTMP anotacionTMP;

        try {
            TurnoEnhanced turno = this.getTurnoByID(new TurnoEnhancedPk(oid),
                    pm);

            if (turno == null) {
                throw new DAOException("El turno especificado no existe");
            }

            SolicitudEnhanced sol = turno.getSolicitud();

            if (tipoValidacion.equals(
                    CTipoRevisionCalificacion.UN_FOLIO_UNA_ANOTACION)) {
                VersantQuery query = (VersantQuery) pm.newQuery(SolicitudFolioEnhanced.class);
                query.declareParameters("SolicitudEnhanced sol");
                query.setFilter(
                        "this.solicitud == sol && !folio.anotacionesTMP.isEmpty()");
                //query.setResult("count(*)");

                //Long col = (Long) query.execute(sol);
                Collection c = (Collection) query.execute(sol);

                if (!c.isEmpty()) {
                    iter = c.iterator();

                    while (iter.hasNext()) {
                        solicitudFolioEnhanced = (SolicitudFolioEnhanced) iter.next();
                        Iterator iterator = solicitudFolioEnhanced.getFolio().getAnotacionesTMPs().iterator();
                        while (iterator.hasNext()) {
                            anotacionTMP = (AnotacionTMP) iterator.next();

                            if ((anotacionTMP.getNumRadicacion() != null && anotacionTMP.getNumRadicacion().equals(turno.getIdWorkflow()))
                                    || (anotacionTMP.getIdWorkflow() != null && anotacionTMP.getIdWorkflow().equals(turno.getIdWorkflow()))) {
                                rta = true;
                                break;
                            }
                        }
                    }
                }

                query.closeAll();
            } else if (tipoValidacion.equals(
                    CTipoRevisionCalificacion.TODOS_FOLIOS_UNA_ANOTACION)) {
                VersantQuery query = (VersantQuery) pm.newQuery(SolicitudFolioEnhanced.class);
                query.declareParameters("SolicitudEnhanced sol");
                query.setFilter(
                        "this.solicitud == sol && folio.anotacionesTMP.isEmpty()");
                query.setResult("count(*)");

                Long col = (Long) query.execute(sol);
                Log.getInstance().debug(JDOGenieFolioDAO.class, new Long(col.longValue()));

                if (col.longValue() == 0) {
                    rta = true;
                }

                query.closeAll();
            } else {
                throw new DAOException("Tipo de validación inválida: "
                        + tipoValidacion);
            }
        } catch (JDOObjectNotFoundException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        return rta;
    }

    /**
     * Retorna la lista con los IDs (Folio.ID) de los folios hijos del folio
     * especificado tanto definitivos como temporales Si el folio no tiene hijos
     * o no existe retorna una lista vacía
     *
     * @param oid
     * @return
     * @throws DAOException
     */
    public List getFoliosHijos(FolioPk oid, Usuario usuario)
            throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        FolioDerivadoEnhanced fd;
        FolioDerivadoTMP fdTMP;
        List rta = new ArrayList();
        Folio aux = new Folio();
        FolioEnhanced datos;

        try {
            datos = this.getFolioByID(new FolioEnhancedPk(oid), pm);

            if (datos == null) {
                throw new DAOException("El folio especificado no existe");
            }

            //Validamos el bloqueo del folio
            if (usuario != null) {
                this.validarBloqueoFolio(datos, usuario, pm);
            }

            //Una vez realizadas las validaciones de bloqueo se hace la consulta
            //Se obtiene los hijos definitivos:
            String matriculaPadre = oid.idMatricula;

            /*Query query = pm.newQuery(FolioDerivadoEnhanced.class);
            query.setOrdering("this.hijo.folio.ordenLPAD ascending");
            query.declareParameters("String matriculaPadre");
            query.setFilter("this.idMatricula== matriculaPadre");

            Collection col = (Collection) query.execute(matriculaPadre);

            for (Iterator iter = col.iterator(); iter.hasNext();) {
                fd = (FolioDerivadoEnhanced) iter.next();
                aux = new Folio();
                aux.setIdMatricula(fd.getIdMatricula1());
                aux.setDefinitivo(true);
                rta.add(aux);
            }

            query.closeAll();*/
            rta = this.getFoliosHijosImplementacion(matriculaPadre);

            //Se obtienen los hijos temporales, para insertar o eliminar
            Query query = pm.newQuery(FolioDerivadoTMP.class);
            query.setOrdering("this.hijoTmp.folio.ordenLPAD ascending");
            query.declareParameters("String matriculaPadre");
            query.setFilter("this.idMatricula== matriculaPadre");

            Collection col = (Collection) query.execute(matriculaPadre);

            for (Iterator iter = col.iterator(); iter.hasNext();) {
                fdTMP = (FolioDerivadoTMP) iter.next();
                aux = new Folio();
                aux.setIdMatricula(fdTMP.getIdMatricula1());
                aux.setDefinitivo(false);
                if (fdTMP.isToDelete()) {
                    rta.remove(aux);
                } else {
                    rta.add(aux);
                }

            }

            query.closeAll();
        } catch (JDOObjectNotFoundException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        return rta;
    }

    /**
     * @author : Henry Gómez Rocha
     * @change : Evita que al momento de pasar del role Calificador al role
     * Digitador se verifique el usuario que tiene el bloqueo.. Caso Mantis :
     * 0004967 Retorna la lista con los IDs (Folio.ID) de los folios hijos del
     * folio especificado tanto definitivos como temporales Si el folio no tiene
     * hijos o no existe retorna una lista vacía
     * @param oid
     * @return
     * @throws DAOException
     */
    public List getFoliosHijos(FolioPk oid, Usuario usuario, boolean validarTurno)
            throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        FolioDerivadoEnhanced fd;
        FolioDerivadoTMP fdTMP;
        List rta = new ArrayList();
        Folio aux = new Folio();
        FolioEnhanced datos;

        try {
            datos = this.getFolioByID(new FolioEnhancedPk(oid), pm);

            if (datos == null) {
                throw new DAOException("El folio especificado no existe");
            }

            //Validamos el bloqueo del folio
            if (usuario != null && validarTurno) {
                this.validarBloqueoFolio(datos, usuario, pm);
            }

            //Una vez realizadas las validaciones de bloqueo se hace la consulta
            //Se obtiene los hijos definitivos:
            String matriculaPadre = oid.idMatricula;

            rta = this.getFoliosHijosImplementacion(matriculaPadre);

            //Se obtienen los hijos temporales, para insertar o eliminar
            Query query = pm.newQuery(FolioDerivadoTMP.class);
            query.setOrdering("this.hijoTmp.folio.ordenLPAD ascending");
            query.declareParameters("String matriculaPadre");
            query.setFilter("this.idMatricula== matriculaPadre");

            Collection col = (Collection) query.execute(matriculaPadre);

            for (Iterator iter = col.iterator(); iter.hasNext();) {
                fdTMP = (FolioDerivadoTMP) iter.next();
                aux = new Folio();
                aux.setIdMatricula(fdTMP.getIdMatricula1());
                aux.setDefinitivo(false);
                if (fdTMP.isToDelete()) {
                    rta.remove(aux);
                } else {
                    rta.add(aux);
                }

            }

            query.closeAll();
        } catch (JDOObjectNotFoundException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        return rta;
    }

    /**
     * Retorna la lista con los IDs (Folio.ID) de los folios hijos del folio
     * especificado tanto definitivos como temporales Si el folio no tiene hijos
     * o no existe retorna una lista vacía
     *
     * @param oid
     * @return
     * @throws DAOException
     */
    public List getFoliosHijosOrdenAnotacion(FolioPk oid, Usuario usuario)
            throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        FolioDerivadoEnhanced fd;
        FolioDerivadoTMP fdTMP;
        List rta = new ArrayList();
        Folio aux = new Folio();
        FolioEnhanced datos;

        try {
            datos = this.getFolioByID(new FolioEnhancedPk(oid), pm);

            if (datos == null) {
                throw new DAOException("El folio especificado no existe");
            }

            //Validamos el bloqueo del folio
            if (usuario != null) {
                this.validarBloqueoFolio(datos, usuario, pm);
            }

            //Una vez realizadas las validaciones de bloqueo se hace la consulta
            //Se obtiene los hijos definitivos:
            String matriculaPadre = oid.idMatricula;

            rta = this.getFoliosHijosImplementacionOrdenAnotacion(matriculaPadre);

            rta.addAll(this.getFoliosHijosImplementacionOrdenAnotacionTMP(matriculaPadre));

        } catch (JDOObjectNotFoundException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        return rta;
    }

    /**
     * Retorna la lista con los IDs (Folio.ID) de los folios padre del folio
     * especificado tanto definitivos como temporales Si el folio no tiene
     * padres o no existe retorna una lista vacía
     *
     * @param oid
     * @return
     * @throws DAOException
     */
    public List getFoliosPadre(FolioPk oid, Usuario usuario) throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        FolioDerivadoEnhanced fd;
        FolioDerivadoTMP fdTMP;
        List rta = new ArrayList();
        Folio aux = new Folio();
        FolioEnhanced datos;

        try {
            datos = this.getFolioByID(new FolioEnhancedPk(oid), pm);

            if (datos == null) {
                throw new DAOException("El folio especificado no existe");
            }

            //validamos el bloqueo del folio
            if (usuario != null) {
                this.validarBloqueoFolio(datos, usuario, pm);
            }

            //Una vez realizadas las validaciones de bloqueo se hace la consulta
            //Se obtiene los hijos definitivos:
            String matriculaHija = oid.idMatricula;

            /*Query query = pm.newQuery(FolioDerivadoEnhanced.class);
            query.setOrdering("this.padre.folio.ordenLPAD ascending");
            query.declareParameters("String matriculaHija");
            query.setFilter("this.idMatricula1==matriculaHija");

            Collection col = (Collection) query.execute(matriculaHija);

            for (Iterator iter = col.iterator(); iter.hasNext();) {
                fd = (FolioDerivadoEnhanced) iter.next();
                aux = new Folio();
                aux.setIdMatricula(fd.getIdMatricula());
                aux.setDefinitivo(true);
                rta.add(aux);
            }

            query.closeAll();*/
            rta = this.getFoliosPadresImplementacion(matriculaHija);

            //Se obtienen los temporales
            Query query = pm.newQuery(FolioDerivadoTMP.class);
            query.setOrdering("this.padreTmp.folio.ordenLPAD ascending");
            query.declareParameters("String matriculaHija");
            query.setFilter("this.idMatricula1==matriculaHija");

            Collection col = (Collection) query.execute(matriculaHija);

            for (Iterator iter = col.iterator(); iter.hasNext();) {
                fdTMP = (FolioDerivadoTMP) iter.next();
                aux = new Folio();
                aux.setIdMatricula(fdTMP.getIdMatricula());
                aux.setDefinitivo(false);
                if (fdTMP.isToDelete()) {
                    rta.remove(aux);
                } else {
                    rta.add(aux);
                }

            }

            query.closeAll();
        } catch (JDOObjectNotFoundException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        return rta;
    }

    /**
     * @author : Henry Gómez Rocha
     * @change : Evita que al momento de pasar del role Calificador al role
     * Digitador se verifique el usuario que tiene el bloqueo.. Caso Mantis :
     * 0004967 Retorna la lista con los IDs (Folio.ID) de los folios padre del
     * folio especificado tanto definitivos como temporales Si el folio no tiene
     * padres o no existe retorna una lista vacía
     * @param oid
     * @return
     * @throws DAOException
     */
    public List getFoliosPadre(FolioPk oid, Usuario usuario, boolean validarTurno) throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        FolioDerivadoEnhanced fd;
        FolioDerivadoTMP fdTMP;
        List rta = new ArrayList();
        Folio aux = new Folio();
        FolioEnhanced datos;

        try {
            datos = this.getFolioByID(new FolioEnhancedPk(oid), pm);

            if (datos == null) {
                throw new DAOException("El folio especificado no existe");
            }

            //validamos el bloqueo del folio
            if (usuario != null && validarTurno) {
                this.validarBloqueoFolio(datos, usuario, pm);
            }

            //Una vez realizadas las validaciones de bloqueo se hace la consulta
            //Se obtiene los hijos definitivos:
            String matriculaHija = oid.idMatricula;

            rta = this.getFoliosPadresImplementacion(matriculaHija);

            //Se obtienen los temporales
            Query query = pm.newQuery(FolioDerivadoTMP.class);
            query.setOrdering("this.padreTmp.folio.ordenLPAD ascending");
            query.declareParameters("String matriculaHija");
            query.setFilter("this.idMatricula1==matriculaHija");

            Collection col = (Collection) query.execute(matriculaHija);

            for (Iterator iter = col.iterator(); iter.hasNext();) {
                fdTMP = (FolioDerivadoTMP) iter.next();
                aux = new Folio();
                aux.setIdMatricula(fdTMP.getIdMatricula());
                aux.setDefinitivo(false);
                if (fdTMP.isToDelete()) {
                    rta.remove(aux);
                } else {
                    rta.add(aux);
                }

            }

            query.closeAll();
        } catch (JDOObjectNotFoundException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        return rta;
    }

    public List getFoliosHijosImplementacion(String idMatricula) throws DAOException {

        PersistenceManager pm = AdministradorPM.getPM();
        List lista = new ArrayList();
        Connection connection = null;
        PreparedStatement ps = null;
        ResultSet rs = null;

        VersantPersistenceManager jdoPM = null;

        try {

            String consulta
                    = "SELECT ID_MATRICULA1 "
                    + "FROM SIR_NE_FOLIO_dERIVADO "
                    + "WHERE ID_MATRICULA = ? ";

            jdoPM = (VersantPersistenceManager) AdministradorPM.getPM();

            jdoPM.currentTransaction().begin();
            connection = jdoPM.getJdbcConnection(null);
            ps = connection.prepareStatement(consulta);
            ps.setString(1, idMatricula);

            rs = ps.executeQuery();

            while (rs.next()) {
                Folio folio = new Folio();
                folio.setIdMatricula(rs.getString(1));
                folio.setDefinitivo(true);
                lista.add(folio);
            }
            jdoPM.currentTransaction().commit();

        } catch (SQLException e) {
            if (jdoPM.currentTransaction().isActive()) {
                jdoPM.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        } catch (JDOObjectNotFoundException e) {
            if (jdoPM.currentTransaction().isActive()) {
                jdoPM.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        } catch (JDOException e) {
            if (jdoPM.currentTransaction().isActive()) {
                jdoPM.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        } catch (Throwable e) {
            if (jdoPM.currentTransaction().isActive()) {
                jdoPM.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        } finally {
            try {
                if (rs != null) {
                    rs.close();
                }

                if (ps != null) {
                    ps.close();
                }
                if (connection != null) {
                    connection.close();
                }
                if (jdoPM != null) {
                    jdoPM.close();
                }
            } catch (SQLException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e);
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
                throw new DAOException(e.getMessage(), e);
            }
        }

        return lista;
    }

    public List getFoliosHijosImplementacionOrdenAnotacion(String idMatricula) throws DAOException {

        PersistenceManager pm = AdministradorPM.getPM();
        List lista = new ArrayList();
        Connection connection = null;
        PreparedStatement ps = null;
        ResultSet rs = null;

        VersantPersistenceManager jdoPM = null;

        try {

            String consulta
                    = "SELECT ID_MATRICULA1 "
                    + "FROM SIR_NE_FOLIO_dERIVADO "
                    + "WHERE ID_MATRICULA = ? "
                    + "ORDER BY TO_NUMBER(ID_ANOTACION)";

            jdoPM = (VersantPersistenceManager) AdministradorPM.getPM();

            jdoPM.currentTransaction().begin();
            connection = jdoPM.getJdbcConnection(null);
            ps = connection.prepareStatement(consulta);

            ps.setString(1, idMatricula);

            rs = ps.executeQuery();

            while (rs.next()) {
                Folio folio = new Folio();
                folio.setIdMatricula(rs.getString(1));
                folio.setDefinitivo(true);
                lista.add(folio);
            }
            jdoPM.currentTransaction().commit();

        } catch (SQLException e) {
            if (jdoPM.currentTransaction().isActive()) {
                jdoPM.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        } catch (JDOObjectNotFoundException e) {
            if (jdoPM.currentTransaction().isActive()) {
                jdoPM.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        } catch (JDOException e) {
            if (jdoPM.currentTransaction().isActive()) {
                jdoPM.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        } catch (Throwable e) {
            if (jdoPM.currentTransaction().isActive()) {
                jdoPM.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        } finally {
            try {
                if (rs != null) {
                    rs.close();
                }

                if (ps != null) {
                    ps.close();
                }

                if (connection != null) {
                    connection.close();
                }

                if (jdoPM != null) {
                    jdoPM.close();
                }
            } catch (SQLException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e);
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
                throw new DAOException(e.getMessage(), e);
            }
        }

        return lista;
    }

    public List getFoliosHijosImplementacionOrdenAnotacionTMP(String idMatricula) throws DAOException {

        PersistenceManager pm = AdministradorPM.getPM();
        List lista = new ArrayList();
        Connection connection = null;
        PreparedStatement ps = null;
        ResultSet rs = null;

        VersantPersistenceManager jdoPM = null;

        try {

            String consulta
                    = "SELECT ID_MATRICULA1 "
                    + "FROM SIR_NE_FOLIO_DERIVADO_TMP "
                    + "WHERE ID_MATRICULA = ? "
                    + "ORDER BY TO_NUMBER(ID_ANOTACION_TMP)";

            jdoPM = (VersantPersistenceManager) AdministradorPM.getPM();

            jdoPM.currentTransaction().begin();
            connection = jdoPM.getJdbcConnection(null);
            ps = connection.prepareStatement(consulta);

            ps.setString(1, idMatricula);

            rs = ps.executeQuery();

            while (rs.next()) {
                Folio folio = new Folio();
                folio.setIdMatricula(rs.getString(1));
                folio.setDefinitivo(false);
                lista.add(folio);
            }
            jdoPM.currentTransaction().commit();

        } catch (SQLException e) {
            if (jdoPM.currentTransaction().isActive()) {
                jdoPM.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        } catch (JDOObjectNotFoundException e) {
            if (jdoPM.currentTransaction().isActive()) {
                jdoPM.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        } catch (JDOException e) {
            if (jdoPM.currentTransaction().isActive()) {
                jdoPM.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        } catch (Throwable e) {
            if (jdoPM.currentTransaction().isActive()) {
                jdoPM.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        } finally {
            try {
                if (rs != null) {
                    rs.close();
                }

                if (ps != null) {
                    ps.close();
                }
                if (connection != null) {
                    connection.close();
                }
                if (jdoPM != null) {
                    jdoPM.close();
                }
            } catch (SQLException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e);
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
                throw new DAOException(e.getMessage(), e);
            }
        }

        return lista;
    }

    public List getFoliosPadresImplementacion(String idMatricula) throws DAOException {

        PersistenceManager pm = AdministradorPM.getPM();
        List lista = new ArrayList();
        Connection connection = null;
        PreparedStatement ps = null;
        ResultSet rs = null;
        VersantPersistenceManager jdoPM = null;

        String consulta
                = "SELECT ID_MATRICULA "
                + "FROM SIR_NE_FOLIO_dERIVADO "
                + "WHERE ID_MATRICULA1 = ? ";

        try {
            jdoPM = (VersantPersistenceManager) AdministradorPM.getPM();

            jdoPM.currentTransaction().begin();
            connection = jdoPM.getJdbcConnection(null);
            ps = connection.prepareStatement(consulta);

            ps.setString(1, idMatricula);

            rs = ps.executeQuery();

            while (rs.next()) {
                Folio folio = new Folio();
                folio.setIdMatricula(rs.getString(1));
                folio.setDefinitivo(true);
                lista.add(folio);
            }
            jdoPM.currentTransaction().commit();

        } catch (SQLException e) {
            if (jdoPM.currentTransaction().isActive()) {
                jdoPM.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        } catch (JDOObjectNotFoundException e) {
            if (jdoPM.currentTransaction().isActive()) {
                jdoPM.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        } catch (JDOException e) {
            if (jdoPM.currentTransaction().isActive()) {
                jdoPM.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        } catch (Throwable e) {
            if (jdoPM.currentTransaction().isActive()) {
                jdoPM.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        } finally {
            try {
                if (rs != null) {
                    rs.close();
                }

                if (ps != null) {
                    ps.close();
                }

                if (connection != null) {
                    connection.close();
                }

                if (jdoPM != null) {
                    jdoPM.close();
                }
            } catch (SQLException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e);
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
                throw new DAOException(e.getMessage(), e);
            }
        }

        return lista;
    }

    /**
     * Obtiene la zona registral de un folio dada la matricula
     *
     * @param matricula
     * @return
     * @throws DAOException
     */
    public String getZonaRegistral(String matricula) throws DAOException {
        FolioEnhanced folio = null;
        PersistenceManager pm = AdministradorPM.getPM();
        String rta = null;

        try {
            folio = this.getFolioByMatricula(matricula, pm);

            if (folio == null) {
                throw new DAOException("El folio no existe. IdMatricula: "
                        + matricula);
            }

            rta = folio.getZonaRegistral().getIdZonaRegistral();
        } catch (JDOObjectNotFoundException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        return rta;
    }

    /**
     * Retorna la lista de las anotaciones que tienen salvedades en un folio
     * tanto definitivos como temporales Si el folio no tiene anotaciones con
     * salvedades retorna una lista vacia
     *
     * @param oid
     * @return
     * @throws DAOException
     */
    public List getAnotacionesConSalvedades(FolioPk oid, Usuario usuario)
            throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        AnotacionEnhanced anota;
        AnotacionTMP anotaTMP;
        List rta = new ArrayList();
        FolioEnhanced datos;

        try {
            datos = this.getFolioByID(new FolioEnhancedPk(oid), pm);

            if (datos == null) {
                throw new DAOException("El folio especificado no existe");
            }

            //validamos el bloqueo del folio
            if (usuario != null) {
                this.validarBloqueoFolio(datos, usuario, pm);
            }

            //Una vez realizadas las validaciones de bloqueo se hace la consulta
            //Se obtiene las anotaciones definitivas que tengan salvedades
            //*String obsoleto = CEstadoAnotacion.OBSOLETA;
            Query query = pm.newQuery(AnotacionEnhanced.class);
            query.declareParameters("FolioEnhanced datos");
            //*query.declareParameters("FolioEnhanced datos, String obsoleto");
            query.setFilter("this.folio==datos &&\n"
                    + "!this.salvedades.isEmpty() &&\n"
                    + " (this.link==null || this.link==false)");
            //*"this.estado.idEstadoAn!=obsoleto && (this.link==null || this.link==false)");            

            Collection col = (Collection) query.execute(datos);
            //*Collection col = (Collection) query.execute(datos, obsoleto);

            for (Iterator iter = col.iterator(); iter.hasNext();) {
                anota = (AnotacionEnhanced) iter.next();
                this.makeTransientAnotacion(anota, pm, new ArrayList());
                rta.add(anota);
            }

            query.closeAll();

            //Se obtienen las anotaciones temporales que tengan salvedades
            query = pm.newQuery(AnotacionTMP.class);
            query.declareParameters("FolioEnhanced datos");
            //*query.declareParameters("FolioEnhanced datos, String obsoleto");
            query.setFilter("this.folio==datos &&\n"
                    + "!this.salvedadesTMP.isEmpty() ");
            //*"!this.salvedadesTMP.isEmpty() &&\n" +
            //*"this.estado.idEstadoAn!=obsoleto");

            col = (Collection) query.execute(datos);
            //*col = (Collection) query.execute(datos, obsoleto);

            for (Iterator iter = col.iterator(); iter.hasNext();) {
                anotaTMP = (AnotacionTMP) iter.next();
                this.makeTransientAnotacionTMP(anotaTMP, pm, new ArrayList());
                rta.add(anotaTMP.getDefinitivo(new ArrayList()));
            }

            query.closeAll();
        } catch (JDOObjectNotFoundException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        return TransferUtils.makeTransferAll(rta);
    }

    /**
     * @author : Henry Gómez Rocha
     * @change : Evita que al momento de pasar del role Calificador al role
     * Digitador se verifique el usuario que tiene el bloqueo.. Caso Mantis :
     * 0004967 Retorna la lista de las anotaciones que tienen salvedades en un
     * folio tanto definitivos como temporales Si el folio no tiene anotaciones
     * con salvedades retorna una lista vacia
     * @param oid
     * @return
     * @throws DAOException
     */
    public List getAnotacionesConSalvedades(FolioPk oid, Usuario usuario, boolean validarTurno)
            throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        AnotacionEnhanced anota;
        AnotacionTMP anotaTMP;
        List rta = new ArrayList();
        FolioEnhanced datos;

        try {
            datos = this.getFolioByID(new FolioEnhancedPk(oid), pm);

            if (datos == null) {
                throw new DAOException("El folio especificado no existe");
            }

            //validamos el bloqueo del folio
            if (usuario != null && validarTurno) {
                this.validarBloqueoFolio(datos, usuario, pm);
            }

            //Una vez realizadas las validaciones de bloqueo se hace la consulta
            //Se obtiene las anotaciones definitivas que tengan salvedades
            //*String obsoleto = CEstadoAnotacion.OBSOLETA;
            Query query = pm.newQuery(AnotacionEnhanced.class);
            query.declareParameters("FolioEnhanced datos");
            //*query.declareParameters("FolioEnhanced datos, String obsoleto");
            query.setFilter("this.folio==datos &&\n"
                    + "!this.salvedades.isEmpty() &&\n"
                    + " (this.link==null || this.link==false)");
            //*"this.estado.idEstadoAn!=obsoleto && (this.link==null || this.link==false)");

            Collection col = (Collection) query.execute(datos);
            //*Collection col = (Collection) query.execute(datos, obsoleto);

            for (Iterator iter = col.iterator(); iter.hasNext();) {
                anota = (AnotacionEnhanced) iter.next();
                this.makeTransientAnotacion(anota, pm, new ArrayList());
                rta.add(anota);
            }

            query.closeAll();

            //Se obtienen las anotaciones temporales que tengan salvedades
            query = pm.newQuery(AnotacionTMP.class);
            query.declareParameters("FolioEnhanced datos");
            //*query.declareParameters("FolioEnhanced datos, String obsoleto");
            query.setFilter("this.folio==datos &&\n"
                    + "!this.salvedadesTMP.isEmpty() ");
            //*"!this.salvedadesTMP.isEmpty() &&\n" +
            //*"this.estado.idEstadoAn!=obsoleto");

            col = (Collection) query.execute(datos);
            //*col = (Collection) query.execute(datos, obsoleto);

            for (Iterator iter = col.iterator(); iter.hasNext();) {
                anotaTMP = (AnotacionTMP) iter.next();
                this.makeTransientAnotacionTMP(anotaTMP, pm, new ArrayList());
                rta.add(anotaTMP.getDefinitivo(new ArrayList()));
            }

            query.closeAll();
        } catch (JDOObjectNotFoundException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        return TransferUtils.makeTransferAll(rta);
    }

    /**
     * Retorna la lista de las anotaciones que tienen salvedades en un folio Si
     * el folio no tiene anotaciones con salvedades retorna una lista vacia
     *
     * @param oid
     * @return
     * @throws DAOException
     */
    public List getAnotacionesConSalvedades(FolioPk oid)
            throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        AnotacionEnhanced anota;
        AnotacionTMP anotaTMP;
        List rta = new ArrayList();
        FolioEnhanced datos;

        try {
            datos = this.getFolioByID(new FolioEnhancedPk(oid), pm);

            if (datos == null) {
                throw new DAOException("El folio especificado no existe");
            }

            //Se obtiene las anotaciones definitivas que tengan salvedades
            //*String obsoleto = CEstadoAnotacion.OBSOLETA;
            Query query = pm.newQuery(AnotacionEnhanced.class);
            query.declareParameters("FolioEnhanced datos");
            //*query.declareParameters("FolioEnhanced datos, String obsoleto");
            query.setFilter("this.folio==datos &&\n"
                    + "!this.salvedades.isEmpty() &&\n"
                    + " (this.link==null || this.link==false)");
            //*"this.estado.idEstadoAn!=obsoleto && (this.link==null || this.link==false)");

            Collection col = (Collection) query.execute(datos);
            //*Collection col = (Collection) query.execute(datos, obsoleto);

            for (Iterator iter = col.iterator(); iter.hasNext();) {
                anota = (AnotacionEnhanced) iter.next();
                this.makeTransientAnotacion(anota, pm, new ArrayList());
                rta.add(anota);
            }

            query.closeAll();
        } catch (JDOObjectNotFoundException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        return TransferUtils.makeTransferAll(rta);
    }

    /**
     * Retorna la lista de las anotaciones que tienen cancelaciones en un folio
     * tanto definitivos como temporales Si el folio no tiene anotaciones con
     * salvedades retorna una lista vacia
     *
     * @param oid
     * @return
     * @throws DAOException
     */
    public List getAnotacionesConCancelaciones(FolioPk oid, Usuario usuario)
            throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        AnotacionEnhanced anota;
        AnotacionTMP anotaTMP;
        List rta = new ArrayList();
        FolioEnhanced datos;

        try {
            datos = this.getFolioByID(new FolioEnhancedPk(oid), pm);

            if (datos == null) {
                throw new DAOException("El folio especificado no existe");
            }

            //validamos el bloqueo del folio
            if (usuario != null) {
                this.validarBloqueoFolio(datos, usuario, pm);
            }

            //Una vez realizadas las validaciones de bloqueo se hace la consulta
            //Se obtiene las anotaciones definitivas que tengan cancelaciones
            //*String obsoleto = CEstadoAnotacion.OBSOLETA;
            Query query = pm.newQuery(AnotacionEnhanced.class);
            query.declareParameters("FolioEnhanced datos");
            //*query.declareParameters("FolioEnhanced datos, String obsoleto");
            query.setFilter("this.folio==datos &&\n"
                    + "!this.anotacionesCancelacion.isEmpty() &&\n"
                    + " (this.link==null || this.link==false)");
            //*"this.estado.idEstadoAn!=obsoleto && (this.link==null || this.link==false)");

            Collection col = (Collection) query.execute(datos);
            //*Collection col = (Collection) query.execute(datos, obsoleto);

            for (Iterator iter = col.iterator(); iter.hasNext();) {
                anota = (AnotacionEnhanced) iter.next();
                this.makeTransientAnotacion(anota, pm, new ArrayList());
                rta.add(anota);
            }

            query.closeAll();

            //Se obtienen las anotaciones temporales que tengan salvedades
            query = pm.newQuery(AnotacionTMP.class);
            query.declareParameters("FolioEnhanced datos");
            //*query.declareParameters("FolioEnhanced datos, String obsoleto");
            query.setFilter("this.folio==datos &&\n"
                    + "!this.anotacionesCancelacionTMP.isEmpty()");
            //*"!this.anotacionesCancelacionTMP.isEmpty() &&\n" +
            //*"this.estado.idEstadoAn!=obsoleto");

            col = (Collection) query.execute(datos);
            //*col = (Collection) query.execute(datos, obsoleto);

            for (Iterator iter = col.iterator(); iter.hasNext();) {
                anotaTMP = (AnotacionTMP) iter.next();
                this.makeTransientAnotacionTMP(anotaTMP, pm, new ArrayList());
                rta.add(anotaTMP.getDefinitivo(new ArrayList()));
            }

            query.closeAll();
        } catch (JDOObjectNotFoundException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        return TransferUtils.makeTransferAll(rta);
    }

    /**
     * @author : Henry Gómez Rocha
     * @change : Evita que al momento de pasar del role Calificador al role
     * Digitador se verifique el usuario que tiene el bloqueo.. Caso Mantis :
     * 0004967 Retorna la lista de las anotaciones que tienen cancelaciones en
     * un folio tanto definitivos como temporales Si el folio no tiene
     * anotaciones con salvedades retorna una lista vacia
     * @param oid
     * @return
     * @throws DAOException
     */
    public List getAnotacionesConCancelaciones(FolioPk oid, Usuario usuario, boolean validarTurno)
            throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        AnotacionEnhanced anota;
        AnotacionTMP anotaTMP;
        List rta = new ArrayList();
        FolioEnhanced datos;

        try {
            datos = this.getFolioByID(new FolioEnhancedPk(oid), pm);

            if (datos == null) {
                throw new DAOException("El folio especificado no existe");
            }

            //validamos el bloqueo del folio
            if (usuario != null && validarTurno) {
                this.validarBloqueoFolio(datos, usuario, pm);
            }

            //Una vez realizadas las validaciones de bloqueo se hace la consulta
            //Se obtiene las anotaciones definitivas que tengan cancelaciones
            //*String obsoleto = CEstadoAnotacion.OBSOLETA;
            Query query = pm.newQuery(AnotacionEnhanced.class);
            query.declareParameters("FolioEnhanced datos");
            //*query.declareParameters("FolioEnhanced datos, String obsoleto");
            query.setFilter("this.folio==datos &&\n"
                    + "!this.anotacionesCancelacion.isEmpty() &&\n"
                    + " (this.link==null || this.link==false)");
            //*"this.estado.idEstadoAn!=obsoleto && (this.link==null || this.link==false)");

            Collection col = (Collection) query.execute(datos);
            //*Collection col = (Collection) query.execute(datos, obsoleto);

            for (Iterator iter = col.iterator(); iter.hasNext();) {
                anota = (AnotacionEnhanced) iter.next();
                this.makeTransientAnotacion(anota, pm, new ArrayList());
                rta.add(anota);
            }

            query.closeAll();

            //Se obtienen las anotaciones temporales que tengan salvedades
            query = pm.newQuery(AnotacionTMP.class);
            query.declareParameters("FolioEnhanced datos");
            //*query.declareParameters("FolioEnhanced datos, String obsoleto");
            query.setFilter("this.folio==datos &&\n"
                    + "!this.anotacionesCancelacionTMP.isEmpty()");
            //*"!this.anotacionesCancelacionTMP.isEmpty() &&\n" +
            //*"this.estado.idEstadoAn!=obsoleto");

            col = (Collection) query.execute(datos);
            //*col = (Collection) query.execute(datos, obsoleto);

            for (Iterator iter = col.iterator(); iter.hasNext();) {
                anotaTMP = (AnotacionTMP) iter.next();
                this.makeTransientAnotacionTMP(anotaTMP, pm, new ArrayList());
                rta.add(anotaTMP.getDefinitivo(new ArrayList()));
            }

            query.closeAll();
        } catch (JDOObjectNotFoundException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        return TransferUtils.makeTransferAll(rta);
    }

    /**
     * Retorna la lista de las anotaciones que tienen cancelaciones en un folio
     * Si el folio no tiene anotaciones con cancelaciones retorna una lista
     * vacia
     *
     * @param oid
     * @return
     * @throws DAOException
     */
    public List getAnotacionesConCancelaciones(FolioPk oid)
            throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        AnotacionEnhanced anota;
        AnotacionTMP anotaTMP;
        List rta = new ArrayList();
        FolioEnhanced datos;

        try {
            datos = this.getFolioByID(new FolioEnhancedPk(oid), pm);

            if (datos == null) {
                throw new DAOException("El folio especificado no existe");
            }

            //Se obtiene las anotaciones definitivas que tengan salvedades
            //*String obsoleto = CEstadoAnotacion.OBSOLETA;
            Query query = pm.newQuery(AnotacionEnhanced.class);
            query.declareParameters("FolioEnhanced datos");
            //*query.declareParameters("FolioEnhanced datos, String obsoleto");
            query.setFilter("this.folio==datos &&\n"
                    + "!this.anotacionesCancelacion.isEmpty() &&\n"
                    + " (this.link==null || this.link==false)");
            //*"this.estado.idEstadoAn!=obsoleto && (this.link==null || this.link==false)");

            Collection col = (Collection) query.execute(datos);
            //*Collection col = (Collection) query.execute(datos, obsoleto);

            for (Iterator iter = col.iterator(); iter.hasNext();) {
                anota = (AnotacionEnhanced) iter.next();
                this.makeTransientAnotacion(anota, pm, new ArrayList());
                rta.add(anota);
            }

            query.closeAll();
        } catch (JDOObjectNotFoundException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        return TransferUtils.makeTransferAll(rta);
    }

    /**
     * Retorna la lista de las anotaciones inválidas en un folio tanto
     * definitivos como temporales Si el folio no tiene anotaciones inválidas
     * retorna una lista vacia
     *
     * @param oid
     * @return
     * @throws Throwable
     */
    public List getAnotacionesInvalidas(FolioPk oid, Usuario usuario)
            throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        AnotacionEnhanced anota;
        AnotacionTMP anotaTMP;
        List rta = new ArrayList();
        FolioEnhanced datos;

        try {
            datos = this.getFolioByID(new FolioEnhancedPk(oid), pm);

            if (datos == null) {
                throw new DAOException("El folio especificado no existe");
            }

            //validamos el bloqueo del folio
            if (usuario != null) {
                this.validarBloqueoFolio(datos, usuario, pm);
            }

            //Una vez realizadas las validaciones de bloqueo se hace la consulta
            //Se obtiene las anotaciones inválidas que no tengan anotaciones temporales.
            String invalida = CEstadoAnotacion.INVALIDO;
            Query query = pm.newQuery(AnotacionEnhanced.class);
            query.declareParameters("FolioEnhanced datos, String invalida");
            query.declareVariables("AnotacionTMP anotaTMP");
            query.setFilter("this.folio==datos &&\n"
                    + "this.estado.idEstadoAn==invalida && (this.link==null || this.link==false)"
                    + " && !(anotaTMP.folio==datos \n"
                    + " && anotaTMP.idAnotacionTmp==this.idAnotacion)");

            Collection col = (Collection) query.execute(datos, invalida);

            for (Iterator iter = col.iterator(); iter.hasNext();) {
                anota = (AnotacionEnhanced) iter.next();
                this.makeTransientAnotacion(anota, pm, new ArrayList());
                rta.add(anota);
            }

            query.closeAll();

            //Se consultan las anotaciones que son definitivas pero que son invalidas en las
            //anotaciones temporales
            query = pm.newQuery(AnotacionEnhanced.class);
            query.declareParameters("FolioEnhanced datos, String invalida");
            query.declareVariables("AnotacionTMP anotaTMP");
            query.setFilter("this.folio==datos &&\n"
                    + "(this.link==null || this.link==false)"
                    + " && (anotaTMP.folio==datos \n"
                    + " && anotaTMP.idAnotacionTmp==this.idAnotacion) && anotaTMP.estado.idEstadoAn==invalida");

            col = (Collection) query.execute(datos, invalida);

            for (Iterator iter = col.iterator(); iter.hasNext();) {
                anota = (AnotacionEnhanced) iter.next();
                this.makeTransientAnotacion(anota, pm, new ArrayList());
                //Por cada anotación encotrada buscamos si existe una
                //anotación temporal que la esté actualizando:
                AnotacionTMPPk aTMPID = new AnotacionTMPPk();
                aTMPID.idAnotacionTmp = anota.getIdAnotacion();
                aTMPID.idMatricula = anota.getIdMatricula();

                anotaTMP = this.getAnotacionTMPByID(aTMPID, pm);

                this.makeTransientAnotacion(anota, pm, new ArrayList());

                if (anotaTMP == null) {
                    //La anotación NO tiene actualizaciones
                    rta.add(anota);
                } else {
                    //LA anotación TIENE actualizaciones por aplicar
                    this.makeTransientAnotacionTMP(anotaTMP, pm,
                            new ArrayList());
                    AnotacionEnhanced an = this.getAnotacionDefinitivaConDeltasAplicados(
                            anota, anotaTMP);
                    rta.add(an);
                }

            }

            query.closeAll();

            //Se obtienen las anotaciones temporales que son inválidas
            query = pm.newQuery(AnotacionTMP.class);
            query.declareParameters("FolioEnhanced datos, String invalida");
            query.declareVariables("AnotacionEnhanced anota");
            query.setFilter("this.folio==datos &&\n"
                    + "this.estado.idEstadoAn==invalida "
                    + //No contar las anotaciones temporales creadas para actualizar definitivas
                    " && !(anota.folio==datos \n"
                    + " && anota.idAnotacion==this.idAnotacionTmp)");

            col = (Collection) query.execute(datos, invalida);

            for (Iterator iter = col.iterator(); iter.hasNext();) {
                anotaTMP = (AnotacionTMP) iter.next();
                this.makeTransientAnotacionTMP(anotaTMP, pm, new ArrayList());
                rta.add(anotaTMP.getDefinitivo(new ArrayList()));
            }

            query.closeAll();
        } catch (JDOObjectNotFoundException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        return TransferUtils.makeTransferAll(rta);
    }

    /**
     * @author : Henry Gómez Rocha
     * @change : Evita que al momento de pasar del role Calificador al role
     * Digitador se verifique el usuario que tiene el bloqueo.. Caso Mantis :
     * 0004967 Retorna la lista de las anotaciones inválidas en un folio tanto
     * definitivos como temporales Si el folio no tiene anotaciones inválidas
     * retorna una lista vacia
     * @param oid
     * @return
     * @throws Throwable
     */
    public List getAnotacionesInvalidas(FolioPk oid, Usuario usuario, boolean validarTurno)
            throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        AnotacionEnhanced anota;
        AnotacionTMP anotaTMP;
        List rta = new ArrayList();
        FolioEnhanced datos;

        try {
            datos = this.getFolioByID(new FolioEnhancedPk(oid), pm);

            if (datos == null) {
                throw new DAOException("El folio especificado no existe");
            }

            //validamos el bloqueo del folio
            if (usuario != null && validarTurno) {
                this.validarBloqueoFolio(datos, usuario, pm);
            }

            //Una vez realizadas las validaciones de bloqueo se hace la consulta
            //Se obtiene las anotaciones inválidas que no tengan anotaciones temporales.
            String invalida = CEstadoAnotacion.INVALIDO;
            Query query = pm.newQuery(AnotacionEnhanced.class);
            query.declareParameters("FolioEnhanced datos, String invalida");
            query.declareVariables("AnotacionTMP anotaTMP");
            query.setFilter("this.folio==datos &&\n"
                    + "this.estado.idEstadoAn==invalida && (this.link==null || this.link==false)"
                    + " && !(anotaTMP.folio==datos \n"
                    + " && anotaTMP.idAnotacionTmp==this.idAnotacion)");

            Collection col = (Collection) query.execute(datos, invalida);

            for (Iterator iter = col.iterator(); iter.hasNext();) {
                anota = (AnotacionEnhanced) iter.next();
                this.makeTransientAnotacion(anota, pm, new ArrayList());
                rta.add(anota);
            }

            query.closeAll();

            //Se consultan las anotaciones que son definitivas pero que son invalidas en las
            //anotaciones temporales
            query = pm.newQuery(AnotacionEnhanced.class);
            query.declareParameters("FolioEnhanced datos, String invalida");
            query.declareVariables("AnotacionTMP anotaTMP");
            query.setFilter("this.folio==datos &&\n"
                    + "(this.link==null || this.link==false)"
                    + " && (anotaTMP.folio==datos \n"
                    + " && anotaTMP.idAnotacionTmp==this.idAnotacion) && anotaTMP.estado.idEstadoAn==invalida");

            col = (Collection) query.execute(datos, invalida);

            for (Iterator iter = col.iterator(); iter.hasNext();) {
                anota = (AnotacionEnhanced) iter.next();
                this.makeTransientAnotacion(anota, pm, new ArrayList());
                //Por cada anotación encotrada buscamos si existe una
                //anotación temporal que la esté actualizando:
                AnotacionTMPPk aTMPID = new AnotacionTMPPk();
                aTMPID.idAnotacionTmp = anota.getIdAnotacion();
                aTMPID.idMatricula = anota.getIdMatricula();

                anotaTMP = this.getAnotacionTMPByID(aTMPID, pm);

                this.makeTransientAnotacion(anota, pm, new ArrayList());

                if (anotaTMP == null) {
                    //La anotación NO tiene actualizaciones
                    rta.add(anota);
                } else {
                    //LA anotación TIENE actualizaciones por aplicar
                    this.makeTransientAnotacionTMP(anotaTMP, pm,
                            new ArrayList());
                    AnotacionEnhanced an = this.getAnotacionDefinitivaConDeltasAplicados(
                            anota, anotaTMP);
                    rta.add(an);
                }

            }

            query.closeAll();

            //Se obtienen las anotaciones temporales que son inválidas
            query = pm.newQuery(AnotacionTMP.class);
            query.declareParameters("FolioEnhanced datos, String invalida");
            query.declareVariables("AnotacionEnhanced anota");
            query.setFilter("this.folio==datos &&\n"
                    + "this.estado.idEstadoAn==invalida "
                    + //No contar las anotaciones temporales creadas para actualizar definitivas
                    " && !(anota.folio==datos \n"
                    + " && anota.idAnotacion==this.idAnotacionTmp)");

            col = (Collection) query.execute(datos, invalida);

            for (Iterator iter = col.iterator(); iter.hasNext();) {
                anotaTMP = (AnotacionTMP) iter.next();
                this.makeTransientAnotacionTMP(anotaTMP, pm, new ArrayList());
                rta.add(anotaTMP.getDefinitivo(new ArrayList()));
            }

            query.closeAll();
        } catch (JDOObjectNotFoundException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        return TransferUtils.makeTransferAll(rta);
    }

    /**
     * Retorna la lista de las anotaciones inválidas en un folio Si el folio no
     * tiene anotaciones inválidas retorna una lista vacia
     *
     * @param oid
     * @return
     * @throws Throwable
     */
    public List getAnotacionesInvalidas(FolioPk oid)
            throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        AnotacionEnhanced anota;
        AnotacionTMP anotaTMP;
        List rta = new ArrayList();
        FolioEnhanced datos;

        try {
            datos = this.getFolioByID(new FolioEnhancedPk(oid), pm);

            if (datos == null) {
                throw new DAOException("El folio especificado no existe");
            }

            //Se obtiene las anotaciones definitivas que tengan salvedades
            String invalida = CEstadoAnotacion.INVALIDO;
            Query query = pm.newQuery(AnotacionEnhanced.class);
            query.declareParameters("FolioEnhanced datos, String invalida");
            query.setFilter("this.folio==datos &&\n"
                    + "this.estado.idEstadoAn==invalida && (this.link==null || this.link==false)");

            Collection col = (Collection) query.execute(datos, invalida);

            for (Iterator iter = col.iterator(); iter.hasNext();) {
                anota = (AnotacionEnhanced) iter.next();
                this.makeTransientAnotacion(anota, pm, new ArrayList());
                rta.add(anota);
            }

            query.closeAll();
        } catch (JDOObjectNotFoundException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        return TransferUtils.makeTransferAll(rta);
    }

    /**
     * Metodo que reordena las anotaciones temporales que tengan orden mayor a
     * la anotacion que se va a eliminar
     *
     * @param fol
     * @param anotacion
     * @param pm
     * @return
     * @throws DAOException
     */
    protected boolean reordenarAnotacionesTemporales(FolioEnhanced fol,
            AnotacionTMP anotacion, PersistenceManager pm)
            throws DAOException {
        boolean rta = true;
        String idDoc = null;
        AnotacionTMP anotaciontmp;
        long orden;

        try {
            String ordenLPADEliminada = anotacion.getOrdenLPAD();
            //*String obsoleto = CEstadoAnotacion.OBSOLETA;
            String idNatJuridica = anotacion.getNaturalezaJuridica()
                    .getIdNaturalezaJuridica();
            Query query = pm.newQuery(AnotacionTMP.class);

            //El query debe tener en cuenta lo que hay en cache
            query.setIgnoreCache(false);
            query.declareParameters(
                    "FolioEnhanced fol, String ordenLPADEliminada");
            query.setFilter("this.folio==fol &&\n"
                    + "this.ordenLPAD>ordenLPADEliminada");

            Collection col = (Collection) query.execute(fol, ordenLPADEliminada);

            for (Iterator iter = col.iterator(); iter.hasNext();) {
                anotaciontmp = (AnotacionTMP) iter.next();
                orden = Long.parseLong(anotaciontmp.getOrden());
                orden = orden - 1;
                anotaciontmp.setOrden(String.valueOf(orden));
                String ordenPad = lpadFuncion(String.valueOf(orden), "0", 6);
                anotaciontmp.setOrdenLPAD(ordenPad);
            }
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        }

        return rta;
    }

    public String lpadFuncion(String orden, String caracter, int size) {
        int tamOrden = orden.length();
        for (int i = tamOrden; i < size; i++) {
            orden = caracter + orden;
        }
        return orden;
    }

    /**
     * Retorna la dirección con Mayor ID, de manera trasiente y sin dependencias
     *
     * @param direcciones
     * @return
     */
    protected DireccionEnhanced getUltimaDireccion(FolioEnhancedPk fid,
            PersistenceManager pm) throws DAOException {
        VersantPersistenceManager jdoPM = (VersantPersistenceManager) pm;
        DireccionEnhanced rta = null;
        Connection connection = null;
        PreparedStatement ps = null;
        ResultSet rs = null;
        boolean txInterna = false;

        try {
            if (!jdoPM.currentTransaction().isActive()) {
                txInterna = true;
            }

            if (txInterna) {
                jdoPM.currentTransaction().begin();
            }

            connection = jdoPM.getJdbcConnection(null);

            String consulta
                    = "select dir2.drcc_especificacion, dir2.id_direccion "
                    + "from sir_ne_direccion dir2 "
                    + "where dir2.id_matricula= ? and "
                    + "dir2.id_direccion = ( "
                    + "select to_char(max(to_number(dir.id_direccion))) "
                    + "from sir_ne_direccion dir "
                    + "where dir.id_matricula=dir2.id_matricula)";

            ps = connection.prepareStatement(consulta);
            ps.setString(1, fid.idMatricula);

            rs = ps.executeQuery();

            if (rs.next()) {
                rta = new DireccionEnhanced();
                rta.setIdMatricula(fid.idMatricula);
                rta.setEspecificacion(rs.getString(1));
                rta.setIdDireccion(rs.getString(2));
            }

            if (txInterna) {
                jdoPM.currentTransaction().commit();
            }
        } catch (SQLException e) {
            if (txInterna) {
                jdoPM.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        } catch (JDOException e) {
            if (txInterna) {
                jdoPM.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        } catch (Throwable e) {
            if (txInterna) {
                jdoPM.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        } finally {
            try {
                if (rs != null) {
                    rs.close();
                }
                if (ps != null) {
                    ps.close();
                }
                if (connection != null) {
                    connection.close();
                }

            } catch (SQLException e) {
            }
        }

        return rta;
    }

    /**
     * Retorna la lista con las anotaciones de los folios hijos del folio
     * especificado, cada anotacion tiene el objeto folio asociado y la última
     * direccion en la lista de direcciones de este folio Si el folio no tiene
     * hijos o no existe retorna una lista vacía
     *
     * @param oid
     * @return
     * @throws DAOException
     */
    public List getFolioHijosEnAnotacionesConDireccion(FolioPk oid)
            throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        FolioDerivadoEnhanced fd;
        List rta = new ArrayList();
        AnotacionEnhanced aux = new AnotacionEnhanced();

        try {
            pm.currentTransaction().begin();

            String matriculaPadre = oid.idMatricula;

            Query query = pm.newQuery(FolioDerivadoEnhanced.class);
            query.setOrdering("this.hijo.folio.ordenLPAD ascending");
            query.declareParameters("String matriculaPadre");
            query.setFilter("this.padre.folio.idMatricula== matriculaPadre");

            Collection col = (Collection) query.execute(matriculaPadre);

            DireccionEnhanced lastDireccion = null;

            FolioEnhanced folioAux;
            DireccionEnhanced dirAux;

            for (Iterator iter = col.iterator(); iter.hasNext();) {
                fd = (FolioDerivadoEnhanced) iter.next();
                aux = fd.getPadre();
                pm.makeTransient(aux);

                folioAux = new FolioEnhanced();
                folioAux.setIdMatricula(fd.getIdMatricula1());
                FolioEnhancedPk fid = new FolioEnhancedPk();
                fid.idMatricula = fd.getIdMatricula1();
                lastDireccion = this.getUltimaDireccion(fid, pm);

                if (lastDireccion != null) {
                    folioAux.addDireccione(lastDireccion);
                }

                aux.setFolio(folioAux);
                rta.add(aux);
            }

            query.closeAll();
        } catch (JDOObjectNotFoundException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (Exception e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().commit();
            }

            pm.close();
        }

        return TransferUtils.makeTransferAll(rta);
    }

    /**
     * Retorna la lista con las anotaciones de los folios hijos del folio
     * especificado, cada anotacion tiene el objeto folio asociado y la última
     * direccion en la lista de direcciones de este folio Se ordena por las
     * anotaciones. Si el folio no tiene hijos o no existe retorna una lista
     * vacía
     *
     * @param oid
     * @return
     * @throws DAOException
     */
    public List getFolioHijosEnAnotacionesConDireccionOrdenadoAnotaciones(FolioPk oid)
            throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        FolioDerivadoEnhanced fd;
        List rta = new ArrayList();
        AnotacionEnhanced aux = new AnotacionEnhanced();

        try {
            pm.currentTransaction().begin();

            String matriculaPadre = oid.idMatricula;

            Query query = pm.newQuery(FolioDerivadoEnhanced.class);
            query.setOrdering("this.padre.ordenLPAD ascending, this.hijo.folio.ordenLPAD ascending");
            query.declareParameters("String matriculaPadre");
            query.setFilter("this.padre.folio.idMatricula== matriculaPadre");

            Collection col = (Collection) query.execute(matriculaPadre);

            DireccionEnhanced lastDireccion = null;

            FolioEnhanced folioAux;
            DireccionEnhanced dirAux;

            for (Iterator iter = col.iterator(); iter.hasNext();) {
                fd = (FolioDerivadoEnhanced) iter.next();
                aux = fd.getPadre();
                pm.makeTransient(aux);

                folioAux = new FolioEnhanced();
                folioAux.setIdMatricula(fd.getIdMatricula1());

                FolioEnhancedPk fid = new FolioEnhancedPk();
                fid.idMatricula = fd.getIdMatricula1();
                lastDireccion = this.getUltimaDireccion(fid, pm);

                if (lastDireccion != null) {
                    folioAux.addDireccione(lastDireccion);
                }

                aux.setFolio(folioAux);
                rta.add(aux);
            }

            query.closeAll();
        } catch (JDOObjectNotFoundException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (Exception e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().commit();
            }

            pm.close();
        }

        return TransferUtils.makeTransferAll(rta);
    }

    /**
     * Retorna la información temporal del folio que se encuentra lista para
     * hacerse definitiva. En los datos del folio retornado sólo van los cambios
     * que se están aplicando: A nivel de Folio: codCatastral
     * codCatastralAnterior estado lindero tipoPredio complementacion
     *
     * A nivel de Direcciones de folio, van las nuevas direcciones
     *
     * A nivel de Salvedades de folio, van las nuevas salvedades
     *
     * A nivel de Anotaciones, van las nuevas anotaciones y las anotaciones
     * definitivas a las cuales se está aplicando algún cambio:
     *
     * Si el flag de anotacion temporal es true, la anotación está siendo
     * insertada, todos los datos de esta anotación son nuevos.
     *
     * Si el flag de anotación temporal es false, la anotación corresponde a los
     * cambios de una anotación definitiva, es decir, los campos diferentes de
     * null corresponden a los cambios aplicados:
     *
     * comentario especificacion estado orden tipoAnotacion naturalezaJuridica
     * toUpdateValor == true : valor
     *
     * Lista de anotaciones ciudadano: Si el flag toDelete es true, la
     * anotacionCiudadano correspondiente está marcada para eliminación Si el
     * flag toDelete es false, la anotacionCiudadano correspondiente está
     * marcada para inserción
     *
     * Lista de salvedades de anotación: Si el flag toDelete es true, la
     * salvedad correspondiente está marcada para eliminación Si el flag
     * toDelete es false, la salvedad correspondiente está marcada para
     * inserción o actualización. Si el idSalvedad está seteado la salvedad es
     * una actualización de una definitiva, si el idSalvedad no está seteado, es
     * una nueva salvedad de la anotación
     *
     *
     * @param oid
     * @param us
     * @return
     * @throws DAOException
     */
    public Folio getDeltaFolio(FolioPk oid, Usuario usuario)
            throws DAOException {
        FolioEnhanced datos = null;
        Folio aux = null;
        PersistenceManager pm = AdministradorPM.getPM();

        try {
            datos = this.getFolioByID(new FolioEnhancedPk(oid), pm);

            if (datos == null) {
                throw new DAOException("El folio especificado no existe");
            }

            //validamos el bloqueo del folio
            if (usuario != null) {
                this.validarBloqueoFolio(datos, usuario, pm);
            }

            //Una vez realizadas las validaciones se procede a obtener
            //la información del folio definitiva y temporal:
            aux = this.getDeltaFolio(datos, pm);

            if (aux == null) {
                aux = new Folio();
                aux.setIdMatricula(datos.getIdMatricula());
            }
        } catch (DAOException e) {
            throw e;
        } catch (Exception e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e);
        } finally {
            pm.close();
        }

        return aux;
    }

    /**
     * Organiza la información temporal, sólo devuelve los cambios que están
     * siendo aplicados al folio, si el folio no tienen ningún cambio retorna
     * null
     *
     * @param f Folio persistente con información temporal y definitiva
     * @return
     * @throws DAOException
     */
    private Folio getDeltaFolio(FolioEnhanced folio, PersistenceManager pm)
            throws DAOException {
        try {
            //Setemos el flag que indica si el folio tiene deltas
            boolean tieneDeltas = false;

            //Creamos un folio trasiente para setear sólo los deltas y los identificadores
            FolioEnhanced rta = new FolioEnhanced();

            //Seteamos los identificadores de folio
            rta.setIdMatricula(folio.getIdMatricula());

            //Se cambia la información temporal básica del folio si se requiere
            FolioDatosTMP fTMP;

            try {
                fTMP = folio.getDatosTMP();
            } catch (JDOObjectNotFoundException e) {
                fTMP = null;
            }

            if (fTMP != null) {
                tieneDeltas = true;

                if (fTMP.getNupre() != null) {
                    rta.setNupre(fTMP.getNupre());
                }

                if (fTMP.getDeterminaInm() != null) {
                    rta.setDeterminaInm(fTMP.getDeterminaInm());
                }

                if (fTMP.getPrivMetros() != null) {
                    rta.setPrivMetros(fTMP.getPrivMetros());
                }

                if (fTMP.getPrivCentimetros() != null) {
                    rta.setPrivCentimetros(fTMP.getPrivCentimetros());
                }

                if (fTMP.getConsMetros() != null) {
                    rta.setConsMetros(fTMP.getConsMetros());
                }

                if (fTMP.getConsCentimetros() != null) {
                    rta.setConsCentimetros(fTMP.getConsCentimetros());
                }

                if (fTMP.getCoeficiente() != null) {
                    rta.setCoeficiente(fTMP.getCoeficiente());
                }

                if (fTMP.getHectareas() != null) {
                    rta.setHectareas(fTMP.getHectareas());
                }

                if (fTMP.getMetros() != null) {
                    rta.setMetros(fTMP.getMetros());
                }

                if (fTMP.getCentimetros() != null) {
                    rta.setCentimetros(fTMP.getCentimetros());
                }

                if (fTMP.getLindero() != null) {
                    rta.setLindero(fTMP.getLindero());
                }

                if (fTMP.getCodCatastral() != null) {
                    rta.setCodCatastral(fTMP.getCodCatastral());
                }

                if (fTMP.getCodCatastralAnterior() != null) {
                    rta.setCodCatastralAnterior(fTMP.getCodCatastralAnterior());
                }

                // bug: 3580
                if (fTMP.getRadicacion() != null) {
                    // pm.makeTransient( folio.getRadicacion() );
                    rta.setRadicacion(fTMP.getRadicacion());
                }

                if (fTMP.getFechaApertura() != null) {
                    // pm.makeTransient(folio.getFechaApertura());
                    rta.setFechaApertura(fTMP.getFechaApertura());
                }

                if (fTMP.getEstado() != null) {
                    pm.makeTransient(fTMP.getEstado());
                    rta.setEstado(fTMP.getEstado());
                }

                if (fTMP.getTipoPredio() != null) {
                    pm.makeTransient(fTMP.getTipoPredio());
                    rta.setTipoPredio(fTMP.getTipoPredio());
                }

                if (fTMP.getZonaRegistral() != null) {
                    this.makeTransientZonaRegistral(fTMP.getZonaRegistral(), pm);
                    rta.setZonaRegistral(fTMP.getZonaRegistral());
                }
            }

            //Se setea la complementación si existe una temporal
            if (folio.getComplementacionTMP() != null) {
                tieneDeltas = true;
                pm.makeTransient(folio.getComplementacionTMP());
                rta.setComplementacion(folio.getComplementacionTMP()
                        .getDefinitivo());

            }

            //Se setea el documento si existe uno temporal
            if (folio.getDocumentoTMP() != null) {
                tieneDeltas = true;
                this.makeTransientDocumentoTMP(folio.getDocumentoTMP(), pm);
                rta.setDocumento(folio.getDocumentoTMP().getDefinitivo());
            }

            //Se agregan las direcciones temporales:
            List direccionesTMP = folio.getDireccionesTMPs();
            DireccionTMP dir;

            for (Iterator it = direccionesTMP.iterator(); it.hasNext();) {
                tieneDeltas = true;
                dir = (DireccionTMP) it.next();
                this.makeTransientDireccionTMP(dir, pm);
                rta.addDireccione(dir.getDefinitivo());
            }

            //Se agregan las salvedades temporales:
            List salvedadesTMP = folio.getSalvedadesTMPs();
            SalvedadFolioTMP sal;

            for (Iterator it = salvedadesTMP.iterator(); it.hasNext();) {
                tieneDeltas = true;
                sal = (SalvedadFolioTMP) it.next();
                this.makeTransientSalvedadFolioTMP(sal, pm);
                rta.addSalvedade(sal.getDefinitivo());
            }

            //Se agregan las anotaciones temporales:
            List anotacionesTMP = folio.getAnotacionesTMPs();
            AnotacionTMP anota;
            List cache;
            Anotacion anotaAux;
            AnotacionEnhanced anotaToInsert;

            for (Iterator it = anotacionesTMP.iterator(); it.hasNext();) {
                tieneDeltas = true;
                anota = (AnotacionTMP) it.next();

                //Si la anotación temporal NO es anotación de auditoría
                //*if (!anota.getEstado().getIdEstadoAn().equals(CEstadoAnotacion.OBSOLETA)) {
                //Se verifica si la anotación corresponde a una adición
                //o está modificando una anotación definitiva:
                AnotacionEnhancedPk anID = new AnotacionEnhancedPk();
                anID.idAnotacion = anota.getIdAnotacionTmp();
                anID.idMatricula = anota.getIdMatricula();

                AnotacionEnhanced anotaVal = this.getAnotacionByID(anID, pm);

                if (anotaVal == null) {
                    //La anotación temporal está configurada para insertarse
                    this.makeTransientAnotacionTMP(anota, pm,
                            new ArrayList());
                    anotaToInsert = anota.getDefinitivo(new ArrayList());
                    anotaToInsert.setTemporal(true);
                } else {
                    //La anotacion temporal representa una actualización a la anotación
                    //definitiva
                    anotaToInsert = new AnotacionEnhanced();

                    //Seteamos el identificador:
                    anotaToInsert.setIdAnotacion(anotaVal.getIdAnotacion());
                    anotaToInsert.setIdMatricula(anotaVal.getIdMatricula());

                    if (anota.getEstado() != null) {
                        if (anotaVal.getEstado() != null) {
                            if (!anota.getEstado().getIdEstadoAn().equals(anotaVal.getEstado()
                                    .getIdEstadoAn())) {
                                pm.makeTransient(anota.getEstado());
                                anotaToInsert.setEstado(anota.getEstado());
                            }
                        } else {
                            throw new DAOException("La anotacion temporal a validar no posee un estado");
                        }
                    } else {
                        throw new DAOException("La anotacion temporal no posee un estado");
                    }

                    if (!anota.getNaturalezaJuridica()
                            .getIdNaturalezaJuridica().equals(anotaVal.getNaturalezaJuridica()
                                    .getIdNaturalezaJuridica())) {
                        pm.makeTransient(anota.getNaturalezaJuridica());
                        anotaToInsert.setNaturalezaJuridica(anota.getNaturalezaJuridica());
                    }

                    if (!anota.getTipoAnotacion().getIdTipoAnotacion()
                            .equals(anotaVal.getTipoAnotacion()
                                    .getIdTipoAnotacion())) {
                        pm.makeTransient(anota.getTipoAnotacion());
                        anotaToInsert.setTipoAnotacion(anota.getTipoAnotacion());
                    }

                    if (anota.getOrden() != null) {

                        if (!(anota.getOrden().equals(anotaVal.getOrden()))) {
                            anotaToInsert.setOrden(anota.getOrden());
                        }

                    }

                    // anota.getOrden();
                    // bug 3543
                    //Se setea el orden siempre para identificarla
                    // anotaToInsert.setOrden(anotaVal.getOrden());
                    if (anota.getEspecificacion() != null) {
                        anotaToInsert.setEspecificacion(anota.getEspecificacion());
                    }

                    if (anota.getComentario() != null) {
                        anotaToInsert.setComentario(anota.getComentario());
                    }

                    // bug 0003557
                    if (anota.getNumRadicacion() != null) {
                        anotaToInsert.setNumRadicacion(anota.getNumRadicacion());
                    }

                    //Se setea el documento si existe uno temporal
                    if (anota.getDocumentoTMP() != null) {
                        anotaToInsert.setDocumento(anota.getDocumentoTMP().getDefinitivo());
                    }

                    /*
                        if (anota.getValor() != anotaVal.getValor()) {
                            anotaToInsert.setValor(anota.getValor());
                            anotaToInsert.setToUpdateValor(true);
                        }*/
                    anotaToInsert.setValor(anota.getValor());

                    //Miramos los ciudadanos de la anotacion que se deben,
                    //insertar o borrar
                    AnotacionCiudadanoTMP anCiudAux;

                    for (Iterator it2 = anota.getAnotacionesCiudadanoTMPs()
                            .iterator(); it2.hasNext();) {
                        anCiudAux = (AnotacionCiudadanoTMP) it2.next();
                        this.makeTransientAnotacionCiudadanoTMP(anCiudAux,
                                pm);

                        if (anCiudAux.isToDelete()) {
                            anCiudAux.setToDelete(true);
                        } else {
                            anCiudAux.setToDelete(false);
                        }
                        //HAGR500 REVISAR ESTE METODO QUE ES POSIBLE QUE ALTERE EL ORDEN DE LOS CIUDADANOS
                        anotaToInsert.addAnotacionesCiudadano(anCiudAux.getDefinitivo());
                    }

                    //Miramos las salvedades de la anotacion que se deben,
                    //insertar o borrar
                    SalvedadAnotacionTMP salAux;

                    for (Iterator it2 = anota.getSalvedadesTMPs().iterator();
                            it2.hasNext();) {
                        salAux = (SalvedadAnotacionTMP) it2.next();
                        this.makeTransientSalvedadAnotacionTMP(salAux, pm);

                        if (salAux.isToDelete()) {
                            salAux.setToDelete(true);
                        } else {
                            //Miramos si la salvedad es de actualización
                            SalvedadAnotacionEnhancedPk salID = new SalvedadAnotacionEnhancedPk();
                            salID.idSalvedad = salAux.getIdSalvedadAnTmp();
                            salID.idAnotacion = salAux.getIdAnotacionTmp();
                            salID.idMatricula = salAux.getIdMatricula();

                            SalvedadAnotacionEnhanced salVal = this.getSalvedadAnotacion(salID,
                                    pm);
                            /*
                                if (salVal == null) {
                                    salAux.setIdSalvedadAnTmp(null);
                                }*/

                            salAux.setToDelete(false);
                        }

                        anotaToInsert.addSalvedade(salAux.getDefinitivo());
                    }
                }

                rta.addAnotacione(anotaToInsert);
                //*}
            }

            Folio tFolio = null;

            if (tieneDeltas) {
                tFolio = (Folio) rta.toTransferObject();
            }
            return tFolio;
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        }
    }

    /**
     * Obtiene los datos definitivos de los datos temporales que estén
     * modificando al folio
     *
     * @param oid
     * @param usuario
     * @return
     * @throws DAOException
     */
    public Folio getDatosDefinitivosDeDatosTemporales(FolioPk oid,
            Usuario usuario) throws DAOException {
        FolioEnhanced datos = null;
        Folio aux = null;
        PersistenceManager pm = AdministradorPM.getPM();

        try {
            datos = this.getFolioByID(new FolioEnhancedPk(oid), pm);

            if (datos == null) {
                throw new DAOException("El folio especificado no existe");
            }

            //validamos el bloqueo del folio
            if (usuario != null) {
                this.validarBloqueoFolio(datos, usuario, pm);
            }

            //Una vez realizadas las validaciones se procede a obtener
            //la información del folio definitiva de temporal:
            aux = this.getDatosDefinitivosDeDatosTemporales(datos, pm);
        } catch (DAOException e) {
            throw e;
        } catch (Exception e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e);
        } finally {
            pm.close();
        }

        return aux;
    }

    /**
     * Obtiene los datos definitivos de los datos temporales que estén
     * modificando al folio
     *
     * @param folio
     * @param pm
     * @return
     * @throws DAOException
     */
    private Folio getDatosDefinitivosDeDatosTemporales(FolioEnhanced folio,
            PersistenceManager pm) throws DAOException {
        try {
            //Creamos un folio trasiente para setear sólo los datos definitivos
            //de los temporales y los identificadores
            FolioEnhanced rta = new FolioEnhanced();

            //Seteamos los identificadores de folio
            rta.setIdMatricula(folio.getIdMatricula());

            //Se cambia la información temporal básica del folio si se requiere
            FolioDatosTMP fTMP;

            try {
                fTMP = folio.getDatosTMP();
            } catch (JDOObjectNotFoundException e) {
                fTMP = null;
            }

            if (fTMP != null) {

                if (fTMP.getNupre() != null) {
                    rta.setNupre(folio.getNupre());
                }

                if (fTMP.getDeterminaInm() != null) {
                    rta.setDeterminaInm(folio.getDeterminaInm());
                }

                if (fTMP.getPrivMetros() != null) {
                    rta.setPrivMetros(folio.getPrivMetros());
                }

                if (fTMP.getPrivCentimetros() != null) {
                    rta.setPrivCentimetros(folio.getPrivCentimetros());
                }

                if (fTMP.getConsMetros() != null) {
                    rta.setConsMetros(folio.getConsMetros());
                }

                if (fTMP.getConsCentimetros() != null) {
                    rta.setConsCentimetros(folio.getConsCentimetros());
                }

                if (fTMP.getCoeficiente() != null) {
                    rta.setCoeficiente(folio.getCoeficiente());
                }

                if (fTMP.getHectareas() != null) {
                    rta.setHectareas(folio.getHectareas());
                }

                if (fTMP.getMetros() != null) {
                    rta.setMetros(folio.getMetros());
                }

                if (fTMP.getCentimetros() != null) {
                    rta.setCentimetros(folio.getCentimetros());
                }

                if (fTMP.getLindero() != null) {
                    rta.setLindero(folio.getLindero());
                }

                if (fTMP.getCodCatastral() != null) {
                    rta.setCodCatastral(folio.getCodCatastral());
                }

                if (fTMP.getCodCatastralAnterior() != null) {
                    rta.setCodCatastralAnterior(folio.getCodCatastralAnterior());
                }

                if (fTMP.getEstado() != null) {
                    pm.makeTransient(folio.getEstado());
                    rta.setEstado(folio.getEstado());
                }

                // bug: 3580
                if (fTMP.getRadicacion() != null) {
                    // pm.makeTransient( folio.getRadicacion() );
                    rta.setRadicacion(folio.getRadicacion());
                }

                if (fTMP.getFechaApertura() != null) {
                    // pm.makeTransient(folio.getFechaApertura());
                    rta.setFechaApertura(folio.getFechaApertura());
                }

                if (fTMP.getZonaRegistral() != null) {
                    Log.getInstance().debug(JDOGenieFolioDAO.class, "ZonaRegistral");
                    rta.setZonaRegistral(folio.getZonaRegistral());
                }
            }

            //Se setea la complementación si existe una temporal
            if (folio.getComplementacionTMP() != null) {
                pm.makeTransient(folio.getComplementacion());
                rta.setComplementacion(folio.getComplementacion());
            }

            //Se setea el documento si existe uno temporal
            if (folio.getDocumentoTMP() != null) {
                this.makeTransientDocumento(folio.getDocumento(), pm);
                rta.setDocumento(folio.getDocumento());
            }

            //Se agregan las anotaciones temporales que estén modificando
            //definitivas:
            List anotacionesTMP = folio.getAnotacionesTMPs();
            AnotacionTMP anota;
            List cache;
            Anotacion anotaAux;
            AnotacionEnhanced anotaToInsert;

            for (Iterator it = anotacionesTMP.iterator(); it.hasNext();) {
                anota = (AnotacionTMP) it.next();

                //Si la anotación temporal NO es anotación de auditoría
                //*if (!anota.getEstado().getIdEstadoAn().equals(CEstadoAnotacion.OBSOLETA)) {
                //Se verifica si la anotación corresponde a una adición
                //o está modificando una anotación definitiva:
                AnotacionEnhancedPk anID = new AnotacionEnhancedPk();
                anID.idAnotacion = anota.getIdAnotacionTmp();
                anID.idMatricula = anota.getIdMatricula();

                AnotacionEnhanced anotaVal = this.getAnotacionByID(anID, pm);

                if (anotaVal != null) {
                    //La anotacion temporal representa una actualización a la anotación
                    //definitiva
                    this.makeTransientAnotacion(anotaVal, pm,
                            new ArrayList());
                    rta.addAnotacione(anotaVal);
                }
                //*}
            }

            return (Folio) rta.toTransferObject();
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        }
    }

    /**
     * Cuenta el número total de anotaciones que tiene un folio incluyendo las
     * anotaciones temporales
     *
     * @param oid
     * @param criterio
     * @param valor
     * @param usuario
     * @return
     * @throws DAOException
     */
    public long getCountAnotacionesFolio(FolioPk oid, String criterio,
            String valor, Usuario usuario) throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        long rta = 0;
        UsuarioEnhanced us;

        try {
            FolioEnhanced fol = this.getFolioByID(new FolioEnhancedPk(oid), pm);

            if (fol == null) {
                throw new DAOException(
                        "El folio especificado no existe. Matricula: "
                        + oid.idMatricula);
            }

            //validamos el bloqueo del folio
            if (usuario != null) {
                this.validarBloqueoFolio(fol, usuario, pm);
            }

            if (criterio == null) {
                throw new DAOException("Se debe especificar un criterio");
            }

            //Se debe buscar por algún criterio las anotaciones
            pm.currentTransaction().begin();

            VersantQuery query = (VersantQuery) pm.newQuery(AnotacionEnhanced.class);
            query.declareParameters("String parametro, FolioEnhanced fol");

            String filtro = "this.folio==fol && (this.link==null || this.link==false)";
            //*String filtro = "this.folio==fol && this.estado.idEstadoAn!='" +
            //*CEstadoAnotacion.OBSOLETA + "' && (this.link==null || this.link==false)";            

            if (criterio.equals(CCriterio.POR_NAT_JURIDICA)) {
                filtro = filtro
                        + " && this.naturalezaJuridica.idNaturalezaJuridica==parametro";
            } else if (criterio.equals(CCriterio.POR_GRUPO_NAT_JURIDICA)) {
                filtro = filtro
                        + " && this.naturalezaJuridica.grupoNaturalezaJuridica.idGrupoNatJuridica==parametro";
            } else if (criterio.equals(CCriterio.POR_ORDEN)) {
                filtro = filtro + " && this.orden==parametro";
            } else if (criterio.equals(CCriterio.POR_TIPO_ANOTACION)) {
                filtro = filtro
                        + " && this.tipoAnotacion.idTipoAnotacion==parametro";
            } else if (!criterio.equals(CCriterio.TODAS_LAS_ANOTACIONES)) {
                throw new DAOException("Criterio invalido: " + criterio);
            }

            query.setFilter(filtro);
            query.setResult("count(this)");
            rta = ((Long) query.execute(valor, fol)).longValue();

            query = (VersantQuery) pm.newQuery(AnotacionTMP.class);
            query.declareParameters("String parametro, FolioEnhanced fol");
            query.declareVariables("AnotacionEnhanced anota");
            filtro = "this.folio==fol ";
            //*filtro = "this.folio==fol && this.estado.idEstadoAn!='" +
            //*CEstadoAnotacion.OBSOLETA + "' ";

            if (criterio.equals(CCriterio.POR_NAT_JURIDICA)) {
                filtro = filtro
                        + " && this.naturalezaJuridica.idNaturalezaJuridica==parametro";
            } else if (criterio.equals(CCriterio.POR_GRUPO_NAT_JURIDICA)) {
                filtro = filtro
                        + " && this.naturalezaJuridica.grupoNaturalezaJuridica.idGrupoNatJuridica==parametro";
            } else if (criterio.equals(CCriterio.POR_ORDEN)) {
                filtro = filtro + " && this.orden==parametro";
            } else if (criterio.equals(CCriterio.POR_TIPO_ANOTACION)) {
                filtro = filtro
                        + " && this.tipoAnotacion.idTipoAnotacion==parametro";
            } else if (!criterio.equals(CCriterio.TODAS_LAS_ANOTACIONES)) {
                throw new DAOException("Criterio invalido: " + criterio);
            }

            //No contar las anotaciones temporales creadas para actualizar definitivas
            if (!(valor != null && (valor.equals(CNaturalezaJuridica.LOTEO) || valor.equals(CNaturalezaJuridica.RELOTEO)))) {
                filtro = filtro + "&& !(anota.folio==fol \n"
                        + "&& anota.idAnotacion==this.idAnotacionTmp)";
            }

            query.setFilter(filtro);
            query.setResult("count(this)");

            long countTMP = ((Long) query.execute(valor, fol)).longValue();

            rta = rta + countTMP;
        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (DAOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw e;
        } catch (Exception e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().commit();
            }

            pm.close();
        }

        return rta;
    }

    /**
     * @author : Henry Gómez Rocha
     * @change : Evita que al momento de pasar del role Calificador al role
     * Digitador se verifique el usuario que tiene el bloqueo.. Caso Mantis :
     * 0004967 Cuenta el número total de anotaciones que tiene un folio
     * incluyendo las anotaciones temporales
     * @param oid
     * @param criterio
     * @param valor
     * @param usuario
     * @return
     * @throws DAOException
     */
    public long getCountAnotacionesFolio(FolioPk oid, String criterio,
            String valor, Usuario usuario, boolean validarTurno) throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        long rta = 0;
        UsuarioEnhanced us;

        try {
            FolioEnhanced fol = this.getFolioByID(new FolioEnhancedPk(oid), pm);

            if (fol == null) {
                throw new DAOException(
                        "El folio especificado no existe. Matricula: "
                        + oid.idMatricula);
            }

            //validamos el bloqueo del folio
            if (usuario != null && validarTurno) {
                this.validarBloqueoFolio(fol, usuario, pm);
            }

            if (criterio == null) {
                throw new DAOException("Se debe especificar un criterio");
            }

            //Se debe buscar por algún criterio las anotaciones
            pm.currentTransaction().begin();

            VersantQuery query = (VersantQuery) pm.newQuery(AnotacionEnhanced.class);
            query.declareParameters("String parametro, FolioEnhanced fol");

            String filtro = "this.folio==fol && (this.link==null || this.link==false)";
            //*String filtro = "this.folio==fol && this.estado.idEstadoAn!='" +
            //*CEstadoAnotacion.OBSOLETA + "' && (this.link==null || this.link==false)";

            if (criterio.equals(CCriterio.POR_NAT_JURIDICA)) {
                filtro = filtro
                        + " && this.naturalezaJuridica.idNaturalezaJuridica==parametro";
            } else if (criterio.equals(CCriterio.POR_GRUPO_NAT_JURIDICA)) {
                filtro = filtro
                        + " && this.naturalezaJuridica.grupoNaturalezaJuridica.idGrupoNatJuridica==parametro";
            } else if (criterio.equals(CCriterio.POR_ORDEN)) {
                filtro = filtro + " && this.orden==parametro";
            } else if (criterio.equals(CCriterio.POR_TIPO_ANOTACION)) {
                filtro = filtro
                        + " && this.tipoAnotacion.idTipoAnotacion==parametro";
            } else if (!criterio.equals(CCriterio.TODAS_LAS_ANOTACIONES)) {
                throw new DAOException("Criterio invalido: " + criterio);
            }

            query.setFilter(filtro);
            query.setResult("count(this)");
            rta = ((Long) query.execute(valor, fol)).longValue();

            query = (VersantQuery) pm.newQuery(AnotacionTMP.class);
            query.declareParameters("String parametro, FolioEnhanced fol");
            query.declareVariables("AnotacionEnhanced anota");
            filtro = "this.folio==fol ";
            //*filtro = "this.folio==fol && this.estado.idEstadoAn!='" +
            //*CEstadoAnotacion.OBSOLETA + "' ";

            if (criterio.equals(CCriterio.POR_NAT_JURIDICA)) {
                filtro = filtro
                        + " && this.naturalezaJuridica.idNaturalezaJuridica==parametro";
            } else if (criterio.equals(CCriterio.POR_GRUPO_NAT_JURIDICA)) {
                filtro = filtro
                        + " && this.naturalezaJuridica.grupoNaturalezaJuridica.idGrupoNatJuridica==parametro";
            } else if (criterio.equals(CCriterio.POR_ORDEN)) {
                filtro = filtro + " && this.orden==parametro";
            } else if (criterio.equals(CCriterio.POR_TIPO_ANOTACION)) {
                filtro = filtro
                        + " && this.tipoAnotacion.idTipoAnotacion==parametro";
            } else if (!criterio.equals(CCriterio.TODAS_LAS_ANOTACIONES)) {
                throw new DAOException("Criterio invalido: " + criterio);
            }

            //No contar las anotaciones temporales creadas para actualizar definitivas
            if (!(valor != null && (valor.equals(CNaturalezaJuridica.LOTEO) || valor.equals(CNaturalezaJuridica.RELOTEO)))) {
                filtro = filtro + "&& !(anota.folio==fol \n"
                        + "&& anota.idAnotacion==this.idAnotacionTmp)";
            }

            query.setFilter(filtro);
            query.setResult("count(this)");

            long countTMP = ((Long) query.execute(valor, fol)).longValue();

            rta = rta + countTMP;
        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (DAOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw e;
        } catch (Exception e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().commit();
            }

            pm.close();
        }

        return rta;
    }

    /**
     * Obtiene una dirección persistente por su ID
     *
     * @param oid
     * @param pm
     * @return
     * @throws DAOException
     */
    protected DireccionEnhanced getDireccion(DireccionEnhancedPk oid,
            PersistenceManager pm) throws DAOException {
        DireccionEnhanced rta = null;

        if ((oid.idDireccion != null) && (oid.idMatricula != null)) {
            try {
                rta = (DireccionEnhanced) pm.getObjectById(oid, true);
            } catch (JDOObjectNotFoundException e) {
                rta = null;
            } catch (JDOException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                throw new DAOException(e.getMessage(), e);
            }
        }

        return rta;
    }

    /**
     *
     * @param oid
     * @param pm
     * @return
     * @throws DAOException
     */
    protected DireccionTMP getDireccionTMP(DireccionTMPPk oid,
            PersistenceManager pm) throws DAOException {
        DireccionTMP rta = null;

        if ((oid.idDireccionTmp != null) && (oid.idMatricula != null)) {
            try {
                rta = (DireccionTMP) pm.getObjectById(oid, true);
            } catch (JDOObjectNotFoundException e) {
                rta = null;
            } catch (JDOException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                throw new DAOException(e.getMessage(), e);
            }
        }

        return rta;
    }

    /**
     * Retorna las anotaciones temporales de un folio con el criterio dado.
     *
     * @param oid
     * @param criterio
     * @param valor
     * @param usuario
     * @return
     * @throws DAOException
     */
    public List getAnotacionesTMPFolioToInsert(FolioPk oid, String criterio,
            String valor, Usuario usuario) throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        List rta = new ArrayList();
        List res = new ArrayList();
        AnotacionEnhanced anota;

        try {
            FolioEnhanced fol = this.getFolioByID(new FolioEnhancedPk(oid), pm);

            if (fol == null) {
                throw new DAOException(
                        "El folio especificado no existe. Matricula: "
                        + oid.idMatricula);
            }

            if (criterio == null) {
                throw new DAOException("Se debe especificar un criterio");
            }

            //validamos el bloqueo del folio
            if (usuario != null) {
                this.validarBloqueoFolio(fol, usuario, pm);
            }

            //Se debe buscar por algún criterio las anotaciones
            pm.currentTransaction().begin();

            //Se debe buscar por algún criterio las anotaciones
            VersantQuery query = (VersantQuery) pm.newQuery(AnotacionTMP.class);
            query.setIgnoreCache(false);
            query.declareParameters("String parametro, FolioEnhanced fol");
            query.setOrdering("ordenLPAD ascending");
            query.declareVariables("AnotacionEnhanced anota");

            String filtro = "this.folio==fol ";
            //*String filtro = "this.folio==fol && this.estado.idEstadoAn!='" +
            //*CEstadoAnotacion.OBSOLETA + "' ";            

            //No contar las anotaciones temporales creadas para actualizar definitivas
            filtro = filtro + "&& !(anota.folio==fol \n"
                    + "&& anota.idAnotacion==this.idAnotacionTmp)";

            if (criterio.equals(CCriterio.POR_NAT_JURIDICA)) {
                filtro = filtro
                        + " && this.naturalezaJuridica.idNaturalezaJuridica==parametro";
            } else if (criterio.equals(CCriterio.POR_GRUPO_NAT_JURIDICA)) {
                filtro = filtro
                        + " && this.naturalezaJuridica.grupoNaturalezaJuridica.idGrupoNatJuridica==parametro";
            } else if (criterio.equals(CCriterio.POR_ORDEN)) {
                filtro = filtro + " && this.orden==parametro";
            } else if (criterio.equals(CCriterio.POR_TIPO_ANOTACION)) {
                filtro = filtro
                        + " && this.tipoAnotacion.idTipoAnotacion==parametro";
            } else if (!criterio.equals(CCriterio.TODAS_LAS_ANOTACIONES)) {
                throw new DAOException("Criterio invalido: " + criterio);
            }

            query.setFilter(filtro);
            res = (List) query.execute(valor, fol);

            AnotacionTMP anotaTMP;
            AnotacionEnhanced anotaAux;

            for (Iterator it = res.iterator(); it.hasNext();) {
                anotaTMP = (AnotacionTMP) it.next();
                this.makeTransientAnotacionTMP(anotaTMP, pm, new ArrayList());
                anotaAux = anotaTMP.getDefinitivo(new ArrayList());
                anotaAux.setTemporal(true);
                rta.add(anotaAux);
            }
        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (Exception e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().commit();
            }

            pm.close();
        }

        return TransferUtils.makeTransferAll(rta);
    }

    /**
     * @author : Henry Gómez Rocha
     * @change : Evita que al momento de pasar del role Calificador al role
     * Digitador se verifique el usuario que tiene el bloqueo.. Caso Mantis :
     * 0004967 Retorna las anotaciones temporales de un folio con el criterio
     * dado.
     * @param oid
     * @param criterio
     * @param valor
     * @param usuario
     * @return
     * @throws DAOException
     */
    public List getAnotacionesTMPFolioToInsert(FolioPk oid, String criterio,
            String valor, Usuario usuario, boolean validarTurno) throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        List rta = new ArrayList();
        List res = new ArrayList();
        AnotacionEnhanced anota;

        try {
            FolioEnhanced fol = this.getFolioByID(new FolioEnhancedPk(oid), pm);

            if (fol == null) {
                throw new DAOException(
                        "El folio especificado no existe. Matricula: "
                        + oid.idMatricula);
            }

            if (criterio == null) {
                throw new DAOException("Se debe especificar un criterio");
            }

            //validamos el bloqueo del folio
            if (usuario != null && validarTurno) {
                this.validarBloqueoFolio(fol, usuario, pm);
            }

            //Se debe buscar por algún criterio las anotaciones
            pm.currentTransaction().begin();

            //Se debe buscar por algún criterio las anotaciones
            VersantQuery query = (VersantQuery) pm.newQuery(AnotacionTMP.class);
            query.setIgnoreCache(false);
            query.declareParameters("String parametro, FolioEnhanced fol");
            query.setOrdering("ordenLPAD ascending");
            query.declareVariables("AnotacionEnhanced anota");

            String filtro = "this.folio==fol ";
            //*String filtro = "this.folio==fol && this.estado.idEstadoAn!='" +
            //*CEstadoAnotacion.OBSOLETA + "' ";

            //No contar las anotaciones temporales creadas para actualizar definitivas
            filtro = filtro + "&& !(anota.folio==fol \n"
                    + "&& anota.idAnotacion==this.idAnotacionTmp)";

            if (criterio.equals(CCriterio.POR_NAT_JURIDICA)) {
                filtro = filtro
                        + " && this.naturalezaJuridica.idNaturalezaJuridica==parametro";
            } else if (criterio.equals(CCriterio.POR_GRUPO_NAT_JURIDICA)) {
                filtro = filtro
                        + " && this.naturalezaJuridica.grupoNaturalezaJuridica.idGrupoNatJuridica==parametro";
            } else if (criterio.equals(CCriterio.POR_ORDEN)) {
                filtro = filtro + " && this.orden==parametro";
            } else if (criterio.equals(CCriterio.POR_TIPO_ANOTACION)) {
                filtro = filtro
                        + " && this.tipoAnotacion.idTipoAnotacion==parametro";
            } else if (!criterio.equals(CCriterio.TODAS_LAS_ANOTACIONES)) {
                throw new DAOException("Criterio invalido: " + criterio);
            }

            query.setFilter(filtro);
            res = (List) query.execute(valor, fol);

            AnotacionTMP anotaTMP;
            AnotacionEnhanced anotaAux;

            for (Iterator it = res.iterator(); it.hasNext();) {
                anotaTMP = (AnotacionTMP) it.next();
                this.makeTransientAnotacionTMP(anotaTMP, pm, new ArrayList());
                anotaAux = anotaTMP.getDefinitivo(new ArrayList());
                anotaAux.setTemporal(true);
                rta.add(anotaAux);
            }
        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (Exception e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().commit();
            }

            pm.close();
        }

        return TransferUtils.makeTransferAll(rta);
    }

    /**
     * Retorna las anotaciones definitivas de un folio con el criterio dado con
     * el delta aplicado (Anotaciones temporales actualizando definitivas), y
     * las anotaciones temporales nuevas
     *
     * @param oid
     * @param criterio
     * @param valor
     * @param usuario
     * @return
     * @throws DAOException
     */
    public List getAnotacionesFolio(FolioPk oid, String criterio,
            String valor, int posicionInicial, int cantidad, Usuario usuario, boolean vigente)
            throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        List rta = new ArrayList();
        List res = new ArrayList();
        AnotacionEnhanced anota;

        try {
            FolioEnhanced fol = this.getFolioByID(new FolioEnhancedPk(oid), pm);

            if (fol == null) {
                throw new DAOException(
                        "El folio especificado no existe. Matricula: "
                        + oid.idMatricula);
            }

            if (criterio == null) {
                throw new DAOException("Se debe especificar un criterio");
            }

            //validamos el bloqueo del folio, si el usuario que se manda
            //por parámetros es distiento a null
            if (usuario != null) {
                this.validarBloqueoFolio(fol, usuario, pm);
            }

            //Se debe buscar por algún criterio las anotaciones
            pm.currentTransaction().begin();

            VersantQuery query = (VersantQuery) pm.newQuery(AnotacionEnhanced.class);
            query.declareParameters("String parametro, FolioEnhanced fol");
            query.setRandomAccess(true);
            query.setOrdering("ordenLPAD ascending");

            if (vigente) {
                query.declareVariables("CancelacionEnhanced cancel; CancelacionTMP cancelTMP");
            }

            String filtro = "this.folio==fol && (this.link==null || this.link==false) ";
            //*String filtro = "this.folio==fol && this.estado.idEstadoAn!='" +
            //*CEstadoAnotacion.OBSOLETA + "' && (this.link==null || this.link==false) ";

            if (criterio.equals(CCriterio.POR_NAT_JURIDICA)) {
                filtro = filtro
                        + " && this.naturalezaJuridica.idNaturalezaJuridica==parametro";
            } else if (criterio.equals(CCriterio.POR_GRUPO_NAT_JURIDICA)) {
                filtro = filtro
                        + " && this.naturalezaJuridica.grupoNaturalezaJuridica.idGrupoNatJuridica==parametro";
            } else if (criterio.equals(CCriterio.POR_ID_ANOTACION)) {
                filtro = filtro + " && this.idAnotacion==parametro";
            } else if (criterio.equals(CCriterio.POR_ORDEN)) {
                filtro = filtro + " && this.orden==parametro";
            } else if (criterio.equals(CCriterio.POR_TIPO_ANOTACION)) {
                filtro = filtro
                        + " && this.tipoAnotacion.idTipoAnotacion==parametro";
            } else if (!criterio.equals(CCriterio.TODAS_LAS_ANOTACIONES)) {
                throw new DAOException("Criterio invalido: " + criterio);
            }

            if (vigente) {
                filtro = filtro + " && !(cancel.cancelada==this)  && !(cancelTMP.canceladaDef==this)";
            }

            query.setFilter(filtro);
            res = (List) query.execute(valor, fol);
            int i = 0;
            for (i = posicionInicial; i < (posicionInicial + cantidad);
                    i++) {
                try {
                    anota = (AnotacionEnhanced) res.get(i);

                    //Por cada anotación encotrada buscamos si existe una
                    //anotación temporal que la esté actualizando:
                    AnotacionTMPPk aTMPID = new AnotacionTMPPk();
                    aTMPID.idAnotacionTmp = anota.getIdAnotacion();
                    aTMPID.idMatricula = anota.getIdMatricula();

                    AnotacionTMP anotaTMP = this.getAnotacionTMPByID(aTMPID, pm);
                    String idWorkFlow = this.getIdWorkFlowByAnotacion(anota.getIdAnotacion(), anota.getIdMatricula(), pm);
                    if (anotaTMP != null) {
                        if (anotaTMP.getIdWorkflow() == null || anotaTMP.getIdWorkflow().equals("") && idWorkFlow != null) {
                            anotaTMP.setIdWorkflow(idWorkFlow);
                        }
                    }
                    /*this.makeTransientAnotacion(anota, pm, new ArrayList());

                    if (anotaTMP == null) {
                        //La anotación NO tiene actualizaciones
                        rta.add(anota);
                    } else {
                        //LA anotación TIENE actualizaciones por aplicar
                        this.makeTransientAnotacionTMP(anotaTMP, pm,
                            new ArrayList());
                        rta.add(this.getAnotacionDefinitivaConDeltasAplicados(
                                anota, anotaTMP));
                    }*/

                    AnotacionEnhanced anotaPersistente2 = this.getAnotacionByID((AnotacionEnhancedPk) pm.getObjectId(anota), pm);
                    this.makeTransientAnotacion(anotaPersistente2, pm, new ArrayList());

                    //this.makeTransientAnotacion(anota, pm, new ArrayList());
                    if (!((valor != null && (valor.equals(CNaturalezaJuridica.LOTEO) || valor.equals(CNaturalezaJuridica.RELOTEO)))
                            && (anotaPersistente2.getAnotacionesHijos() != null && anotaPersistente2.getAnotacionesHijos().size() > 0))) {
                        if (anotaTMP == null) {
                            //La anotación NO tiene actualizaciones
                            //rta.add(anota);
                            rta.add(anotaPersistente2);
                        } else {
                            //LA anotación TIENE actualizaciones por aplicar
                            if (!((valor != null && (valor.equals(CNaturalezaJuridica.LOTEO) || valor.equals(CNaturalezaJuridica.RELOTEO)))
                                    && (anotaTMP.getAnotacionesHijosTMPs() != null && anotaTMP.getAnotacionesHijosTMPs().size() > 0))) {
                                this.makeTransientAnotacionTMP(anotaTMP, pm,
                                        new ArrayList());
                                rta.add(this.getAnotacionDefinitivaConDeltasAplicados(
                                        anotaPersistente2, anotaTMP));
                            }
                        }
                    }
                } catch (NoSuchElementException ns) {
                    break;
                } catch (ArrayIndexOutOfBoundsException ns) {
                    break;
                }
            }
            //Se revisa si se salió del ciclo porque terminó las anotaciones
            //o porque se salió del rango.
            if (i <= (posicionInicial + cantidad)) {
                //Todavía queda rango por ver, se busca entre las temporales:
                //Definimos el siguiente rango entre las temporales:
                int cantidadTMP = ((posicionInicial + cantidad) - i);
                int posicionInicialTMP = i - (int) (this.getCountAnotacionesFolio(oid, criterio, valor, vigente));

                //Realizamos la consulta en las anotaciones temporales:
                VersantQuery queryTMP = (VersantQuery) pm.newQuery(AnotacionTMP.class);
                queryTMP.declareParameters("String parametro, FolioEnhanced fol");
                queryTMP.setRandomAccess(true);
                queryTMP.setOrdering("ordenLPAD ascending");

                String variables = "AnotacionEnhanced anota";

                if (vigente) {
                    variables = variables + "; CancelacionTMP cancelTMP";
                }

                queryTMP.declareVariables(variables);

                String filtroTMP = "this.folio==fol ";
                //*String filtroTMP = "this.folio==fol && this.estado.idEstadoAn!='" +
                //*CEstadoAnotacion.OBSOLETA + "' ";				

                //No contar las anotaciones temporales creadas para actualizar definitivas
                if (!(valor != null && (valor.equals(CNaturalezaJuridica.LOTEO) || valor.equals(CNaturalezaJuridica.RELOTEO)))) {
                    filtroTMP = filtroTMP + "&& !(anota.folio==fol \n"
                            + "&& anota.idAnotacion==this.idAnotacionTmp)";
                }

                if (criterio.equals(CCriterio.POR_NAT_JURIDICA)) {
                    filtroTMP = filtroTMP
                            + " && this.naturalezaJuridica.idNaturalezaJuridica==parametro";
                } else if (criterio.equals(CCriterio.POR_GRUPO_NAT_JURIDICA)) {
                    filtroTMP = filtroTMP
                            + " && this.naturalezaJuridica.grupoNaturalezaJuridica.idGrupoNatJuridica==parametro";
                } else if (criterio.equals(CCriterio.POR_ID_ANOTACION)) {
                    filtroTMP = filtroTMP + " && this.idAnotacionTmp==parametro";
                } else if (criterio.equals(CCriterio.POR_ORDEN)) {
                    filtroTMP = filtroTMP + " && this.orden==parametro";
                } else if (criterio.equals(CCriterio.POR_TIPO_ANOTACION)) {
                    filtroTMP = filtroTMP
                            + " && this.tipoAnotacion.idTipoAnotacion==parametro";
                } else if (!criterio.equals(CCriterio.TODAS_LAS_ANOTACIONES)) {
                    throw new DAOException("Criterio invalido: " + criterio);
                }

                if (vigente) {
                    filtroTMP = filtroTMP + " && !(cancelTMP.canceladaTmp == this)";
                }

                queryTMP.setFilter(filtroTMP);
                List res2 = (List) queryTMP.execute(valor, fol);
                for (int j = posicionInicialTMP; j < (posicionInicialTMP + cantidadTMP);
                        j++) {
                    try {
                        AnotacionTMP anotaTMP = (AnotacionTMP) res2.get(j);

                        /*
						this.makeTransientAnotacionTMP(anotaTMP, pm,
								new ArrayList());
						AnotacionEnhanced anotaAux = anotaTMP.getDefinitivo(new ArrayList());
						anotaAux.setTemporal(true);
						rta.add(anotaAux);*/
                        AnotacionTMPPk aTMPID = new AnotacionTMPPk();
                        aTMPID.idAnotacionTmp = anotaTMP.getIdAnotacionTmp();
                        aTMPID.idMatricula = anotaTMP.getIdMatricula();
                        AnotacionTMP anotaTMP2 = this.getAnotacionTMPByID(aTMPID, pm);

                        this.makeTransientAnotacionTMP(anotaTMP2, pm,
                                new ArrayList());
                        AnotacionEnhanced anotaAux = anotaTMP2.getDefinitivo(new ArrayList());

                        /**
                         * En caso de que se modifique el docuemnto de la
                         * anotacion temporal se debe actualizar
                         */
                        if (anotaTMP2.getDocumentoTMP() != null) {
                            anotaAux.setDocumento(anotaTMP2.getDocumentoTMP().getDefinitivo());
                        }
                        anotaAux.setTemporal(true);

                        AnotacionEnhancedPk anotaAux2 = new AnotacionEnhancedPk();
                        anotaAux2.idAnotacion = anotaTMP.getIdAnotacionTmp();
                        anotaAux2.idMatricula = anotaTMP.getIdMatricula();
                        boolean edicionASegregacion = false;

                        AnotacionEnhanced anotaEnh = this.getAnotacionByID(anotaAux2, pm);

                        if (anotaEnh != null) {
                            if (valor != null && (valor.equals(CNaturalezaJuridica.LOTEO) || valor.equals(CNaturalezaJuridica.RELOTEO))
                                    && (anotaEnh.getAnotacionesHijos() == null || anotaEnh.getAnotacionesHijos().size() < 1)) {
                                edicionASegregacion = true;
                            }
                        }

                        if (!(valor != null && (valor.equals(CNaturalezaJuridica.LOTEO) || valor.equals(CNaturalezaJuridica.RELOTEO)))
                                || edicionASegregacion) {
                            rta.add(anotaAux);
                        }

                    } catch (NoSuchElementException ns) {
                        break;
                    } catch (ArrayIndexOutOfBoundsException ns) {
                        break;
                    }
                }
            }

        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (DAOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw e;
        } catch (Throwable e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().commit();
            }

            pm.close();
        }

        return TransferUtils.makeTransferAll(rta);
    }

    /**
     * @author : Henry Gómez Rocha
     * @change : Evita que al momento de pasar del role Calificador al role
     * Digitador se verifique el usuario que tiene el bloqueo.. Caso Mantis :
     * 0004967 Retorna las anotaciones definitivas de un folio con el criterio
     * dado con el delta aplicado (Anotaciones temporales actualizando
     * definitivas), y las anotaciones temporales nuevas
     *
     * @param oid
     * @param criterio
     * @param valor
     * @param usuario
     * @return
     * @throws DAOException
     */
    public List getAnotacionesFolio(FolioPk oid, String criterio,
            String valor, int posicionInicial, int cantidad, Usuario usuario, boolean vigente, boolean validarTurno)
            throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        List rta = new ArrayList();
        List res = new ArrayList();
        AnotacionEnhanced anota;

        try {
            FolioEnhanced fol = this.getFolioByID(new FolioEnhancedPk(oid), pm);

            if (fol == null) {
                throw new DAOException(
                        "El folio especificado no existe. Matricula: "
                        + oid.idMatricula);
            }

            if (criterio == null) {
                throw new DAOException("Se debe especificar un criterio");
            }

            //validamos el bloqueo del folio, si el usuario que se manda
            //por parámetros es distiento a null
            if (usuario != null && validarTurno) {
                this.validarBloqueoFolio(fol, usuario, pm);
            }

            //Se debe buscar por algún criterio las anotaciones
            pm.currentTransaction().begin();

            VersantQuery query = (VersantQuery) pm.newQuery(AnotacionEnhanced.class);
            query.declareParameters("String parametro, FolioEnhanced fol");
            query.setRandomAccess(true);
            query.setOrdering("ordenLPAD ascending");

            if (vigente) {
                query.declareVariables("CancelacionEnhanced cancel; CancelacionTMP cancelTMP");
            }

            String filtro = "this.folio==fol && (this.link==null || this.link==false) ";
            //*String filtro = "this.folio==fol && this.estado.idEstadoAn!='" +
            //*CEstadoAnotacion.OBSOLETA + "' && (this.link==null || this.link==false) ";

            if (criterio.equals(CCriterio.POR_NAT_JURIDICA)) {
                filtro = filtro
                        + " && this.naturalezaJuridica.idNaturalezaJuridica==parametro";
            } else if (criterio.equals(CCriterio.POR_GRUPO_NAT_JURIDICA)) {
                filtro = filtro
                        + " && this.naturalezaJuridica.grupoNaturalezaJuridica.idGrupoNatJuridica==parametro";
            } else if (criterio.equals(CCriterio.POR_ID_ANOTACION)) {
                filtro = filtro + " && this.idAnotacion==parametro";
            } else if (criterio.equals(CCriterio.POR_ORDEN)) {
                filtro = filtro + " && this.orden==parametro";
            } else if (criterio.equals(CCriterio.POR_TIPO_ANOTACION)) {
                filtro = filtro
                        + " && this.tipoAnotacion.idTipoAnotacion==parametro";
            } else if (!criterio.equals(CCriterio.TODAS_LAS_ANOTACIONES)) {
                throw new DAOException("Criterio invalido: " + criterio);
            }

            if (vigente) {
                filtro = filtro + " && !(cancel.cancelada==this)  && !(cancelTMP.canceladaDef==this)";
            }

            query.setFilter(filtro);
            res = (List) query.execute(valor, fol);
            int i = 0;
            for (i = posicionInicial; i < (posicionInicial + cantidad);
                    i++) {
                try {
                    anota = (AnotacionEnhanced) res.get(i);

                    //Por cada anotación encotrada buscamos si existe una
                    //anotación temporal que la esté actualizando:
                    AnotacionTMPPk aTMPID = new AnotacionTMPPk();
                    aTMPID.idAnotacionTmp = anota.getIdAnotacion();
                    aTMPID.idMatricula = anota.getIdMatricula();

                    AnotacionTMP anotaTMP = this.getAnotacionTMPByID(aTMPID, pm);
                    String idWorkFlow = this.getIdWorkFlowByAnotacion(anota.getIdAnotacion(), anota.getIdMatricula(), pm);
                    if (anotaTMP != null) {
                        if (anotaTMP.getIdWorkflow() == null || anotaTMP.getIdWorkflow().equals("") && idWorkFlow != null) {
                            anotaTMP.setIdWorkflow(idWorkFlow);
                        }
                    }
                    /*this.makeTransientAnotacion(anota, pm, new ArrayList());

                    if (anotaTMP == null) {
                        //La anotación NO tiene actualizaciones
                        rta.add(anota);
                    } else {
                        //LA anotación TIENE actualizaciones por aplicar
                        this.makeTransientAnotacionTMP(anotaTMP, pm,
                            new ArrayList());
                        rta.add(this.getAnotacionDefinitivaConDeltasAplicados(
                                anota, anotaTMP));
                    }*/

                    AnotacionEnhanced anotaPersistente2 = this.getAnotacionByID((AnotacionEnhancedPk) pm.getObjectId(anota), pm);
                    this.makeTransientAnotacion(anotaPersistente2, pm, new ArrayList());

                    //this.makeTransientAnotacion(anota, pm, new ArrayList());
                    if (!((valor != null && (valor.equals(CNaturalezaJuridica.LOTEO) || valor.equals(CNaturalezaJuridica.RELOTEO)))
                            && (anotaPersistente2.getAnotacionesHijos() != null && anotaPersistente2.getAnotacionesHijos().size() > 0))) {
                        if (anotaTMP == null) {
                            //La anotación NO tiene actualizaciones
                            //rta.add(anota);
                            rta.add(anotaPersistente2);
                        } else {
                            //LA anotación TIENE actualizaciones por aplicar
                            if (!((valor != null && (valor.equals(CNaturalezaJuridica.LOTEO) || valor.equals(CNaturalezaJuridica.RELOTEO)))
                                    && (anotaTMP.getAnotacionesHijosTMPs() != null && anotaTMP.getAnotacionesHijosTMPs().size() > 0))) {
                                this.makeTransientAnotacionTMP(anotaTMP, pm,
                                        new ArrayList());
                                rta.add(this.getAnotacionDefinitivaConDeltasAplicados(
                                        anotaPersistente2, anotaTMP));
                            }
                        }
                    }
                } catch (NoSuchElementException ns) {
                    break;
                } catch (ArrayIndexOutOfBoundsException ns) {
                    break;
                }
            }
            //Se revisa si se salió del ciclo porque terminó las anotaciones
            //o porque se salió del rango.
            if (i <= (posicionInicial + cantidad)) {
                //Todavía queda rango por ver, se busca entre las temporales:
                //Definimos el siguiente rango entre las temporales:
                int cantidadTMP = ((posicionInicial + cantidad) - i);
                int posicionInicialTMP = i - (int) (this.getCountAnotacionesFolio(oid, criterio, valor, vigente));

                //Realizamos la consulta en las anotaciones temporales:
                VersantQuery queryTMP = (VersantQuery) pm.newQuery(AnotacionTMP.class);
                queryTMP.declareParameters("String parametro, FolioEnhanced fol");
                queryTMP.setRandomAccess(true);
                queryTMP.setOrdering("ordenLPAD ascending");

                String variables = "AnotacionEnhanced anota";

                if (vigente) {
                    variables = variables + "; CancelacionTMP cancelTMP";
                }

                queryTMP.declareVariables(variables);

                String filtroTMP = "this.folio==fol ";
                //*String filtroTMP = "this.folio==fol && this.estado.idEstadoAn!='" +
                //*CEstadoAnotacion.OBSOLETA + "' ";

                //No contar las anotaciones temporales creadas para actualizar definitivas
                if (!(valor != null && (valor.equals(CNaturalezaJuridica.LOTEO) || valor.equals(CNaturalezaJuridica.RELOTEO)))) {
                    filtroTMP = filtroTMP + "&& !(anota.folio==fol \n"
                            + "&& anota.idAnotacion==this.idAnotacionTmp)";
                }

                if (criterio.equals(CCriterio.POR_NAT_JURIDICA)) {
                    filtroTMP = filtroTMP
                            + " && this.naturalezaJuridica.idNaturalezaJuridica==parametro";
                } else if (criterio.equals(CCriterio.POR_GRUPO_NAT_JURIDICA)) {
                    filtroTMP = filtroTMP
                            + " && this.naturalezaJuridica.grupoNaturalezaJuridica.idGrupoNatJuridica==parametro";
                } else if (criterio.equals(CCriterio.POR_ID_ANOTACION)) {
                    filtroTMP = filtroTMP + " && this.idAnotacionTmp==parametro";
                } else if (criterio.equals(CCriterio.POR_ORDEN)) {
                    filtroTMP = filtroTMP + " && this.orden==parametro";
                } else if (criterio.equals(CCriterio.POR_TIPO_ANOTACION)) {
                    filtroTMP = filtroTMP
                            + " && this.tipoAnotacion.idTipoAnotacion==parametro";
                } else if (!criterio.equals(CCriterio.TODAS_LAS_ANOTACIONES)) {
                    throw new DAOException("Criterio invalido: " + criterio);
                }

                if (vigente) {
                    filtroTMP = filtroTMP + " && !(cancelTMP.canceladaTmp == this)";
                }

                queryTMP.setFilter(filtroTMP);
                List res2 = (List) queryTMP.execute(valor, fol);
                for (int j = posicionInicialTMP; j < (posicionInicialTMP + cantidadTMP);
                        j++) {
                    try {
                        AnotacionTMP anotaTMP = (AnotacionTMP) res2.get(j);

                        /*
						this.makeTransientAnotacionTMP(anotaTMP, pm,
								new ArrayList());
						AnotacionEnhanced anotaAux = anotaTMP.getDefinitivo(new ArrayList());
						anotaAux.setTemporal(true);
						rta.add(anotaAux);*/
                        AnotacionTMPPk aTMPID = new AnotacionTMPPk();
                        aTMPID.idAnotacionTmp = anotaTMP.getIdAnotacionTmp();
                        aTMPID.idMatricula = anotaTMP.getIdMatricula();
                        AnotacionTMP anotaTMP2 = this.getAnotacionTMPByID(aTMPID, pm);

                        this.makeTransientAnotacionTMP(anotaTMP2, pm,
                                new ArrayList());
                        AnotacionEnhanced anotaAux = anotaTMP2.getDefinitivo(new ArrayList());

                        /**
                         * En caso de que se modifique el docuemnto de la
                         * anotacion temporal se debe actualizar
                         */
                        if (anotaTMP2.getDocumentoTMP() != null) {
                            anotaAux.setDocumento(anotaTMP2.getDocumentoTMP().getDefinitivo());
                        }
                        anotaAux.setTemporal(true);

                        AnotacionEnhancedPk anotaAux2 = new AnotacionEnhancedPk();
                        anotaAux2.idAnotacion = anotaTMP.getIdAnotacionTmp();
                        anotaAux2.idMatricula = anotaTMP.getIdMatricula();
                        boolean edicionASegregacion = false;

                        AnotacionEnhanced anotaEnh = this.getAnotacionByID(anotaAux2, pm);

                        if (anotaEnh != null) {
                            if (valor != null && (valor.equals(CNaturalezaJuridica.LOTEO) || valor.equals(CNaturalezaJuridica.RELOTEO))
                                    && (anotaEnh.getAnotacionesHijos() == null || anotaEnh.getAnotacionesHijos().size() < 1)) {
                                edicionASegregacion = true;
                            }
                        }

                        if (!(valor != null && (valor.equals(CNaturalezaJuridica.LOTEO) || valor.equals(CNaturalezaJuridica.RELOTEO)))
                                || edicionASegregacion) {
                            rta.add(anotaAux);
                        }

                    } catch (NoSuchElementException ns) {
                        break;
                    } catch (ArrayIndexOutOfBoundsException ns) {
                        break;
                    }
                }
            }

        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (DAOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw e;
        } catch (Throwable e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().commit();
            }

            pm.close();
        }

        return TransferUtils.makeTransferAll(rta);
    }

    /**
     * @param anota
     * @param anotaTMP
     * @param pm
     * @return
     */
    protected AnotacionEnhanced getAnotacionDefinitivaConDeltasAplicados(
            AnotacionEnhanced anToUpdate, AnotacionTMP anotaTMP)
            throws DAOException {
        try {
            AnotacionEnhanced anotaAux = anotaTMP.getDefinitivo(new ArrayList());

            //La anotacion temporal representa una actualización a la anotación
            //definitiva
            if (anotaAux.getEstado() != null) {
                anToUpdate.setEstado(anotaAux.getEstado());
            }

            if (anotaAux.getNaturalezaJuridica() != null) {
                anToUpdate.setNaturalezaJuridica(anotaAux.getNaturalezaJuridica());
            }

            if (anotaAux.getTipoAnotacion() != null) {
                anToUpdate.setTipoAnotacion(anotaAux.getTipoAnotacion());
            }

            if (anotaAux.getOrden() != null) {
                anToUpdate.setOrden(anotaAux.getOrden());
            }

            if (anotaAux.getEspecificacion() != null) {
                anToUpdate.setEspecificacion(anotaAux.getEspecificacion());
            }

            if (anotaAux.getComentario() != null) {
                anToUpdate.setComentario(anotaAux.getComentario());
            }

            if (anotaAux.getValor() != anToUpdate.getValor()) {
                anToUpdate.setValor(anotaAux.getValor());
            }

            if (anotaAux.getFechaRadicacion() != null) {
                anToUpdate.setFechaRadicacion(anotaAux.getFechaRadicacion());
            }

            if (anotaAux.getNumRadicacion() != null) {
                anToUpdate.setNumRadicacion(anotaAux.getNumRadicacion());
            }

            if (anotaTMP.getDocumentoTMP() != null) {
                anToUpdate.setDocumento(anotaTMP.getDocumentoTMP().getDefinitivo());
            }

            //Miramos los ciudadanos de la anotacion que se deben,
            //insertar o borrar
            AnotacionCiudadanoEnhanced anCiudAux;

            for (Iterator it2 = anotaAux.getAnotacionesCiudadanos().iterator();
                    it2.hasNext();) {
                anCiudAux = (AnotacionCiudadanoEnhanced) it2.next();

                if (anToUpdate.getAnotacionesCiudadanos().contains(anCiudAux)) {

                    //Se debe actualizar o borrar el ciudadano del objeto
                    /**
                     * En caso de que la anotacion no sea para borrar se elimina
                     * y se vuelve a adicionar. Esto sucede cuando solo se
                     * cambia otros datos al ciudadano menos las llaves
                     * primarias (participacion, propietario). El contain mira
                     * solo por llaves primarias
                     */
                    if (anCiudAux.isToDelete()) {
                        anToUpdate.removeAnotacionesCiudadano(anCiudAux);
                    } else {
                        anToUpdate.removeAnotacionesCiudadano(anCiudAux);
                        anToUpdate.addAnotacionesCiudadano(anCiudAux);
                    }
                } else {
                    //Se debe agregar el ciudadano
                    anToUpdate.addAnotacionesCiudadano(anCiudAux);
                }
            }

            //Miramos las salvedades de la anotacion que se deben,
            //insertar o borrar
            SalvedadAnotacionEnhanced salAux;

            for (Iterator it3 = anotaAux.getSalvedades().iterator();
                    it3.hasNext();) {
                salAux = (SalvedadAnotacionEnhanced) it3.next();

                if (anToUpdate.getSalvedades().contains(salAux)) {
                    //Se debe actualizar o borrar el ciudadano del objeto
                    if (salAux.isToDelete()) {
                        anToUpdate.removeSalvedade(salAux);
                    } else {
                        if (salAux.getDescripcion() != null) {
                            int ind = anToUpdate.getSalvedades().indexOf(salAux);
                            SalvedadAnotacionEnhanced salToUpdate = (SalvedadAnotacionEnhanced) anToUpdate.getSalvedades()
                                    .get(ind);
                            salToUpdate.setDescripcion(salAux.getDescripcion());
                        }
                    }
                } else {
                    //Se debe agregar la salvedad
                    anToUpdate.addSalvedade(salAux);
                }
            }

            //Miramos las cancelaciones de la anotacion que se deben,
            //insertar o borrar
            CancelacionEnhanced anCancelAux;

            for (Iterator it2 = anotaAux.getAnotacionesCancelacions().iterator();
                    it2.hasNext();) {
                anCancelAux = (CancelacionEnhanced) it2.next();

                if (anToUpdate.getAnotacionesCancelacions().contains(anCancelAux)) {
                    //Se debe actualizar o borrar la cancelacion
                    if (anCancelAux.isToDelete()) {
                        anToUpdate.removeAnotacionesCancelacion(anCancelAux);
                    }
                } else {
                    //Se debe agregar el ciudadano
                    anToUpdate.addAnotacionesCancelacion(anCancelAux);
                }
            }

            //Como es una anotación que está siendo modificada se pone el flag de temporal
            anToUpdate.setTemporal(true);

            // bug 3568
            anToUpdate.setTemporalConContraparteDefinitiva(true);

            return anToUpdate;
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }
    }

    /**
     *
     * @param folio
     * @param datos
     * @param pm
     * @return
     * @throws DAOException
     */
    protected boolean updateFolioDocumento(FolioEnhanced folio, Folio datos,
            PersistenceManager pm) throws DAOException {
        boolean rta = false;

        try {
            DocumentoEnhanced doc = DocumentoEnhanced.enhance(datos.getDocumento());

            // Se valida si ya se tiene un DocumentoTMP asociado al folio
            DocumentoTMP documento = folio.getDocumentoTMP();

            //Si no existe se crea
            if (documento == null) {
                //Se obtiene el documento actual
                DocumentoEnhanced aux = folio.getDocumento();

                //Si existe un documento actual
                //se revisa si ya existe un registro temporal
                //para el mismo documento
                if (aux != null) {
                    DocumentoTMPPk auxId = new DocumentoTMPPk();
                    auxId.idDocumentoTmp = aux.getIdDocumento();

                    DocumentoTMP auxTMP = this.getDocumentoTMP(auxId, pm);

                    //Si existe un documento temporal actual
                    //asociado modificamos su registro
                    if (auxTMP != null) {
                        this.actualizarDocumentoTMP(auxTMP, doc, pm);
                        folio.setDocumentoTMP(auxTMP);
                    } else {
                        DocumentoTMP docTMP = new DocumentoTMP(aux);
                        this.setDocumentoTMPToFolio(folio, docTMP, pm);
                        pm.makePersistent(docTMP);
                        this.actualizarDocumentoTMP(docTMP, doc, pm);
                    }
                } //Si no existe un documento actual se debe asignar un ID de la secuencia de documentos
                //definitivos
                else {
                    doc.setIdDocumento(String.valueOf(this.getSecuencial(
                            CDocumento.TABLE_NAME, null)));
                    documento = new DocumentoTMP(doc);
                    this.setDocumentoTMPToFolio(folio, documento, pm);
                    pm.makePersistent(documento);
                }
            } //Si tiene un documento asociado símplemente se actualiza
            else {
                this.actualizarDocumentoTMP(documento, doc, pm);
            }

            rta = true;
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }

        return rta;
    }

    /**
     * @author: Cesar Ramirez
     * @change: 1245.HABILITAR.TIPO.PREDIO Método Actualiza el tipo de predio
     * para persistirlo posteriormente en la base de datos.
     * @param folio
     * @param datos
     * @param pm
     * @return
     * @throws DAOException
     */
    protected boolean updateTipoPredio(FolioEnhanced folio, Folio datos,
            UsuarioEnhanced usuario, String turno, PersistenceManager pm) throws DAOException {
        boolean rta = false;

        try {
            FolioEnhanced folioAuditoriaViejo = (FolioEnhanced) auditoria.clonarEnhanced(folio);
            // Recibe el id de Tipo Predio cambiado.
            String idPredio = datos.getTipoPredio().getIdPredio();

            if (idPredio != null) {
                TipoPredioEnhancedPk tpId = new TipoPredioEnhancedPk();
                tpId.idPredio = idPredio;
                TipoPredioEnhanced tipoPredio = this.getTipoPredio(tpId, pm);

                // Asigna la info de Tipo Predio para su posterior actualización.
                folio.setTipoPredio(tipoPredio);

                /**
                 * @author: Cesar Ramirez
                 * @change: 1245.HABILITAR.TIPO.PREDIO Sólo guarda en la tabla
                 * de Auditoría la edición del campo si el folio es definitivo.
                 *
                 */
                if (folio.isDefinitivo()) {
                    co.com.iridium.generalSIR.negocio.auditoria.AuditoriaSIR auditoriaSir = new co.com.iridium.generalSIR.negocio.auditoria.AuditoriaSIR();

                    auditoria.addAuditoria(folio, folioAuditoriaViejo, usuario, pm);

                    if (turno != null) {
                        try {
                            auditoriaSir.guardarAuditoriaFolio(folio, folioAuditoriaViejo, turno);
                        } catch (GeneralSIRException ex) {
                            Log.getInstance().error(JDOGenieFolioDAO.class, ex.getMessage());
                        }
                    }
                }
                rta = true;
            }
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }

        return rta;
    }

    /**
     * Actualiza el documento de una anotacion temporal. Si ya existe un
     * docuemento en temporal para otra anotación o folio se actualiza el mismo
     * objeto.
     *
     * @param anotacion
     * @param datos
     * @param pm
     * @return
     * @throws DAOException
     */
    protected boolean updateAnotacionDocumento(AnotacionTMP anotacion, AnotacionTMP datos,
            PersistenceManager pm) throws DAOException {
        boolean rta = false;

        try {
            DocumentoEnhanced doc = datos.getDocumento();

            // Se valida si ya se tiene un DocumentoTMP asociado a la anotacion
            DocumentoTMP documento = anotacion.getDocumentoTMP();

            //Si no existe se crea
            if (documento == null) {
                //Se obtiene el documento actual
                DocumentoEnhanced aux = anotacion.getDocumento();

                //Si existe un documento actual
                //se revisa si ya existe un registro temporal
                //para el mismo documento
                if (aux != null) {
                    DocumentoTMPPk auxId = new DocumentoTMPPk();
                    auxId.idDocumentoTmp = aux.getIdDocumento();

                    DocumentoTMP auxTMP = this.getDocumentoTMP(auxId, pm);

                    //Si existe un documento temporal actual
                    //asociado modificamos su registro
                    if (auxTMP != null) {
                        if (tipoCambio) {
                            DocumentoTMP docTMP = new DocumentoTMP(aux);
                            //Hallando secuencia del documento definitivo
                            docTMP.setIdDocumentoTmp(String.valueOf(this.getSecuencial(CDocumento.TABLE_NAME, null)));
                            this.setDocumentoTMPToAnotacion(anotacion, docTMP, pm);
                            pm.makePersistent(docTMP);
                            this.actualizarDocumentoTMP(docTMP, doc, pm);
                        } else {
                            this.actualizarDocumentoTMP(auxTMP, doc, pm);
                            anotacion.setDocumentoTMP(auxTMP);
                        }
                    } else {
                        if (tipoCambio) {
                            DocumentoTMP docTMP = new DocumentoTMP(aux);
                            //Hallando secuencia del documento definitivo
                            docTMP.setIdDocumentoTmp(String.valueOf(this.getSecuencial(CDocumento.TABLE_NAME, null)));
                            this.setDocumentoTMPToAnotacion(anotacion, docTMP, pm);
                            pm.makePersistent(docTMP);
                            this.actualizarDocumentoTMP(docTMP, doc, pm);
                        } else {
                            DocumentoTMP docTMP = new DocumentoTMP(aux);
                            this.setDocumentoTMPToAnotacion(anotacion, docTMP, pm);
                            pm.makePersistent(docTMP);
                            this.actualizarDocumentoTMP(docTMP, doc, pm);
                        }
                    }
                } //Si no existe un documento actual se debe asignar un ID de la secuencia de documentos
                //definitivos
                else {
                    doc.setIdDocumento(String.valueOf(this.getSecuencial(
                            CDocumento.TABLE_NAME, null)));
                    documento = new DocumentoTMP(doc);
                    this.setDocumentoTMPToAnotacion(anotacion, documento, pm);
                    pm.makePersistent(documento);
                }
            } //Si tiene un documento asociado símplemente se actualiza
            else {
                this.actualizarDocumentoTMP(documento, doc, pm);
            }

            rta = true;
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }

        return rta;
    }

    /**
     * Actualiza los datos de un documento temporal persistente con los datos de
     * un documento transiente
     *
     * @param toUpdate
     * @param fromDoc
     * @param pm
     * @return
     * @throws DAOException
     */
    protected boolean actualizarDocumentoTMP(DocumentoTMP toUpdate,
            DocumentoEnhanced fromDoc, PersistenceManager pm) throws DAOException {
        boolean rta = false;
        JDOGenieZonaRegistralDAO jdoAux = new JDOGenieZonaRegistralDAO();

        try {
            if (fromDoc.getComentario() != null) {
                toUpdate.setComentario(fromDoc.getComentario());
            }

            if (fromDoc.getFecha() != null) {
                toUpdate.setFecha(fromDoc.getFecha());
            }

            if (fromDoc.getNumero() != null) {
                toUpdate.setNumero(fromDoc.getNumero());
            }

            if (fromDoc.getOficinaOrigen() != null) {
                OficinaOrigenEnhancedPk ooId = new OficinaOrigenEnhancedPk();
                ooId.idOficinaOrigen = fromDoc.getOficinaOrigen()
                        .getIdOficinaOrigen();
                /*
                      *  @author Carlos Torres
                      *  @chage   se agrega validacion de version diferente
                      *  @mantis 0013414: Acta - Requerimiento No 069_453_Código_Notaria_NC
                 */
                ooId.version = fromDoc.getOficinaOrigen().getVersion();
                OficinaOrigenEnhanced office = null;
                office = this.getOficinaOrigen(ooId, pm);
                if (office == null) {
                    throw new DAOException("No existe una oficina con el ID: " + ooId.idOficinaOrigen);
                }
                MunicipioEnhancedPk munId = null;
                VeredaEnhanced vereda = fromDoc.getOficinaOrigen().getVereda();
                if (vereda != null) {
                    String idMunicipio = vereda.getIdMunicipio();
                    if (idMunicipio != null) {
                        String idDepartamento = vereda.getIdDepartamento();
                        if (idDepartamento != null) {
                            DepartamentoEnhancedPk dptoID = new DepartamentoEnhancedPk();
                            dptoID.idDepartamento = idDepartamento;
                            if (jdoAux.getDepartamento(dptoID, pm) == null) {
                                throw new DAOException("El Departamento con el ID: " + dptoID.idDepartamento + " no existe");
                            }
                            munId = new MunicipioEnhancedPk();
                            munId.idMunicipio = idMunicipio;
                            munId.idDepartamento = idDepartamento;
                            MunicipioEnhanced municipioTemp = this.getMunicipio(munId, pm);
                            if (municipioTemp == null) {
                                throw new DAOException("No existe un Municipio con el ID: "
                                        + munId.idMunicipio);
                            }
                            /*
                                                             *  @author Carlos Torres
                                                             *  @chage   se agrega validacion de version diferente
                                                             *  @mantis 0013414: Acta - Requerimiento No 069_453_Código_Notaria_NC
                             */
                            OficinaOrigenEnhanced ofTemp = this.getOficinaOrigenByIds(idDepartamento, idMunicipio, vereda.getIdVereda(), fromDoc.getOficinaOrigen().getIdOficinaOrigen(), fromDoc.getOficinaOrigen().getVersion());
                            if (ofTemp == null) {
                                throw new DAOException("La oficina con el ID: " + ooId.idOficinaOrigen + " no existe en el municipio con ID: "
                                        + idMunicipio + " y en el departamento con ID: " + idDepartamento);
                            }
                        }
                    }
                }
                toUpdate.setOficinaOrigen(office);
                toUpdate.setOficinaInternacional(null);
//            	toUpdate.setOficinaInternacional(fromDoc.getOficinaInternacional());
            }

            if (fromDoc.getCirculo() != null) {
                toUpdate.setCirculo(fromDoc.getCirculo());
            }

            if (fromDoc.getOficinaInternacional() != null) {
                toUpdate.setOficinaInternacional(fromDoc.getOficinaInternacional());
                toUpdate.setOficinaOrigen(null);
            }

            if (fromDoc.getTipoDocumento() != null) {
                TipoDocumentoEnhancedPk tdId = new TipoDocumentoEnhancedPk();
                tdId.idTipoDocumento = fromDoc.getTipoDocumento()
                        .getIdTipoDocumento();

                TipoDocumentoEnhanced tipoDoc = this.getTipoDocumento(tdId, pm);

                if (tipoDoc == null) {
                    throw new DAOException(
                            "No existe un tipo de documento con el ID: "
                            + tdId.idTipoDocumento);
                }

                toUpdate.setTipoDocumento(tipoDoc);
            }
        } catch (DAOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw e;
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }

        return rta;
    }

    /**
     * Hace definitivo el documento temporal en el folio
     *
     * @param folio
     * @param datos
     * @param pm
     * @throws DAOException
     */
    protected void hacerDefinitivoDocumento(FolioEnhanced folio,
            DocumentoTMP datos, UsuarioEnhanced usuario, String turno, PersistenceManager pm) throws DAOException {
        try {
            //Se revisa si se va a insertar un documento
            //o se va a actualizar
            DocumentoEnhancedPk oid = new DocumentoEnhancedPk();
            oid.idDocumento = datos.getIdDocumentoTmp();

            DocumentoEnhanced aux = this.getDocumento(oid, pm);

            if (aux == null) {
                //inserción
                DocumentoEnhanced doc = datos.getDefinitivo();
                pm.makePersistent(doc);
                folio.setDocumento(doc);
            } else {
                DocumentoEnhanced docAuditoriaViejo = (DocumentoEnhanced) auditoria.clonarEnhanced(aux);

                //actualización
                aux.setComentario(datos.getComentario());
                aux.setNumero(datos.getNumero());
                aux.setFecha(datos.getFecha());
                aux.setOficinaOrigen(datos.getOficinaOrigen());
                aux.setTipoDocumento(datos.getTipoDocumento());

                //Se hace la auditoría a los atributos que cambiaron
                auditoria.addAuditoria(aux, docAuditoriaViejo, usuario, pm);
                /**
                 * @Author Carlos Torres
                 * @Mantis 13176
                 * @Chaged
                 */
                if (turno != null) {
                    co.com.iridium.generalSIR.negocio.auditoria.AuditoriaSIR auditoriaSir = new co.com.iridium.generalSIR.negocio.auditoria.AuditoriaSIR();
                    try {
                        auditoriaSir.guardarAuditoriaDocumento(aux, docAuditoriaViejo, turno);
                    } catch (GeneralSIRException ex) {
                        Log.getInstance().error(JDOGenieFolioDAO.class, ex.getMessage());
                    }
                }

            }

            //TODO Permitir que se pueda eliminar el documento temporal
            //dependiendo si existen folios asociados al mismo documento
            //pm.deletePersistent(datos);
            folio.setDocumentoTMP(null);
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }
    }

    /**
     * Hace definitivo el documento temporal en la anotacion
     *
     * @param folio
     * @param datos
     * @param pm
     * @throws DAOException
     */
    protected void hacerDefinitivoDocumento(AnotacionEnhanced anotacion,
            DocumentoTMP datos, UsuarioEnhanced usuario, PersistenceManager pm, String turno) throws DAOException {
        try {
            //Se revisa si se va a insertar un documento
            //o se va a actualizar
            DocumentoEnhancedPk oid = new DocumentoEnhancedPk();
            oid.idDocumento = datos.getIdDocumentoTmp();

            DocumentoEnhanced aux = this.getDocumento(oid, pm);

            if (aux == null) {
                //inserción
                DocumentoEnhanced doc = datos.getDefinitivo();
                pm.makePersistent(doc);
                anotacion.setDocumento(doc);
            } else {
                DocumentoEnhanced docAuditoriaViejo = (DocumentoEnhanced) auditoria.clonarEnhanced(aux);

                //actualización
                aux.setComentario(datos.getComentario());
                aux.setNumero(datos.getNumero());
                aux.setFecha(datos.getFecha());
                aux.setOficinaOrigen(datos.getOficinaOrigen());
                aux.setTipoDocumento(datos.getTipoDocumento());
                aux.setOficinaInternacional(datos.getOficinaInternacional());

                //Se hace la auditoría a los atributos que cambiaron
                auditoria.addAuditoria(aux, docAuditoriaViejo, usuario, pm);
                /**
                 * @Author Carlos Torres
                 * @Mantis 13176
                 * @Chaged
                 */
                if (turno != null) {
                    co.com.iridium.generalSIR.negocio.auditoria.AuditoriaSIR auditoriaSir = new co.com.iridium.generalSIR.negocio.auditoria.AuditoriaSIR();
                    try {
                        auditoriaSir.guardarAuditoriaDocumento(aux, docAuditoriaViejo, turno);
                    } catch (GeneralSIRException ex) {
                        Log.getInstance().error(JDOGenieFolioDAO.class, ex.getMessage());
                    }
                }

            }

            //TODO Permitir que se pueda eliminar el documento temporal
            //dependiendo si existen anotaciones asociadas al mismo documento
            //pm.deletePersistent(datos);
            //anotacion.setDocumentoTMP(null);
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }
    }

    /**
     * Retorna una lista de objetos SolicitudFolio con los folios que tengan
     * algún cambio temporal a ser aplicado dentro del turno especificado. Cada
     * Folio retornado tiene los deltas que están pendientes por aplicar, si
     * algún folio no se encuentra bloqueado por el usuario especificado se
     * lanza una excepcion
     *
     * @param oid
     * @param usuario
     * @return
     * @throws DAOException
     */
    public List getDeltaFolios(TurnoPk oid, Usuario usuario)
            throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        EstadoFolio aux = null;
        String matricula;

        TurnoEnhanced turno;
        List rta = new ArrayList();
        SolicitudFolioEnhanced sf;
        SolicitudFolio tSf;

        try {

            //Validación del turno:
            turno = this.getTurnoByID(new TurnoEnhancedPk(oid), pm);

            if (turno == null) {
                throw new DAOException(
                        "No se encontró el turno con el ID especificado");
            }

            //Se obtiene la lista de folios asociados al turno
            List folios = turno.getSolicitud().getSolicitudFolios();

            /*
            if (folios.size() == 0) {
                throw new DAOException("El turno no tiene matrículas asociadas");
            }*/
            //Validamos el usuario
            UsuarioEnhanced us = null;
            if (usuario != null) {
                UsuarioEnhancedPk uid = new UsuarioEnhancedPk();
                uid.idUsuario = usuario.getIdUsuario();

                us = this.getUsuarioByID(uid, pm);

                if (us == null) {
                    throw new DAOException("El usuario especificado no existe: "
                            + uid.idUsuario);
                }
            }

            //Para cada folio se valida que se encuentre bloqueado, si el usuario es distinto de null
            for (Iterator it = folios.iterator(); it.hasNext();) {
                sf = (SolicitudFolioEnhanced) it.next();

                if (us != null) {
                    //Validamos si el folio está bloqueado
                    BloqueoFolioEnhanced bloqueo = this.getBloqueoFolio(sf.getIdMatricula(),
                            pm);

                    if (bloqueo == null) {
                        throw new DAOException("La matricula "
                                + sf.getIdMatricula() + " no se encuentra bloqueada");
                    }

                    //Validamos que el usuario sea dueño del bloqueo del folio
                    UsuarioEnhanced usuAux = this.getUsuarioByLlaveBloqueo(bloqueo.getLlaveBloqueo(),
                            pm);

                    if (usuAux == null) {
                        throw new DAOException(
                                "Error en la obtención del usuario a partir de la llave de bloqueo");
                    }

                    if (usuAux.getIdUsuario() != us.getIdUsuario()) {
                        throw new DAOException(
                                "El usuario no es dueño del bloqueo del folio "
                                + sf.getIdMatricula() + ". El turno asociado a la matrícula es: " + bloqueo.getIdWorkflowBloqueo());
                    }
                }

                //Una vez realizada la validación de bloqueo se obtiene el delta, si
                //el folio no tiene delta no se incluye en la lista definitiva
                Folio tFolio = this.getDeltaFolio(sf.getFolio(), pm);

                if (tFolio != null) {
                    tSf = new SolicitudFolio();
                    tSf.setFolio(tFolio);
                    rta.add(tSf);
                }
            }
            return rta;
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (DAOException e) {
            throw e;
        } finally {
            pm.close();
        }
    }

    /**
     * Obtiene las anotaciones agrupadas por folio que fueron agregadas en un
     * turno específico
     *
     * @param oid
     * @return
     * @throws DAOException
     */
    public List getCalificacionTurno(TurnoPk oid)
            throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        EstadoFolio aux = null;
        String matricula;

        TurnoEnhanced turno;
        List rta = new ArrayList();
        SolicitudFolioEnhanced sf = null;
        int flagAnotacionesCalificacion = 0;
        try {
            //Validación del turno:
            turno = this.getTurnoByID(new TurnoEnhancedPk(oid), pm);

            if (turno == null) {
                throw new DAOException(
                        "No se encontró el turno con el ID especificado");
            }

            Query query = pm.newQuery(TurnoAnotacionEnhanced.class);
            query.setOrdering("idMatricula ascending, anotacion.ordenLPAD ascending");
            query.declareParameters("TurnoEnhanced tur");
            query.setFilter("turno==tur");
            Collection col = (Collection) query.execute(turno);
            String idMatriculaActual = "";
            FolioEnhanced folio = null;
            TurnoAnotacionEnhanced turnoAnotacion;
            AnotacionEnhanced anotaToInsert;
            for (Iterator iter = col.iterator(); iter.hasNext();) {
                turnoAnotacion = (TurnoAnotacionEnhanced) iter.next();
                anotaToInsert = turnoAnotacion.getAnotacion();
                this.makeTransientAnotacion(anotaToInsert, pm, new ArrayList());
                if (!anotaToInsert.getIdMatricula().equals(idMatriculaActual)) {
                    folio = new FolioEnhanced();
                    folio.setIdMatricula(turnoAnotacion.getIdMatricula());
                    sf = new SolicitudFolioEnhanced();
                    sf.setFolio(folio);
                    rta.add(sf);
                    idMatriculaActual = anotaToInsert.getIdMatricula();
                    flagAnotacionesCalificacion = 1;
                }
                folio.addAnotacione(anotaToInsert);
            }

            if (flagAnotacionesCalificacion == 0) {
                //Se ingresa las anotaciones donde El numero de Radicacion sea el turno o que la fecha y el numero sean lo del turno
                //Se tiene el turno
                String idTurnoTurno = turno.getIdTurno();
                String anioTurno = turno.getAnio();
                String numAnioTurno = anioTurno + "-" + idTurnoTurno;
                String wk = "";
                if (turno.getIdWorkflow() != null) {
                    wk = turno.getIdWorkflow();
                }

                int anioTurnoT = (new Integer(anioTurno)).intValue();
                Calendar fechaIni = Calendar.getInstance();
                fechaIni.set(Calendar.HOUR_OF_DAY, 0);
                fechaIni.set(Calendar.MINUTE, 0);
                fechaIni.set(Calendar.SECOND, 1);
                fechaIni.set(Calendar.DATE, 1);
                fechaIni.set(Calendar.MONTH, 0);
                fechaIni.set(Calendar.YEAR, anioTurnoT);

                Calendar fechaFin = Calendar.getInstance();
                fechaFin.set(Calendar.HOUR_OF_DAY, 23);
                fechaFin.set(Calendar.MINUTE, 59);
                fechaFin.set(Calendar.SECOND, 59);
                fechaFin.set(Calendar.DATE, 31);
                fechaFin.set(Calendar.MONTH, 11);
                fechaFin.set(Calendar.YEAR, anioTurnoT);

                Date fechaInicialConsulta = fechaIni.getTime();
                Date fechaFinalConsulta = fechaFin.getTime();

                Log.getInstance().debug(JDOGenieFolioDAO.class, "Fecha Inicio " + fechaInicialConsulta);
                Log.getInstance().debug(JDOGenieFolioDAO.class, "Fecha Fin " + fechaFinalConsulta);
                Log.getInstance().debug(JDOGenieFolioDAO.class, "idTurnoTurno " + idTurnoTurno);

                List listSolTurno = new ArrayList();
                listSolTurno = (List) turno.getSolicitud().getSolicitudFolios();
                //Se tiene las solicitudes Folio
                for (int i = 0; i < listSolTurno.size(); i++) {
                    SolicitudFolioEnhanced solTurno = (SolicitudFolioEnhanced) listSolTurno.get(i);
                    FolioEnhanced ftemp = solTurno.getFolio();

                    String idMatriculaActual2 = "";

                    Query queryCalificacionViejos = pm.newQuery(AnotacionEnhanced.class);
                    queryCalificacionViejos.declareParameters("String idMat, String numAnioTurno, String turno,String wk, Date fechaInicial, Date fechaFinal");
                    queryCalificacionViejos.setFilter("this.idMatricula==idMat && "
                            + "(this.numRadicacion==numAnioTurno || ( (this.numRadicacion==turno || this.numRadicacion == wk)&& "
                            + "(this.fechaRadicacion>fechaInicial) && (this.fechaRadicacion<fechaFinal))) && ( this.link == false || this.link == null) ");
                    Collection colCalificacionViejos = (Collection) queryCalificacionViejos.executeWithArray(new Object[]{ftemp.getIdMatricula(), numAnioTurno, idTurnoTurno, wk, fechaInicialConsulta, fechaFinalConsulta});

                    //Aca ya se tienen las anotaciones que cumplen con todo
                    for (Iterator iter = colCalificacionViejos.iterator(); iter.hasNext();) {
                        Log.getInstance().debug(JDOGenieFolioDAO.class, "*************ENCONTRO ANOTACIONES QUE CUMPLEN ESO");
                        AnotacionEnhanced anotacionenhanced = (AnotacionEnhanced) iter.next();
                        //logEstatico.debug(anotacionenhanced);
                        this.makeTransientAnotacion(anotacionenhanced, pm, new ArrayList());
                        if (!anotacionenhanced.getIdMatricula().equals(idMatriculaActual2)) {
                            Log.getInstance().debug(JDOGenieFolioDAO.class, "*************CREO UN FOLIO NUEVO");
                            folio = new FolioEnhanced();
                            folio.setIdMatricula(ftemp.getIdMatricula());
                            sf = new SolicitudFolioEnhanced();
                            sf.setFolio(folio);
                            rta.add(sf);
                            idMatriculaActual2 = anotacionenhanced.getIdMatricula();
                        }
                        Log.getInstance().debug(JDOGenieFolioDAO.class, "Va a ingresar una anotacion del folio " + anotacionenhanced.getIdAnotacion());
                        folio.addAnotacione(anotacionenhanced);
                        Log.getInstance().debug(JDOGenieFolioDAO.class, "Ingreso anotacion " + anotacionenhanced.getIdAnotacion());
                        Log.getInstance().debug(JDOGenieFolioDAO.class, "El folio tiene " + sf.getFolio().getAnotaciones().size() + " anotaciones");
                    }
                }
            }
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (DAOException e) {
            throw e;
        } finally {
            pm.close();
        }
        rta = (TransferUtils.makeTransferAll(rta));
        return rta;
    }

    /**
     * Obtiene un objeto Folio dado su identificador
     *
     * @param oid identificador del Folio conformado por Nro matricula y
     * ZonaRegistral
     * @return Objeto Folio con sus objetos estado, complementacion, tipoPredio
     * y ZonaRegistral, y listas de salvedades folio y direcciones. No se
     * incluyen las anotaciones El objeto ZonaRegistral contiene la jerarquía
     * circulo, vereda, municipio y departamento null si no encuentra un folio
     * que coincida con el identificador dado
     * @throws DAOException
     */
    public Folio getFolioByIDSinAnotaciones(FolioPk oid, Usuario usuario)
            throws DAOException {
        FolioEnhanced datos = null;
        Folio aux = null;
        PersistenceManager pm = AdministradorPM.getPM();

        try {
            datos = this.getFolioByID(new FolioEnhancedPk(oid), pm);

            if (datos == null) {
                throw new DAOException("El folio especificado no existe");
            }

            //validamos el bloqueo del folio, si el usuario es mandado
            //por parámetros
            if (usuario != null) {
                this.validarBloqueoFolio(datos, usuario, pm);
            }

            this.makeTransientFolioTMPSinAnotaciones(datos, pm);
        } catch (DAOException e) {
            throw e;
        } catch (Exception e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e);
        } finally {
            pm.close();
        }

        aux = this.getMaskedFolio(datos);
        this.ordenarDirecciones(aux.getDirecciones());
        return aux;
    }

    /**
     * @author : Henry Gómez Rocha
     * @change : Evita que al momento de pasar del role Calificador al role
     * Digitador se verifique el usuario que tiene el bloqueo.. Caso Mantis :
     * 0004967 Obtiene un objeto Folio dado su identificador
     * @param oid identificador del Folio conformado por Nro matricula y
     * ZonaRegistral
     * @return Objeto Folio con sus objetos estado, complementacion, tipoPredio
     * y ZonaRegistral, y listas de salvedades folio y direcciones. No se
     * incluyen las anotaciones El objeto ZonaRegistral contiene la jerarquía
     * circulo, vereda, municipio y departamento null si no encuentra un folio
     * que coincida con el identificador dado
     * @throws DAOException
     */
    public Folio getFolioByIDSinAnotaciones(FolioPk oid, Usuario usuario, boolean validarTurno)
            throws DAOException {
        FolioEnhanced datos = null;
        Folio aux = null;
        PersistenceManager pm = AdministradorPM.getPM();

        try {
            datos = this.getFolioByID(new FolioEnhancedPk(oid), pm);

            if (datos == null) {
                throw new DAOException("El folio especificado no existe");
            }

            //validamos el bloqueo del folio, si el usuario es mandado
            //por parámetros
            if (usuario != null && validarTurno) {
                this.validarBloqueoFolio(datos, usuario, pm);
            }

            this.makeTransientFolioTMPSinAnotaciones(datos, pm);
        } catch (DAOException e) {
            throw e;
        } catch (Exception e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e);
        } finally {
            pm.close();
        }

        aux = this.getMaskedFolio(datos);
        this.ordenarDirecciones(aux.getDirecciones());
        return aux;
    }

    /**
     * Hace trasiente el folio con lo temporal exceptuando TODAS las anotaciones
     *
     * @param folio
     * @param pm
     * @throws DAOException
     */
    protected void makeTransientFolioTMPSinAnotaciones(FolioEnhanced folio,
            PersistenceManager pm) throws DAOException {
        if (folio != null) {
            try {
                for (Iterator itr2 = folio.getDirecciones().iterator();
                        itr2.hasNext();) {
                    this.makeTransientDireccion((DireccionEnhanced) itr2.next(),
                            pm);
                }

                for (Iterator itr2 = folio.getDireccionesTMPs().iterator();
                        itr2.hasNext();) {
                    this.makeTransientDireccionTMP((DireccionTMP) itr2.next(),
                            pm);
                }

                for (Iterator itr3 = folio.getSalvedades().iterator();
                        itr3.hasNext();) {
                    this.makeTransientSalvedadFolio((SalvedadFolioEnhanced) itr3.next(),
                            pm);
                }

                for (Iterator itr3 = folio.getSalvedadesTMPs().iterator();
                        itr3.hasNext();) {
                    this.makeTransientSalvedadFolioTMP((SalvedadFolioTMP) itr3.next(),
                            pm);
                }

                for (Iterator itr4 = folio.getTurnosFolios().iterator();
                        itr4.hasNext();) {
                    this.makeTransientTurnoFolio((TurnoFolioEnhanced) itr4.next(),
                            pm);
                }

                for (Iterator itr5 = folio.getHistorialEstados().iterator();
                        itr5.hasNext();) {
                    this.makeTransientEstadoHistoria((EstadoHistoriaEnhanced) itr5.next(),
                            pm);
                }

                this.makeTransientZonaRegistral(folio.getZonaRegistral(), pm);
                this.makeTransientDocumento(folio.getDocumento(), pm);
                this.makeTransientDocumentoTMP(folio.getDocumentoTMP(), pm);

                try {
                    FolioDatosTMP fdt = folio.getDatosTMP();
                    pm.makeTransient(fdt.getTipoPredio());
                    this.makeTransientZonaRegistral(fdt.getZonaRegistral(), pm);
                    pm.makeTransient(fdt.getEstado());
                    pm.makeTransient(fdt);
                } catch (JDOObjectNotFoundException e) {
                    //folio.setDatosTMP(null);
                }

                pm.makeTransient(folio.getComplementacionTMP());
                pm.makeTransient(folio.getComplementacion());
                pm.makeTransient(folio.getEstado());
                pm.makeTransient(folio.getTipoPredio());
                pm.makeTransient(folio);
            } catch (JDOException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                throw new DAOException(e.getMessage(), e);
            }
        }
    }

    /**
     * Ordena una lista de direcciones por identificador transformado a número
     *
     * @param direcciones
     */
    protected void ordenarDirecciones(List direcciones) {
        Collections.sort(direcciones, new Comparator() {
            public int compare(Object o1, Object o2) {
                Direccion d1 = (Direccion) o1;
                Direccion d2 = (Direccion) o2;
                Integer i1 = new Integer(d1.getIdDireccion());
                Integer i2 = new Integer(d2.getIdDireccion());
                return i1.compareTo(i2);
            }
        });
    }

    /**
     * Valida que el usuario tenga bloqueado el folio respectivo, Si el folio no
     * está bloqueado o el usuario no existe o el usuario no es el dueño del
     * bloqueo se lanza una excepción
     *
     * @param datos
     * @param usuario
     * @param pm
     * @return
     * @throws DAOException
     */
    protected boolean validarBloqueoFolio(FolioEnhanced datos, Usuario usuario,
            PersistenceManager pm) throws DAOException {
        AnotacionTMP rta = null;
        UsuarioEnhanced us = null;

        try {
            //Validamos el usuario y si tiene acceso al folio
            //para modificarlo
            UsuarioEnhancedPk uid = new UsuarioEnhancedPk();
            uid.idUsuario = usuario.getIdUsuario();

            us = this.getUsuarioByID(uid, pm);

            if (us == null) {
                throw new DAOException("El usuario especificado no existe: "
                        + uid.idUsuario);
            }

            //Validamos si el folio está bloqueado
            BloqueoFolioEnhanced bloqueo = this.getBloqueoFolio(datos.getIdMatricula(),
                    pm);

            if (bloqueo == null) {
                throw new DAOException("La matricula " + datos.getIdMatricula() + " no se encuentra bloqueada");
            }

            //Validamos que el usuario sea dueño del bloqueo del folio
            UsuarioEnhanced usuAux = this.getUsuarioByLlaveBloqueo(bloqueo.getLlaveBloqueo(),
                    pm);

            if (usuAux == null) {
                throw new DAOException(
                        "Error en la obtención del usuario a partir de la llave de bloqueo");
            }

            if (usuAux.getIdUsuario() != us.getIdUsuario()) {
                throw new DAOException(
                        "El usuario no es dueño del bloqueo del folio con matrícula " + datos.getIdMatricula()
                        + ". El turno asociado a la matrícula es: " + bloqueo.getIdWorkflowBloqueo());
            }
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }

        return true;
    }

    /**
     * Servicio utilizado para establecer si el folio con el número de matrícula
     * posee alguna deuda
     *
     * @param matricula
     * @return true: folio debe dinero, false: folio libre de deudas
     * @throws ForsetiException
     */
    public boolean tieneDeudaFolio(String matricula) throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        boolean rta = false;

        try {
            Query query = pm.newQuery(SolicitudFolioEnhanced.class);
            query.declareVariables(
                    "LiquidacionEnhanced liq; PagoEnhanced pago; TurnoEnhanced turno");
            query.declareParameters("String matricula");
            query.setFilter("this.idMatricula==matricula &&\n"
                    + "(this.solicitud.liquidaciones.contains(liq) &&\n"
                    + "liq.valor>0 && !(pago.liquidacion==liq)) &&\n"
                    + "(turno.solicitud==this.solicitud) &&\n"
                    + "(turno.idCirculo==this.solicitud.circulo)");

            Collection col = (Collection) query.execute(matricula);

            Iterator iter = col.iterator();

            if (iter.hasNext()) {
                rta = true;
            }

            query.closeAll();
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        return rta;
    }

    /**
     * Obtiene los datos de antiguo sistema por ID
     *
     * @param oid
     * @param pm
     * @return
     * @throws DAOException
     */
    protected DatosAntiguoSistemaEnhanced getDatosAntiguoSistema(
            DatosAntiguoSistemaEnhancedPk oid, PersistenceManager pm)
            throws DAOException {
        DatosAntiguoSistemaEnhanced rta = null;

        if (oid.idDatosAntiguoSistema != null) {
            try {
                rta = (DatosAntiguoSistemaEnhanced) pm.getObjectById(oid, true);
            } catch (JDOObjectNotFoundException e) {
                rta = null;
            } catch (JDOException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                throw new DAOException(e.getMessage(), e);
            }
        }

        return rta;
    }

    /**
     * Obtiene el bloqueo del folio en caso que se encuentre bloqueado Si la
     * matricula NO está bloqueada returna null, si está bloqueada retorna un
     * usuario con la llave de bloqueo en la lista de sus llaves, y la llave con
     * el BloqueoFolio en la lista de sus bloqueos de folio. En el objeto
     * BloqueoFolio está la fecha de bloqueo y el turno (idWorkflowBloqueo) que
     * lo bloqueó
     *
     * @param fid
     * @return Hashtable
     * @throws DAOException
     */
    public Usuario getBloqueoFolio(FolioPk fid) throws DAOException {
        Hashtable hs = null;
        BloqueoFolio rta = null;
        BloqueoFolioEnhanced aux = null;
        LlaveBloqueo llave = null;
        LlaveBloqueoEnhanced llaveAux = null;
        UsuarioEnhanced usuAux = null;
        Usuario usuario = null;
        PersistenceManager pm = AdministradorPM.getPM();

        try {
            pm.currentTransaction().setOptimistic(false);
            pm.currentTransaction().begin();

            FolioEnhanced folio = this.getFolioByID(new FolioEnhancedPk(fid),
                    pm);

            if (folio == null) {
                throw new DAOException("El folio no existe");
            }

            aux = this.getBloqueoFolio(folio.getIdMatricula(), pm);

            if (aux != null) {
                llaveAux = aux.getLlaveBloqueo();
                usuAux = this.getUsuarioByLlaveBloqueo(llaveAux, pm);

                if (usuAux == null) {
                    throw new DAOException(
                            "Error en la obtención del usuario a partir de la llave de bloqueo");
                }

                pm.makeTransient(llaveAux);
                pm.makeTransient(usuAux);
                pm.makeTransient(aux);
            }

            pm.currentTransaction().commit();
        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (DAOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            throw e;
        } catch (Exception e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        if (aux != null) {
            hs = new Hashtable();
            rta = (BloqueoFolio) aux.toTransferObject();
            llave = (LlaveBloqueo) llaveAux.toTransferObject();
            usuario = (Usuario) usuAux.toTransferObject();

            llave.addBloqueoFolio(rta);
            usuario.addLlavesBloqueo(llave);
        }

        return usuario;
    }

    /**
     * Servicio utilizado para establecer si el folio con el número de matrícula
     * posee alguna deuda. Si No tiene deuda retorna null, si tiene deuda
     * retorna un Turno, con una solicitud, y con la liquidación la cual NO
     * tiene registrado el pago
     *
     * @param matricula
     * @return Turno
     * @throws DAOException
     */
    public Turno getTurnoDeudaFolio(FolioPk fid) throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        Turno turno = null;
        Solicitud solicitud = null;
        Liquidacion liquidacion = null;
        TurnoEnhanced turnoAux = null;
        SolicitudEnhanced solicitudAux = null;
        LiquidacionEnhanced liq = null;

        boolean rta = false;

        try {
            FolioEnhanced folio = this.getFolioByID(new FolioEnhancedPk(fid),
                    pm);

            if (folio == null) {
                throw new DAOException("El folio no existe");
            }

            Query query = pm.newQuery(SolicitudFolioEnhanced.class);
            query.declareVariables(
                    "LiquidacionEnhanced liq; PagoEnhanced pago; TurnoEnhanced turno");
            query.declareParameters("String matricula");
            query.setFilter("this.idMatricula==matricula &&\n"
                    + "(this.solicitud.liquidaciones.contains(liq) &&\n"
                    + "liq.valor>0 && !(pago.liquidacion==liq)) &&\n"
                    + "(turno.solicitud==this.solicitud) &&\n"
                    + "(turno.idCirculo==this.solicitud.circulo)");

            Collection col = (Collection) query.execute(folio.getIdMatricula());

            Iterator iter = col.iterator();

            if (iter.hasNext()) {
                SolicitudFolioEnhanced sf = (SolicitudFolioEnhanced) iter.next();
                PagoEnhanced pago;

                //Se busca la liquidación que tiene deuda
                boolean flag = true;

                for (Iterator it = sf.getSolicitud().getLiquidaciones()
                        .iterator(); it.hasNext() && flag;) {
                    try {
                        liq = (LiquidacionEnhanced) it.next();
                        pago = liq.getPago();
                    } catch (JDOObjectNotFoundException exc) {
                        flag = false;
                    }
                }

                if (flag) {
                    throw new DAOException(
                            "Error, no encontró la liquidación sin pago");
                }

                solicitudAux = sf.getSolicitud();
                turnoAux = this.getTurnoBySolicitud(solicitudAux, pm);
                pm.makeTransient(turnoAux);
                pm.makeTransient(solicitudAux);
                pm.makeTransient(liq.getUsuario());
                pm.makeTransient(liq);
            }

            query.closeAll();
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        if (turnoAux != null) {
            turno = (Turno) turnoAux.toTransferObject();
            solicitud = (Solicitud) solicitudAux.toTransferObject();
            liquidacion = (Liquidacion) liq.toTransferObject();
            solicitud.addLiquidacion(liquidacion);
            turno.setSolicitud(solicitud);
        }

        return turno;
    }

    /**
     * Obtiene la plantilla pertenencia que tiene la respuesta dada en el
     * parámetro
     *
     * @param repuesta
     * @param pm
     * @return
     * @throws DAOException
     */
    protected PlantillaPertenenciaEnhanced getPlantillaPertenenciaByRespuesta(
            String respuesta, PersistenceManager pm) throws DAOException {
        PlantillaPertenenciaEnhanced rta = null;

        try {
            Query query = pm.newQuery(PlantillaPertenenciaEnhanced.class);
            query.declareParameters("String rta");

            String filtro = "respuesta==rta";
            query.setFilter(filtro);

            Collection col = (Collection) query.execute(respuesta);

            Iterator it = col.iterator();

            if (!it.hasNext()) {
                rta = null;
            } else {
                rta = (PlantillaPertenenciaEnhanced) it.next();
            }

            query.closeAll();
        } catch (JDOObjectNotFoundException e) {
            rta = null;
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        }

        return rta;
    }

    /**
     * Obtiene la plantilla de pertenencia asociada a la respuesta especificada
     *
     * @param respuesta
     * @return
     * @throws DAOException
     */
    public PlantillaPertenencia getPlantillaPertenenciaByRespuesta(
            String respuesta) throws DAOException {
        PlantillaPertenenciaEnhanced ef = null;
        PersistenceManager pm = AdministradorPM.getPM();
        PlantillaPertenencia aux = null;

        try {
            ef = this.getPlantillaPertenenciaByRespuesta(respuesta, pm);
            pm.makeTransient(ef);
        } catch (DAOException e) {
            throw e;
        } finally {
            pm.close();
        }

        if (ef != null) {
            aux = (PlantillaPertenencia) ef.toTransferObject();
        }

        return aux;
    }

    /**
     * Actualiza la despcripción de un oficio de pertenencia dada su respuesta
     *
     * @param respuesta
     * @return
     * @throws DAOException
     */
    public boolean updatePlantillaPertenenciaByRespuesta(String respuesta,
            String nuevaDescripcion) throws DAOException {
        PlantillaPertenenciaEnhanced ef = null;
        PersistenceManager pm = AdministradorPM.getPM();
        PlantillaPertenencia aux = null;

        try {
            pm.currentTransaction().begin();
            ef = this.getPlantillaPertenenciaByRespuesta(respuesta, pm);

            if (ef == null) {
                throw new DAOException(
                        "La plantilla que está intentando actualizar no existe con la respuesta: "
                        + respuesta);
            }

            ef.setDescripcion(nuevaDescripcion);
            pm.currentTransaction().commit();
        } catch (DAOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            throw e;
        } catch (Exception e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        return true;
    }

    /**
     * Actualizar la descripción de una complementación cuando esta tiene
     * conflictos con la complementación del sistema FOLIO.
     *
     * @param complementacion
     * @param usuario
     * @return
     * @throws DAOException
     */
    public boolean updateComplementacionConflictiva(Complementacion complementacion, Usuario usuario) throws DAOException {

        if (complementacion == null || complementacion.getIdComplementacion() == null) {
            throw new DAOException("No es posible agregar los folios relacionados del turno anterior, la solicitud no es válida");
        }

        PersistenceManager pm = AdministradorPM.getPM();
        try {

            pm.currentTransaction().begin();

            //SE ACTUALIZA LA AUDITORIA DE LA TABLA COMPLEMENTACIÓN SIR_NE_COMP_CONFLIC_AUDITORIA
            ComplementacionEnhancedPk idComplementacion = new ComplementacionEnhancedPk();
            idComplementacion.idComplementacion = complementacion.getIdComplementacion();
            ComplementacionEnhanced complementacionEnh = (ComplementacionEnhanced) pm.getObjectById(idComplementacion, true);

            UsuarioEnhancedPk oid = new UsuarioEnhancedPk();
            oid.idUsuario = usuario.getIdUsuario();
            UsuarioEnhanced userE = (UsuarioEnhanced) pm.getObjectById(oid, true);

            long idSecuencial = this.getSecuencial(CSecuencias.SECUENCIA_AUDITORIA_COMP_CONF, pm);
            int idSec = (int) idSecuencial;

            ComplementacionConflictivaAuditoriaEnhanced compAuditoria = new ComplementacionConflictivaAuditoriaEnhanced();
            compAuditoria.setIdAuditoria(String.valueOf(idSec));
            compAuditoria.setIdComplementacion(complementacionEnh.getIdComplementacion());
            compAuditoria.setComplementacion(complementacionEnh.getComplementacion());
            compAuditoria.setComplementacionConflictiva(complementacionEnh.getComplementacionConflictiva());
            compAuditoria.setFechaCreacion(new Date());
            compAuditoria.setUsuario(userE);
            pm.makePersistent(compAuditoria);

            //SE ACTUALIZA LA COMPLEMENTACIÓN DEL FOLIO CON LA INFORMACIÓN ENVIADA, UNA VEZ GUARDADA LA AUDITORIA
            complementacionEnh.setComplementacion(complementacion.getComplementacion());
            complementacionEnh.setComplementacionConflictiva(null);

            try {
                ComplementacionTMPPk idComTMP = new ComplementacionTMPPk();
                idComTMP.idComplementacionTmp = complementacion.getIdComplementacion();
                ComplementacionTMP comTMP = (ComplementacionTMP) pm.getObjectById(idComTMP, true);
                if (comTMP != null) {
                    comTMP.setComplementacion(complementacion.getComplementacion());
                    pm.makePersistent(comTMP);
                }
            } catch (JDOException e) {
            } catch (Exception e) {
            }

            pm.makePersistent(complementacionEnh);
            pm.currentTransaction().commit();

        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (Throwable e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        return true;
    }

    /**
     * Obtiene la lista de las platilla de pertenencia configuradas en el
     * sistema
     *
     * @param pm
     * @return
     * @throws DAOException
     */
    protected List getPlantillaPertenencias(PersistenceManager pm)
            throws DAOException {
        try {
            Query query = pm.newQuery(PlantillaPertenenciaEnhanced.class);
            query.setOrdering("respuesta ascending");

            List rta = (List) query.execute();

            return rta;
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }
    }

    /**
     * Obtiene la lista de las platilla de pertenencia configuradas en el
     * sistema
     *
     * @return
     * @throws DAOException
     */
    public List getPlantillaPertenencias() throws DAOException {
        List rta = null;
        PersistenceManager pm = AdministradorPM.getPM();

        try {
            rta = this.getPlantillaPertenencias(pm);
            pm.makeTransientAll(rta);
        } catch (DAOException e) {
            throw e;
        } finally {
            pm.close();
        }

        return TransferUtils.makeTransferAll(rta);
    }

    /**
     * Valida un orden asignado a una anotación dentro del folio
     *
     * @param folio
     * @param nuevoOrden
     * @param pm
     * @throws DAOException
     */
    protected long validarYObtenerOrden(FolioEnhanced folio, String nuevoOrden,
            PersistenceManager pm) throws DAOException {
        //1. Validar que el orden asignado sea numérico:
        Long ordenNum = null;

        try {
            ordenNum = Long.valueOf(nuevoOrden);
        } catch (java.lang.NumberFormatException nfe) {
            throw new DAOException("El orden insertado es inválido: "
                    + nuevoOrden);
        }

        //2. Validar el nuevo orden asignado:
        long tam = this.getNextOrdenAnotacion(folio, pm);

        if (ordenNum.longValue() > (tam - 1)) {
            throw new DAOException(
                    "El orden insertado supera el número de anotaciones: "
                    + nuevoOrden);
        }

        return ordenNum.longValue();
    }

    /**
     * Obtiene el LPAD de un número, es decir un número de 6 dígitos completado
     * con ceros a la izquierda
     *
     * @param num
     * @return
     * @throws DAOException
     */
    protected String getLPAD(String num) throws DAOException {
        String rta = "";

        if (num.length() > 6) {
            throw new DAOException("El número tiene más de 6 dígitos: " + num);
        }

        int numCerosToInsert = 6 - num.length();

        for (int i = 0; i < numCerosToInsert; i++) {
            rta = rta + "0";
        }

        return rta + num;
    }

    /**
     * Actualiza el orden de las anotaciones que se encuentren en el rango
     * determinado con el delta dado, se actualiza a partir de la siguiente
     * anotación de la primera, la primera y la última se puede incluir
     * dependiendo del parámetro dado en incluirUltima
     *
     * @param folio
     * @param ordenAnterior
     * @param nuevoOrdenLPAD
     * @param i
     * @param incluirAnotacionLimite true: Incluye la primera y NO la última
     * false: Incluye la última y NO la primera
     * @param pm
     */
    protected void actualizarOrdenAnotaciones(FolioEnhanced folio,
            String fromOrden, String toOrden, int delta,
            boolean incluirAnotacionLimite, UsuarioEnhanced usuario, TurnoEnhanced turno,
            PersistenceManager pm) throws DAOException {
        try {
            String filtro;
            //*String obsoleto = CEstadoAnotacion.OBSOLETA;
            long num;

            if (incluirAnotacionLimite) {
                filtro = "this.folio==folio && this.ordenLPAD>=lpadFrom && this.ordenLPAD<lpadTo ";
                //*filtro = "this.folio==folio && this.ordenLPAD>=lpadFrom && this.ordenLPAD<lpadTo && this.estado.idEstadoAn!='" +
                //*obsoleto + "'";
            } else {
                filtro = "this.folio==folio && this.ordenLPAD>lpadFrom && this.ordenLPAD<=lpadTo ";
                //*filtro = "this.folio==folio && this.ordenLPAD>lpadFrom && this.ordenLPAD<=lpadTo && this.estado.idEstadoAn!='" +
                //*obsoleto + "'";                
            }

            //1. Consulta:  Se revisan las anotaciones temporales que están actualizando anotaciones
            //              definitivas, con el fin de afectar su orden:
            Query query3 = pm.newQuery(AnotacionTMP.class);
            query3.declareParameters(
                    "String lpadFrom, String lpadTo, FolioEnhanced folio");
            query3.declareVariables("AnotacionEnhanced anota");

            //Contar solamente las anotaciones temporales creadas para actualizar ORDEN de definitivas
            String filtro3 = filtro + " && (anota.folio==folio \n"
                    + "&& anota.idAnotacion==this.idAnotacionTmp) && (this.orden != null)";

            query3.setFilter(filtro3);

            Collection col3 = (Collection) query3.execute(fromOrden, toOrden,
                    folio);

            for (Iterator iter3 = col3.iterator(); iter3.hasNext();) {
                AnotacionTMP anotaciontmp = (AnotacionTMP) iter3.next();
                num = Long.parseLong(anotaciontmp.getOrden());
                anotaciontmp.setOrden(String.valueOf(num + delta));
            }

            //2. Consulta:  Se revisan las anotaciones definitivas que NO se están actualizando
            //              con el fin de afectar su orden
            Query query = pm.newQuery(AnotacionEnhanced.class);
            query.declareParameters(
                    "String lpadFrom, String lpadTo, FolioEnhanced folio");
            query.declareVariables("AnotacionTMP anota; AnotacionTMP anota2");

            //Contar solamente las anotaciones definitivas sin correspondiente en anotaciones temporales
            //que estén actualizando su orden
            String filtro1 = filtro + " && (!(anota.folio==folio \n"
                    + "&& anota.idAnotacionTmp==this.idAnotacion) || (anota2.folio==folio && anota2.idAnotacionTmp==this.idAnotacion && anota2.orden==null))";
            query.setFilter(filtro1);

            Collection col = (Collection) query.execute(fromOrden, toOrden,
                    folio);

            for (Iterator iter = col.iterator(); iter.hasNext();) {
                AnotacionEnhanced anotacionenhanced = (AnotacionEnhanced) iter.next();

                //Actualizar anotación definitiva:
                AnotacionTMP anotaTMP = new AnotacionTMP();
                anotaTMP.setIdAnotacionTmp(anotacionenhanced.getIdAnotacion());
                anotaTMP.setIdMatricula(anotacionenhanced.getIdMatricula());
                num = Long.parseLong(anotacionenhanced.getOrden());
                anotaTMP.setOrden(String.valueOf(num + delta));
                this.actualizarAnotacion(folio, anotacionenhanced, anotaTMP,
                        usuario, false, turno, pm);
            }

            Query query2 = pm.newQuery(AnotacionTMP.class);
            query2.declareParameters(
                    "String lpadFrom, String lpadTo, FolioEnhanced folio");
            query2.declareVariables("AnotacionEnhanced anota");

            //No contar las anotaciones temporales creadas para actualizar definitivas
            //Solamente las nuevas anotaciones
            filtro = filtro + " && !(anota.folio==folio \n"
                    + "&& anota.idAnotacion==this.idAnotacionTmp)";

            query2.setFilter(filtro);

            Collection col2 = (Collection) query2.execute(fromOrden, toOrden,
                    folio);

            for (Iterator iter2 = col2.iterator(); iter2.hasNext();) {
                AnotacionTMP anotaciontmp = (AnotacionTMP) iter2.next();
                num = Long.parseLong(anotaciontmp.getOrden());
                anotaciontmp.setOrden(String.valueOf(num + delta));
            }
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (java.lang.NumberFormatException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }
    }

    /**
     * Actualiza los datos de una naturaleza jurídica.
     *
     * @param cid
     * @param dato
     * @return
     * @throws DAOException
     */
    public boolean updateNaturalezaJuridica(NaturalezaJuridica naturaleza, Usuario usuario)
            throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();

        try {
            //pm.currentTransaction().setOptimistic(false);
            pm.currentTransaction().begin();

            NaturalezaJuridicaEnhancedPk natID = new NaturalezaJuridicaEnhancedPk();
            natID.idNaturalezaJuridica = naturaleza.getIdNaturalezaJuridica();

            //	Traer Objeto Persistente
            NaturalezaJuridicaEnhanced objPers = this.getNaturalezaJuridica(natID,
                    pm);

            UsuarioEnhancedPk usuarioEnhId = new UsuarioEnhancedPk();
            usuarioEnhId.idUsuario = usuario.getIdUsuario();
            UsuarioEnhanced usuarioEnh = (UsuarioEnhanced) pm.getObjectById(usuarioEnhId, true);

            objPers.setUsuario(usuarioEnh);
            if (objPers == null) {
                throw new DAOException(
                        "No existe la naturaleza jurídica con el id "
                        + naturaleza.getIdNaturalezaJuridica());
            }

            if (naturaleza.getNombre() != null) {
                objPers.setNombre(naturaleza.getNombre());
            }

            objPers.setHabilitadoCalificacion(naturaleza.isHabilitadoCalificacion());

            if (naturaleza.getDominioNaturalezaJuridica() != null) {
                DominioNaturalezaJuridicaEnhancedPk dnid = new DominioNaturalezaJuridicaEnhancedPk();
                dnid.idDominioNatJur = naturaleza.getDominioNaturalezaJuridica()
                        .getIdDominioNatJur();

                DominioNaturalezaJuridicaEnhanced dominio = this.getDominioNaturalezaJuridica(dnid,
                        pm);

                // Bug 5449: Algunas naturalezas juridicas no tienen dominio
                /*if (dominio == null) {
                    throw new DAOException(
                        "No encontró un dominio de naturaleza jurídica con el ID: " +
                        dnid.idDominioNatJur);
                }*/
                objPers.setDominioNaturalezaJuridica(dominio);
            } else {
                objPers.setDominioNaturalezaJuridica(null);
            }

            if (naturaleza.getGrupoNaturalezaJuridica() != null) {
                //Validación del grupo de la naturaleza juridica
                GrupoNaturalezaJuridicaEnhancedPk gid = new GrupoNaturalezaJuridicaEnhancedPk();
                gid.idGrupoNatJuridica = naturaleza.getGrupoNaturalezaJuridica().getIdGrupoNatJuridica();

                GrupoNaturalezaJuridicaEnhanced vcir = this.getGrupoNaturalezaJuridica(gid, pm);

                if (vcir == null) {
                    throw new DAOException(
                            "No existe un grupo de naturaleza jurídica con el identificador: "
                            + gid.idGrupoNatJuridica);
                }

                objPers.setGrupoNaturalezaJuridica(vcir);
            }

            pm.currentTransaction().commit();
        } catch (Throwable e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        return true;
    }

    /**
     * Retorna una cadena de caracteres que representa la fecha dada.
     *
     * @param fecha.
     * @return
     */
    protected String getFecha(Date fecha) {
        Calendar c = Calendar.getInstance();
        String fechaString = " ";
        if (fecha != null) {
            c.setTime(fecha);
            fechaString
                    = c.get(Calendar.DAY_OF_MONTH)
                    + "/"
                    + (c.get(Calendar.MONTH) + 1)
                    + "/"
                    + c.get(Calendar.YEAR);
        }
        return fechaString;
    }

    /**
     * Retorna una cadena de caracteres que representa el nuevo lindero del
     * folio creado a partir de una segregación
     *
     * @param fd
     * @param doc
     * @param pm
     * @return String
     */
    protected String contruirLindero(FolioDerivadoTMP fd, DocumentoEnhanced doc, PersistenceManager pm) {
        //El lindero queda de la siguiente manera:
        //NOMBRE_LOTE con extensión de AREA cuyos linderos y demás especificaciones obran en TIPO_DOC NUM, FECHA,
        //OFICINA_PROC. Artículo 11 Decreto 1711 de 1984

        String NOMBRE_LOTE = "";
        if (fd.getLote() != null) {
            NOMBRE_LOTE = fd.getLote();
        }

        String AREA = "";
        if (fd.getArea() != null) {
            AREA = fd.getArea();
        }

        String HECTAREAS = "";
        if (fd.getHectareas() != null) {
            HECTAREAS = fd.getHectareas();
        }

        String METROS = "";
        if (fd.getMetros() != null) {
            METROS = fd.getMetros();
        }

        String CENTIMETROS = "";
        if (fd.getCentimetros() != null) {
            CENTIMETROS = fd.getCentimetros();
        }

        String PORCENTAJE = "";
        if (fd.getPorcentaje() != null) {
            PORCENTAJE = fd.getPorcentaje();
            if ((PORCENTAJE.lastIndexOf("%") == -1) && (PORCENTAJE.length() >= 1)) {
                PORCENTAJE = PORCENTAJE + "%";
            }
        }

        String TIPO_DOC = "";
        if (doc.getTipoDocumento() != null) {
            TIPO_DOC = doc.getTipoDocumento().getNombre();
        }

        String NUM = "";
        if (doc.getNumero() != null) {
            NUM = doc.getNumero();
        }

        String FECHA = "";
        if (doc.getFecha() != null) {
            FECHA = this.getFecha(doc.getFecha());
        }

        String OFICINA_PROC = "";
        if (doc.getOficinaOrigen() != null) {
            if (doc.getOficinaOrigen().getNombre() != null) {
                OFICINA_PROC = doc.getOficinaOrigen().getNombre();
            } else {
                OFICINA_PROC = doc.getOficinaOrigen().getTipoOficina().getNombre();
                if (doc.getOficinaOrigen().getNumero() != null) {
                    OFICINA_PROC = OFICINA_PROC + " " + doc.getOficinaOrigen().getNumero();
                }
            }
        }

        String OFICINA_MUNICIPIO = "";
        if (doc.getOficinaOrigen() != null) {
            if (doc.getOficinaOrigen().getVereda() != null) {
                if (doc.getOficinaOrigen().getVereda().getMunicipio() != null) {
                    if (doc.getOficinaOrigen().getVereda().getMunicipio().getNombre() != null) {
                        OFICINA_MUNICIPIO = " de " + doc.getOficinaOrigen().getVereda().getMunicipio().getNombre();
                    }
                }
            }
        }

        /**
         * @Autor: Edgar Lora
         * @Mantis: 0013038
         * @Requerimiento: 060_453
         */
        String lindero = NOMBRE_LOTE + " con extensión de " + AREA + HECTAREAS + (!HECTAREAS.equals("") ? " Hectareas " : "") + METROS + (!METROS.equals("") ? " Metros " : "")
                + CENTIMETROS + (!CENTIMETROS.equals("") ? " Centimetros " : "") + " " + PORCENTAJE + " cuyos linderos y demás especificaciones obran en "
                + TIPO_DOC + " " + NUM + ", " + FECHA + ", " + OFICINA_PROC + OFICINA_MUNICIPIO + ". Articulo 8 Parágrafo 1º. de la Ley 1579 de 2012";

        return lindero;
    }

    /**
     * Obtiene una anotación definitiva o temporal por el orden. Obtiene los
     * datos básicos de la anotación sin dependencias.
     *
     * @param oid
     * @param orden
     * @param usuario
     * @return
     * @throws DAOException
     */
    public Anotacion getAnotacionByOrden(FolioPk oid, String orden, Usuario usuario) throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        Anotacion rta = null;
        boolean found = false;
        AnotacionTMP anotaciontmp = null;
        AnotacionEnhanced anota = null;
        String ord = this.getLPAD(orden);

        try {
            FolioEnhanced fol = this.getFolioByID(new FolioEnhancedPk(oid), pm);

            if (fol == null) {
                throw new DAOException(
                        "El folio especificado no existe. Matricula: "
                        + oid.idMatricula);
            }

            //Validar bloqueo del folio
            if (usuario != null) {
                this.validarBloqueoFolio(fol, usuario, pm);
            }

            Query query = pm.newQuery(AnotacionTMP.class);
            query.declareParameters("FolioEnhanced fol, String ord");
            query.setFilter("this.folio == fol &&\n"
                    + "this.ordenLPAD == ord ");
            //*"this.ordenLPAD == ord  && this.estado.idEstadoAn!='" +
            //*CEstadoAnotacion.OBSOLETA + "' ");

            Collection col = (Collection) query.execute(fol, ord);
            Iterator iter = col.iterator();

            if (iter.hasNext()) {
                anotaciontmp = (AnotacionTMP) iter.next();
                this.makeTransientAnotacionTMP(anotaciontmp, pm, new ArrayList());
                found = true;
            }

            if (!found) {
                //se busca entre las anotaciones definitivas
                query = pm.newQuery(AnotacionEnhanced.class);
                query.declareParameters("FolioEnhanced fol, String ord");
                query.setFilter("this.folio == fol &&\n"
                        + "this.ordenLPAD == ord && (this.link==null || this.link==false)");
                //*"this.ordenLPAD == ord  && this.estado.idEstadoAn!='" +
                //*CEstadoAnotacion.OBSOLETA + "' && (this.link==null || this.link==false)");

                col = (Collection) query.execute(fol, ord);
                iter = col.iterator();
                if (iter.hasNext()) {
                    anota = (AnotacionEnhanced) iter.next();
                    pm.makeTransient(anota);
                    found = true;
                }
            }

        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        if (found) {
            if (anotaciontmp != null) {
                anota = anotaciontmp.getDefinitivo(new ArrayList());
                anota.setTemporal(true);
            }
            rta = (Anotacion) anota.toTransferObject();
        }

        return rta;
    }

    /**
     * Obtiene una lista de anotaciones temporales a partir de dos rangos por el
     * orden. Obtiene los datos básicos de la anotación sin dependencias.
     *
     * @param oid
     * @param ordenInicial
     * @param ordenFinal
     * @param usuario
     * @return
     * @throws DAOException
     */
    public List getAnotacionesTemporalesByRangoOrden(FolioPk oid, String ordenInicial, String ordenFinal, Usuario usuario) throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();

        List rta = new ArrayList(10);
        boolean found = false;

        String ordInicial = this.getLPAD(ordenInicial);
        String ordFinal = this.getLPAD(ordenFinal);

        AnotacionTMP anotacionTemporal = null;
        AnotacionEnhanced anota = null;

        try {
            FolioEnhanced fol = this.getFolioByID(new FolioEnhancedPk(oid), pm);

            if (fol == null) {
                throw new DAOException(
                        "El folio especificado no existe. Matricula: "
                        + oid.idMatricula);
            }

            //Validar bloqueo del folio
            if (usuario != null) {
                this.validarBloqueoFolio(fol, usuario, pm);
            }

            Query query = pm.newQuery(AnotacionTMP.class);
            query.declareParameters("FolioEnhanced fol, String ordenInicial, String ordenFinal");
            query.declareVariables("AnotacionEnhanced anota");

            query.setFilter("this.folio == fol "
                    + " && this.ordenLPAD >= ordenInicial"
                    + " && this.ordenLPAD <= ordenFinal "
                    + " && !(anota.folio==fol \n" + "&& anota.idAnotacion==this.idAnotacionTmp)");
            //+ " && this.estado.idEstadoAn!='" + CEstadoAnotacion.OBSOLETA + "' " );
            //*+ " && this.estado.idEstadoAn!='" + CEstadoAnotacion.OBSOLETA + "' " );

            Collection col = (Collection) query.execute(fol, ordInicial, ordFinal);

            for (Iterator iter = col.iterator(); iter.hasNext();) {
                anotacionTemporal = (AnotacionTMP) iter.next();
                this.makeTransientAnotacionTMP(anotacionTemporal, pm, new ArrayList());

                anota = anotacionTemporal.getDefinitivo(new ArrayList());
                anota.setTemporal(true);

                rta.add(anota);
            }

        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        List rtaTransfer = new ArrayList();
        Iterator itRta = rta.iterator();
        while (itRta.hasNext()) {
            AnotacionEnhanced anot = (AnotacionEnhanced) itRta.next();
            rtaTransfer.add(anot.toTransferObject());
        }

        return rtaTransfer;
    }

    /**
     * Copia una anotación canceladora a otros folios, cada folio debe tener un
     * objeto anotación con el identificador de la anotación que se quiere
     * cancelar
     *
     * @param idAnotacion
     * @param folios
     * @param usuario Usuario que esta realizando la copia de anotaciones
     * @param copiarComentario Booleano que determina si se debe copiar o no el
     * comentario de la anotación origen
     * @return
     * @throws DAOException
     */
    public boolean copiarAnotacionCanceladora(AnotacionPk idAnotacion, List folios, Usuario usuario, boolean copiarComentario) throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        List errores = new ArrayList();
        DAOException exc = new DAOException("Error copiado la anotación");
        Hashtable ht = new Hashtable();
        AnotacionTMP nuevaAnotacion;
        AnotacionTMP anotaToCancel;
        FolioPk idFolioDestino;

        AnotacionTMPPk anID = new AnotacionTMPPk();
        anID.idAnotacionTmp = idAnotacion.idAnotacion;
        anID.idMatricula = idAnotacion.idMatricula;

        try {
            pm.currentTransaction().setOptimistic(false);
            pm.currentTransaction().begin();

            //Se trae a persistente el usuario porque se necesita en el servicio
            //que inserta la anotación
            UsuarioEnhancedPk usID = new UsuarioEnhancedPk();
            usID.idUsuario = usuario.getIdUsuario();
            UsuarioEnhanced us = this.getUsuarioByID(usID, pm);

            //Se recorre la lista de foliosID para insertar la anotación transiente
            //a cada uno de ellos
            for (Iterator it = folios.iterator(); it.hasNext();) {
                Folio folioVal = (Folio) it.next();
                try {
                    idFolioDestino = new FolioPk();
                    idFolioDestino.idMatricula = folioVal.getIdMatricula();

                    FolioEnhanced folioDestino = this.getFolioByID(new FolioEnhancedPk(idFolioDestino), pm);
                    if (folioDestino == null) {
                        throw new DAOException("El folio no existe: " + idFolioDestino.idMatricula);
                    }

                    //Se valida el bloqueo
                    this.validarBloqueoFolio(folioDestino, usuario, pm);

                    //Se valida la anotación a cancelar:
                    if (folioVal.getAnotaciones().isEmpty()) {
                        throw new DAOException("El folio " + folioVal.getIdMatricula() + " no tiene la anotación a cancelar");
                    }

                    Anotacion toCancelar = (Anotacion) folioVal.getAnotaciones().get(0);

                    //Se valida la existencia de la anotación a cancelar (Debe ser definitiva)
                    AnotacionEnhancedPk toCancelID = new AnotacionEnhancedPk();
                    toCancelID.idAnotacion = toCancelar.getIdAnotacion();
                    toCancelID.idMatricula = toCancelar.getIdMatricula();

                    AnotacionEnhanced toCancelEnh = this.getAnotacionByID(toCancelID, pm);

                    if (toCancelEnh == null) {
                        throw new DAOException("La anotación que quiere cancelar no existe");
                    }

                    //Se valida que la anotación a cancelar no sea canceladora
                    if (!toCancelEnh.getAnotacionesCancelacions().isEmpty()) {
                        throw new DAOException("La anotación que quiere cancelar es canceladora");
                    }

                    //Se valida la anotación a copiar (canceladora):
                    AnotacionTMP anotaCanceladora = this.getAnotacionTMPByID(anID, pm);

                    if (anotaCanceladora == null) {
                        throw new DAOException("La anotación a copiar NO existe");
                    }

                    //Se valida que la anotación sea canceladora:
                    if (anotaCanceladora.getAnotacionesCancelacionTMPs().isEmpty()) {
                        throw new DAOException("La anotación NO es canceladora");
                    }

                    //Se crea la copia de la nueva anotación
                    nuevaAnotacion = new AnotacionTMP(anotaCanceladora.getDefinitivo(new ArrayList()), new ArrayList());

                    //Se crea la copia de la anotacion a cancelar:
                    anotaToCancel = new AnotacionTMP(toCancelEnh, new ArrayList());

                    //Se le quita las cancelaciones a la nuevaAnotacion:
                    nuevaAnotacion.removeAllAnotacionesCancelacionTMP();

                    //En este punto ya tenemos las dos anotaciones transientes: nuevaAnotacion y anotaToCancel
                    //para asociarlas en una cancelación y hacerlas persistentes:
                    CancelacionTMP cancel = new CancelacionTMP();
                    cancel.setCanceladaDef(toCancelEnh);
                    //nuevaAnotacion.setCrearCancelada(true);
                    nuevaAnotacion.addAnotacionesCancelacionTMP(cancel);

                    //Se llama al servicio que ingresa una anotación transiente temporal
                    //a un folio persistente:
                    nuevaAnotacion.setIdAnotacionTmp(null);

                    if (!copiarComentario) {
                        nuevaAnotacion.setComentario(null);
                    }

                    //Asignación de orden:
                    nuevaAnotacion.setOrden(String.valueOf(this.getNextOrdenAnotacion(
                            folioDestino, pm)));

                    this.addAnotacionTMPToFolio(folioDestino, nuevaAnotacion, us, null, pm);
                    pm.makePersistent(nuevaAnotacion);

                } catch (DAOException e) {
                    List l = new ArrayList();
                    l.add(e.getMessage());
                    ht.put(folioVal.getIdMatricula(), l);
                }
            }
            if (ht.size() > 0) {
                exc.setHashErrores(ht);
                throw exc;
            }
            pm.currentTransaction().commit();

        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (DAOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            throw e;
        } catch (Exception e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }
        return true;
    }

    /**
     * Devuelve una hashtable en donde para cada matrícula (key) especifica si
     * tiene o no nuevas anotaciones temporales Boolean (valor)
     *
     * @param turnoID
     * @return
     * @throws DAOException
     */
    public Hashtable validarNuevasAnotacionesTurno(TurnoPk turnoID) throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        Hashtable rta = new Hashtable();
        try {
            TurnoEnhanced turno = this.getTurnoByID(new TurnoEnhancedPk(turnoID), pm);
            if (turno == null) {
                throw new DAOException("El turno no existe");
            }

            SolicitudEnhanced solicitud = turno.getSolicitud();
            boolean tieneAnotacionesTMP;
            SolicitudFolioEnhanced sf;
            for (Iterator it = solicitud.getSolicitudFolios().iterator(); it.hasNext();) {
                sf = (SolicitudFolioEnhanced) it.next();
                tieneAnotacionesTMP = false;
                if (this.getCountAnotacionesTMPFolio(sf.getFolio(), pm) > 0) {
                    tieneAnotacionesTMP = true;
                }
                rta.put(sf.getFolio().getIdMatricula(), new Boolean(tieneAnotacionesTMP));
            }

        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (DAOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw e;
        } finally {
            pm.close();
        }

        return rta;
    }

    /**
     * Indica si un folio se encuentra asociado a un turno activo que se
     * encuentre en calificación
     *
     * @param folioID
     * @return
     * @throws DAOException
     */
    public boolean isFolioInTurnoCalificacion(FolioPk folioID) throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        boolean rta = false;
        try {
            Query query = pm.newQuery(SolicitudFolioEnhanced.class);
            query.declareVariables("TurnoEnhanced turno");
            query.declareParameters("String idMat,String faseCal");
            query.setFilter("this.idMatricula == idMat &&\n"
                    + "turno.solicitud == this.solicitud &&\n"
                    + "turno.idFase == faseCal &&\n"
                    + "turno.fechaFin == null &&\n"
                    + "turno.idCirculo==this.solicitud.circulo");
            Collection col = (Collection) query.execute(folioID.idMatricula, CFase.CAL_CALIFICACION);

            Iterator iter = col.iterator();
            if (iter.hasNext()) {
                rta = true;
            }
            query.closeAll();

        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        return rta;
    }

    /**
     * Obtiene una categoría por el id
     *
     * @param oid
     * @param pm
     * @return
     * @throws DAOException
     */
    protected CategoriaEnhanced getCategoriaById(
            CategoriaEnhancedPk oid, PersistenceManager pm) throws DAOException {
        CategoriaEnhanced rta = null;

        if (oid.idCategoria != null) {
            try {
                rta = (CategoriaEnhanced) pm.getObjectById(oid, true);
            } //Se lanza una excepción si no se encuentra una Minuta con el identificador
            //recibido como parámetro.
            catch (JDOObjectNotFoundException e) {
                rta = null;
            } catch (JDOException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                throw new DAOException(e.getMessage(), e);
            }
        }

        return rta;
    }

    /**
     * Indica si un turno tiene datos temporales realizados por el turno
     * indicado
     *
     * @param turnoID
     * @param folioID
     * @return true: El turno está realizando cambios sobre el folio false: El
     * turno NO está realizando cambios sobre el folio
     * @throws DAOException
     */
    public boolean hasDatosTemporalesTurno(TurnoPk turnoID, FolioPk folioID) throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        boolean rta = false;
        try {
            TurnoEnhanced turno = this.getTurnoByID(new TurnoEnhancedPk(turnoID), pm);
            if (turno == null) {
                throw new DAOException("El turno indicado no existe");
            }

            FolioEnhanced folio = this.getFolioByID(new FolioEnhancedPk(folioID), pm);

            if (folio == null) {
                throw new DAOException("El folio indicado no existe");
            }

            //Se verifica si el folio se encuentra bloqueado por el turno
            if (this.isBloqueadoByTurno(turno, folio, pm)) {
                //Se verifica si el folio tiene datos temporales
                // @author     : Ellery David Robles G.
                // @casoMantis : 08523.
                if (this.hasDatosTemporales2(turno, folio, pm)) {
                    rta = true;
                }
            }

        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        return rta;
    }

    /**
     * Indica si un folio tiene datos temporales
     *
     * @param turnoID
     * @param folioID
     * @return true: El turno está realizando cambios sobre el folio false: El
     * turno NO está realizando cambios sobre el folio
     * @throws DAOException
     */
    public boolean hasDatosTemporalesFolio(FolioPk folioID) throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        boolean rta = false;
        try {

            FolioEnhanced folio = this.getFolioByID(new FolioEnhancedPk(folioID), pm);

            if (folio == null) {
                throw new DAOException("El folio indicado no existe");
            }

            if (this.hasDatosTemporales(folio, pm)) {
                rta = true;
            }

        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        return rta;
    }

    /**
     * Indica si el folio se encuentra bloqueado en el turno
     *
     * @param turno
     * @param folio
     * @return
     */
    public boolean isBloqueadoByTurno(TurnoPk turnoID, FolioPk folioID) throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();

        TurnoEnhanced turno = this.getTurnoByID(new TurnoEnhancedPk(turnoID), pm);

        if (turno == null) {
            throw new DAOException("El turno indicado no existe");
        }
        FolioEnhanced folio = this.getFolioByID(new FolioEnhancedPk(folioID), pm);

        if (folio == null) {
            throw new DAOException("El folio indicado no existe");
        }
        return (isBloqueadoByTurno(turno, folio, pm));
    }

    /**
     * Indica si el folio se encuentra bloqueado en el turno
     *
     * @param turno
     * @param folio
     * @param pm
     * @return
     */
    private boolean isBloqueadoByTurno(TurnoEnhanced turno, FolioEnhanced fol, PersistenceManager pm) {
        boolean rta = false;
        Query query = pm.newQuery(BloqueoFolioEnhanced.class);
        query.declareParameters("FolioEnhanced fol, String idWork");
        query.setFilter("this.folio==fol &&\n"
                + "this.fechaDesbloqueo == null &&\n"
                + "this.idWorkflowBloqueo == idWork");
        Collection col = (Collection) query.execute(fol, turno.getIdWorkflow());
        Iterator iter = col.iterator();
        if (iter.hasNext()) {
            rta = true;
        }
        query.closeAll();
        return rta;
    }

    /**
     * Indica si el folio tiene información temporal
     *
     * @param folio
     * @param pm
     * @return
     */
    private boolean hasDatosTemporales(FolioEnhanced folio, PersistenceManager pm) {
        boolean rta = false;
        //Si el folio NO es definitivo y es creado por el turno la respuesta es afirmativa
        if (!folio.isDefinitivo()) {
            rta = true;
        }

        //Se mira los datos temporales de folio
        if (!rta) {
            try {
                FolioDatosTMP folioTMP = folio.getDatosTMP();
                if (folioTMP != null) {
                    rta = true;
                }
            } catch (JDOObjectNotFoundException e) {
            }
        }

        //Se mira si tiene complementacion o documento temporal
        if (!rta) {
            if ((folio.getComplementacionTMP() != null) || (folio.getDocumentoTMP() != null)) {
                rta = true;
            }
        }

        //Se revisa si tiene direcciones temporales
        if (!rta) {
            if (!folio.getDireccionesTMPs().isEmpty()) {
                rta = true;
            }
        }

        //Se revisa si tiene salvedades temporales
        if (!rta) {
            if (!folio.getSalvedadesTMPs().isEmpty()) {
                rta = true;
            }
        }

        //Por último se revisa si tiene anotaciones temporales
        if (!rta) {
            if (!folio.getAnotacionesTMPs().isEmpty()) {
                rta = true;
            }
        }

        return rta;
    }

    /**
     * @author : Ellery David Robles G.
     * @casoMantis : 08523.
     * @actaReq : 025_151 - Error al Desasociar el Folio.
     * @change : Indica si el folio tiene información temporal.
     * @param : turno.
     * @param : folio.
     * @param : pm.
     * @return : rta.
     */
    private boolean hasDatosTemporales2(TurnoEnhanced turno, FolioEnhanced folio, PersistenceManager pm) {
        boolean rta = false;
        //Si el folio NO es definitivo y es creado por el turno la respuesta es afirmativa
        if (!folio.isDefinitivo()) {
            rta = true;
        }
        //Se revisa si tiene anotaciones temporales
        if (!rta) {
            if (!folio.getAnotacionesTMPs().isEmpty()) {
                List anotaList = folio.getAnotacionesTMPs();
                Iterator anotaItem = anotaList.iterator();
                if (anotaItem.hasNext()) {
                    AnotacionTMP anotaTMP = (AnotacionTMP) anotaItem.next();
                    if (turno.getIdWorkflow().equals(anotaTMP.getNumRadicacion())) {
                        rta = true;
                    }
                }
            }
        }
        return rta;
    }

    /**
     * Devuelve un listado de anotaciones en las cuales el ciudadano se
     * encuentra relacionado
     *
     * @return List<Anotacion>
     *
     */
    public List getAnotacionesQueRelacionanCiudadano(CiudadanoPk oid) throws DAOException {
        List rta = new ArrayList();
        PersistenceManager pm = AdministradorPM.getPM();
        JDOGenieCiudadanoDAO ciudDAO = new JDOGenieCiudadanoDAO();
        try {
            CiudadanoEnhanced ciud = ciudDAO.getCiudadano(new CiudadanoEnhancedPk(oid), pm);
            if (ciud != null) {
                List aux = this.getAnotacionesQueRelacionanCiudadanoDefinitivas(ciud, pm);
                for (Iterator it = aux.iterator(); it.hasNext();) {
                    AnotacionCiudadanoEnhanced an = (AnotacionCiudadanoEnhanced) it.next();
                    pm.makeTransient(an.getAnotacion());
                    pm.makeTransient(an);
                    rta.add(an.getAnotacion());
                }
            }
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        return TransferUtils.makeTransferAll(rta);
    }

    /**
     * Indica si el folio se encuentra bloqueado en el turno
     *
     * @param turno
     * @param folio
     * @param pm
     * @return
     */
    protected List getAnotacionesQueRelacionanCiudadanoDefinitivas(CiudadanoEnhanced ciud, PersistenceManager pm) {
        List col = new ArrayList();
        Query query = pm.newQuery(AnotacionCiudadanoEnhanced.class);
        query.declareParameters("CiudadanoEnhanced ciud");
        query.setFilter("this.ciudadano==ciud");
        query.setOrdering("idMatricula ascending");
        col = (List) query.execute(ciud);
        return col;
    }

    public String lpad(String value, String caracter, int numero) {

        int tamvalue = value.length();
        String cadTo = "";
        for (int i = tamvalue; i < numero; i++) {
            cadTo += caracter;
        }
        value = cadTo + value;
        return value;

    }

    /**
     * Devuelve un listado de los ciudadanos que estan relacionados a un folio
     *
     * @return List<Ciudadanos>
     *
     */
    public List getCiudadanoUltimosFolio(String idMatricula) throws DAOException {
        List rta = new ArrayList();
        String minAnotacion = "";
        String maxAnotacion = "";
        int max = 30;

        String tipoDocumento = CCiudadano.TIPO_DOC_ID_SECUENCIA;
        PersistenceManager pm = AdministradorPM.getPM();
        try {

            FolioPk fpk = new FolioPk();
            fpk.idMatricula = idMatricula;
            Folio folio = this.getFolioByIDSinAnotaciones(fpk);
            try {
                max = (int) folio.getLastIdAnotacion();
            } catch (Exception e) {
            }

            int min = max - 30;
            if (min < 1) {
                min = 1;
            }

            //se realiza la depuracion del Lpad;
            minAnotacion = lpad(String.valueOf(min), "0", 6);
            maxAnotacion = lpad(String.valueOf(max), "0", 6);

            Query query = pm.newQuery(AnotacionCiudadanoEnhanced.class);
            query.setOrdering("this.anotacion.ordenLPAD descending");
            query.declareParameters("String idMatricula, String minAnotacion, String maxAnotacion, String tipoDocumento");
            query.setFilter("this.idMatricula == idMatricula && \n"
                    + "this.anotacion.ordenLPAD >= minAnotacion &&	\n"
                    + "this.anotacion.ordenLPAD <= maxAnotacion &&	\n"
                    + "this.ciudadano.tipoDoc != tipoDocumento");
            Collection col = (Collection) query.executeWithArray(new Object[]{idMatricula, minAnotacion, maxAnotacion, tipoDocumento});

            for (Iterator iter = col.iterator(); iter.hasNext();) {
                AnotacionCiudadanoEnhanced anotacionCiudadanoenhanced = (AnotacionCiudadanoEnhanced) iter.next();

                pm.makeTransient(anotacionCiudadanoenhanced.getCiudadano());
                pm.makeTransient(anotacionCiudadanoenhanced.getAnotacion());
                pm.makeTransient(anotacionCiudadanoenhanced);
                AnotacionCiudadano anotacionCiudadano = (AnotacionCiudadano) anotacionCiudadanoenhanced.toTransferObject();
                rta.add((AnotacionCiudadano) anotacionCiudadano);
            }
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }
        return rta;
    }

    /**
     * Indica si el ciudadano se encuentra asociado a una anotación definitiva
     *
     * @param turno
     * @param folio
     * @param pm
     * @return
     */
    protected boolean isCiudadanoInAnotacionDefinitiva(CiudadanoEnhanced ciud, PersistenceManager pm) {
        List lista = this.getAnotacionesQueRelacionanCiudadanoDefinitivas(ciud, pm);
        Iterator it = lista.iterator();
        return it.hasNext();
    }

    /**
     * Indica si el ciudadano se encuentra asociado a una anotación definitiva
     *
     * @param turno
     * @param folio
     * @param pm
     * @return
     */
    public boolean isCiudadanoInAnotacionDefinitiva(CiudadanoPk ciudID) throws DAOException {
        boolean rta = false;
        PersistenceManager pm = AdministradorPM.getPM();
        JDOGenieCiudadanoDAO ciudDAO = new JDOGenieCiudadanoDAO();
        try {
            CiudadanoEnhanced ciud = ciudDAO.getCiudadano(new CiudadanoEnhancedPk(ciudID), pm);
            if (ciud != null) {
                rta = this.isCiudadanoInAnotacionDefinitiva(ciud, pm);
            }

        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        return rta;
    }

    /* (non-Javadoc)
     * @see gov.sir.forseti.dao.FolioDAO#trasladadoMatricula(java.lang.String)
     */
    public boolean trasladadoMatricula(String matricula) throws DAOException {

        FolioEnhanced folio = null;
        boolean rta = false;
        PersistenceManager pm = AdministradorPM.getPM();

        try {
            folio = this.getFolioByMatricula(matricula, pm);

            if (folio != null) {
                EstadoFolioEnhanced ef = folio.getEstado();
                if (ef != null && ef.getIdEstado().equals(CEstadoFolio.TRASLADADO)) {
                    rta = true;
                } else {
                    rta = false;
                }
            }
        } catch (DAOException e) {
            throw e;
        } finally {
            pm.close();
        }

        return rta;
    }

    /**
     * (non-Javadoc)
     *
     * @see
     * gov.sir.forseti.dao.FolioDAO#validarFolioTieneAnotacionesconOrdenRepetido()
     */
    public boolean validarFolioTieneAnotacionesconOrdenRepetido(FolioPk folioId) throws DAOException {

        // define the query
        // based on http://www.oracle.com/technology/oramag/oracle/06-mar/o26asktom.html for delete duplicates
        StringBuffer sqlStatement = new StringBuffer(4096);

        // full join () over { sir_ne_anotacion | sir_ne_anotacion_tmp }
        // bug 5610
        sqlStatement.append("with folio_param as (                                                                       ");
        sqlStatement.append("     select ? p_id_matricula                                                                ");
        //sqlStatement.append( "          , ? p_id_zona_registral                                                           " );
        sqlStatement.append("      from dual                                                                             ");
        sqlStatement.append(")                                                                                           ");
        sqlStatement.append(", folio_msk as (                                                                            ");
        sqlStatement.append("                                                                                            ");
        sqlStatement.append("select inner_x.id_matricula                                                                 ");
        //sqlStatement.append( "     , inner_x.id_zona_registral                                                            " );
        sqlStatement.append("     , inner_x.id_anotacion                                                                 ");
        sqlStatement.append("     , inner_x.ntcn_orden                                                                   ");
        sqlStatement.append("     , inner_x.id_anotacion_tmp                                                             ");
        sqlStatement.append("     , inner_x.nttm_orden                                                                   ");
        sqlStatement.append("     , inner_x.mskd_orden                                                                   ");
        sqlStatement.append("                                                                                            ");
        sqlStatement.append("from (                                                                                      ");
        sqlStatement.append("  select sir_ne_folio.id_matricula,                                                         ");
        sqlStatement.append("         sir_ne_folio.id_zona_registral,                                                    ");
        sqlStatement.append("         t0_anotacion.id_anotacion,                                                         ");
        sqlStatement.append("         t0_anotacion.ntcn_orden,                                                           ");
        sqlStatement.append("         t2_anotacion.id_anotacion_tmp,                                                     ");
        sqlStatement.append("         t2_anotacion.nttm_orden,                                                           ");
        sqlStatement.append("         coalesce( t2_anotacion.nttm_orden, t0_anotacion.ntcn_orden, null ) mskd_orden      ");
        sqlStatement.append("    from sir_ne_folio,                                                                      ");
        sqlStatement.append("         sir_ne_anotacion t0_anotacion,                                                     ");
        sqlStatement.append("         sir_ne_anotacion_tmp t2_anotacion,                                                 ");
        sqlStatement.append("         folio_param                                                                        ");
        sqlStatement.append("   where coalesce( t2_anotacion.id_estado_an, t0_anotacion.id_estado_an, null ) = 'V'       ");
        sqlStatement.append("         and sir_ne_folio.id_matricula          = t0_anotacion.id_matricula                 ");
        //sqlStatement.append( "         and sir_ne_folio.id_zona_registral = t0_anotacion.id_zona_registral                " );
        sqlStatement.append("         and t0_anotacion.id_matricula      = t2_anotacion.id_matricula      (+)            ");
        //sqlStatement.append( "         and t0_anotacion.id_zona_registral = t2_anotacion.id_zona_registral (+)            " );
        sqlStatement.append("         and t0_anotacion.id_anotacion      = t2_anotacion.id_anotacion_tmp  (+)            ");
        sqlStatement.append("         and t2_anotacion.nttm_orden is not null                                            ");
        //sqlStatement.append( "         and sir_ne_folio.id_zona_registral = folio_param.p_id_zona_registral               " );
        sqlStatement.append("         and sir_ne_folio.id_matricula      = folio_param.p_id_matricula                    ");
        sqlStatement.append("                                                                                            ");
        sqlStatement.append("    union                                                                                   ");
        sqlStatement.append("                                                                                            ");
        sqlStatement.append("  select sir_ne_folio.id_matricula,                                                         ");
        sqlStatement.append("         sir_ne_folio.id_zona_registral,                                                    ");
        sqlStatement.append("         t0_anotacion.id_anotacion,                                                         ");
        sqlStatement.append("         t0_anotacion.ntcn_orden,                                                           ");
        sqlStatement.append("         t2_anotacion.id_anotacion_tmp,                                                     ");
        sqlStatement.append("         t2_anotacion.nttm_orden,                                                           ");
        sqlStatement.append("         coalesce( t2_anotacion.nttm_orden, t0_anotacion.ntcn_orden, null ) mskd_orden      ");
        sqlStatement.append("    from sir_ne_folio,                                                                      ");
        sqlStatement.append("         sir_ne_anotacion_tmp t2_anotacion,                                                 ");
        sqlStatement.append("         sir_ne_anotacion t0_anotacion,                                                     ");
        sqlStatement.append("         folio_param                                                                        ");
        sqlStatement.append("   where coalesce( t2_anotacion.id_estado_an, t0_anotacion.id_estado_an, null ) = 'V'       ");
        sqlStatement.append("         and sir_ne_folio.id_matricula          = t2_anotacion.id_matricula                 ");
        //sqlStatement.append( "         and sir_ne_folio.id_zona_registral = t2_anotacion.id_zona_registral                " );
        sqlStatement.append("         and t2_anotacion.id_matricula      = t0_anotacion.id_matricula      (+)            ");
        //sqlStatement.append( "         and t2_anotacion.id_zona_registral = t0_anotacion.id_zona_registral (+)            " );
        sqlStatement.append("         and t2_anotacion.id_anotacion_tmp  = t0_anotacion.id_anotacion  (+)                ");
        //sqlStatement.append( "         and sir_ne_folio.id_zona_registral = folio_param.p_id_zona_registral               " );
        sqlStatement.append("         and sir_ne_folio.id_matricula      = folio_param.p_id_matricula                    ");
        sqlStatement.append("  ) inner_x                                                                                 ");
        sqlStatement.append("                                                                                            ");
        sqlStatement.append("                                                                                            ");
        sqlStatement.append(")                                                                                           ");
        sqlStatement.append("select inner_1.level1_idanotacion                                                           ");
        sqlStatement.append("     , inner_1.level2_idanotacion                                                           ");
        sqlStatement.append("     , inner_1.mskd_orden                                                                   ");
        sqlStatement.append("  from (                                                                                    ");
        sqlStatement.append("                                                                                            ");
        sqlStatement.append("          select level_1.id_anotacion level1_idanotacion                                    ");
        sqlStatement.append("               , level_2.id_anotacion level2_idanotacion                                    ");
        sqlStatement.append("               , level_1.mskd_orden                                                         ");
        sqlStatement.append("               , row_number() over (                                                        ");
        sqlStatement.append("                     partition by least( level_1.id_anotacion,level_2.id_anotacion )        ");
        sqlStatement.append("                                , greatest( level_1.id_anotacion,level_2.id_anotacion )     ");
        sqlStatement.append("                         order by level_1.mskd_orden                                        ");
        sqlStatement.append("                 ) rn                                                                       ");
        sqlStatement.append("            from folio_msk level_1                                                          ");
        sqlStatement.append("               , folio_msk level_2                                                          ");
        sqlStatement.append("           where level_1.id_anotacion <> level_2.id_anotacion                               ");
        sqlStatement.append("             and level_1.mskd_orden = level_2.mskd_orden                                    ");
        sqlStatement.append("                                                                                            ");
        sqlStatement.append("       ) inner_1                                                                            ");
        sqlStatement.append(" where inner_1.rn <> 1                                                                      ");

        // ---------------------------------
        long result_NumberOfRecords = 0L;
        String result_Messages = null;

        String local_MskdOrden;
        StringBuffer local_MessagesAccum = new StringBuffer(4096);
        // ---------------------------------

        Connection connection = null;
        PreparedStatement ps = null;
        ResultSet rs = null;

        VersantPersistenceManager jdoPM = null;
        // get jdo.commnection ---------------
        try {
            jdoPM = (VersantPersistenceManager) AdministradorPM.getPM();
            jdoPM.currentTransaction().setOptimistic(false);
            jdoPM.currentTransaction().begin();
            connection = jdoPM.getJdbcConnection(null);
        } catch (JDOException e) {
            if (jdoPM.currentTransaction().isActive()) {
                jdoPM.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        }

        // -----------------------------------
        try {

            ps = connection.prepareStatement(sqlStatement.toString());
            ps.setString(1, folioId.idMatricula);

            local_MessagesAccum.append("(FOLIO: " + folioId.idMatricula + ", EN ANOTACION: " + "[");

            rs = ps.executeQuery();
            while (rs.next()) {
                local_MskdOrden = rs.getString(3);
                local_MessagesAccum.append(local_MskdOrden + " ");
                result_NumberOfRecords++;
            } // while

            local_MessagesAccum.append("])");

            jdoPM.currentTransaction().commit();

        } catch (SQLException e) {
            if (jdoPM.currentTransaction().isActive()) {
                jdoPM.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException("Error SQL: " + e.getMessage(), e);
        } catch (JDOException e) {
            if (jdoPM.currentTransaction().isActive()) {
                jdoPM.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        } catch (Throwable e) { // necessary ?
            if (jdoPM.currentTransaction().isActive()) {
                jdoPM.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        } finally {

            try {

                if (rs != null) {
                    rs.close();
                }

                if (ps != null) {
                    ps.close();
                }

                if (connection != null) {
                    connection.close();
                }

                if (jdoPM != null) {
                    jdoPM.close();
                }

            } catch (SQLException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e);
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            } // try

        } // try

        if (result_NumberOfRecords == 0L) {
            return true;
        }
        throw new DAOException(
                "Se han encontrado anotaciones con orden repetido "
                + local_MessagesAccum.toString()
                + "."
                + " Revisar estas anotaciones antes de continuar."
        );

    } // end-method: validarFolioTieneAnotacionesconOrdenRepetido

    /**
     * @see
     * gov.sir.forseti.dao.FolioDAO#eliminarOficinaOrigen(gov.sir.core.negocio.modelo.OficinaOrigen.OficinaOrigenPk)
     */
    public boolean eliminarOficinaOrigen(OficinaOrigenPk oficinaID) throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();

        try {
            pm.currentTransaction().setOptimistic(false);
            pm.currentTransaction().begin();

            //	Traer Objeto Persistente
            OficinaOrigenEnhancedPk idEnh = new OficinaOrigenEnhancedPk();
            idEnh.idOficinaOrigen = oficinaID.idOficinaOrigen;
            /*
              *  @author Carlos Torres
              *  @chage   se agrega validacion de version diferente
              *  @mantis 0013414: Acta - Requerimiento No 069_453_Código_Notaria_NC
             */
            idEnh.version = oficinaID.version;

            OficinaOrigenEnhanced objPers = (OficinaOrigenEnhanced) pm.getObjectById(idEnh, true);
            pm.deletePersistentAll(objPers.getCategorias());
            if (objPers == null) {
                throw new DAOException(
                        "No existe la oficina con el id "
                        + oficinaID.idOficinaOrigen);
            }

            pm.deletePersistent(objPers);
            pm.currentTransaction().commit();
        } catch (Throwable e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }
        return true;
    }

    public long countSalvedadesFolio(String idMatricula, String idWorkflow, Usuario usuario) throws DAOException {

        // no verifica la existencia del folio o
        // del turno
        PersistenceManager pm = AdministradorPM.getPM();
        long rta = 0;

        try {
            pm.currentTransaction().begin();

            TurnoEnhanced local_TurnoEnhanced;
            FolioEnhanced local_FolioEnhanced;

            // local_TurnoEnhanced = this.getTurnoByWFId( idWorkflow, pm );
            // local_FolioEnhanced = this.getFolioByMatricula( idMatricula, pm );
            // if( null == local_TurnoEnhanced ) {
            //   throw new DAOException( "Turno Identificado con id " + idWorkflow + " no encontrado" );
            // }
            // if( null == local_FolioEnhanced ) {
            //   throw new DAOException( "Folio Identificado con matricula " + idMatricula + " no encontrado" );
            // }
            // query-params
            String p_IdWorkflow;
            String p_IdMatricula;

            p_IdWorkflow = idWorkflow;
            p_IdMatricula = idMatricula;

            // sof:query-body
            VersantQuery query = (VersantQuery) pm.newQuery(SalvedadFolioEnhanced.class);
            query.declareVariables("TurnoEnhanced t; SolicitudFolioEnhanced solFol; SalvedadFolioEnhanced salAux");
            query.declareParameters("String p_IdWorkflow, String p_IdMatricula");
            query.setFilter(
                    "this.numRadicacion== p_IdWorkflow &&"
                    + "t.idWorkflow==p_IdWorkflow &&"
                    + "t.idCirculo==t.solicitud.circulo &&"
                    + "t.solicitud.solicitudFolios.contains(solFol) &&"
                    + "solFol.idMatricula == p_IdMatricula &&"
                    + "solFol.folio.salvedades.contains(salAux) &&"
                    + "salAux == this"
            );
            query.setResult("count(*)");

            rta = ((Long) query.execute(p_IdWorkflow, p_IdMatricula)).longValue();

            // for (Iterator iter = col.iterator(); iter.hasNext();) {
            //               SalvedadFolioEnhanced salvedadfolioenhanced = (SalvedadFolioEnhanced)iter.next();
            // //    logEstatico.debug(salvedadfolioenhanced);
            // }
            // eof:query-body
        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (Exception e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().commit();
            }

            pm.close();
        }

        return rta;

    } // end-method: countSalvedadesFolio

    public long countSalvedadesAnotacion(String idMatricula, String idWorkflow, Usuario usuario) throws DAOException {

        // no verifica la existencia del folio o
        // del turno
        PersistenceManager pm = AdministradorPM.getPM();
        long rta = 0;

        try {
            pm.currentTransaction().begin();

            // TurnoEnhanced local_TurnoEnhanced;
            // FolioEnhanced local_FolioEnhanced;
            // local_TurnoEnhanced = this.getTurnoByWFId( idWorkflow, pm );
            // local_FolioEnhanced = this.getFolioByMatricula( idMatricula, pm );
            // if( null == local_TurnoEnhanced ) {
            //   throw new DAOException( "Turno Identificado con id " + idWorkflow + " no encontrado" );
            // }
            // if( null == local_FolioEnhanced ) {
            //   throw new DAOException( "Folio Identificado con matricula " + idMatricula + " no encontrado" );
            // }
            // query-params
            String p_IdWorkflow;
            String p_IdMatricula;

            p_IdWorkflow = idWorkflow;
            p_IdMatricula = idMatricula;

            // sof:query-body
            VersantQuery query = (VersantQuery) pm.newQuery(SalvedadAnotacionEnhanced.class);
            query.declareVariables("TurnoEnhanced t; SolicitudFolioEnhanced solFol; SalvedadAnotacionEnhanced salAux; AnotacionEnhanced auxAn;");
            query.declareParameters("String p_IdWorkflow, String p_IdMatricula");
            query.setFilter("this.numRadicacion == p_IdWorkflow &&"
                    + "t.idWorkflow == p_IdWorkflow"
                    + "&& t.idCirculo == t.solicitud.circulo"
                    + "&& t.solicitud.solicitudFolios.contains(solFol)"
                    + "&& solFol.idMatricula == p_IdMatricula"
                    + "&& solFol.folio.anotaciones.contains( auxAn )"
                    + "&& solFol.folio == auxAn.folio"
                    + "&& auxAn.salvedades.contains(salAux)"
                    + "&& salAux == this"
            );
            query.setResult("count(*)");

            rta = ((Long) query.execute(p_IdWorkflow, p_IdMatricula)).longValue();

            // for (Iterator iter = col.iterator(); iter.hasNext();) {
            //    SalvedadAnotacionEnhanced salvedadanotacionenhanced = (SalvedadAnotacionEnhanced)iter.next();
            // //    logEstatico.debug(salvedadanotacionenhanced);
            // }
            // eof:query-body
        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().commit();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (Exception e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().commit();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().commit();
            }

            pm.close();
        }

        return rta;
    } // end-method: countSalvedadesAnotacion

    /**
     * @see
     * gov.sir.forseti.interfaz.ForsetiServiceInterface#getOficinasOrigenByMunicipio(
     * gov.sir.core.negocio.modelo.Municipio.MunicipioPk )
     */
    public List getOficinasOrigenByMunicipio(MunicipioPk oid)
            throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        List rta = null;
        List rta2 = new ArrayList();
        OficinaOrigenEnhanced of;

        //TipoOficina tipo;
        try {
            rta = this.getOficinasOrigenByMunicipio(new MunicipioEnhancedPk(oid), pm);

            for (Iterator itr = rta.iterator(); itr.hasNext();) {
                of = (OficinaOrigenEnhanced) itr.next();
                pm.makeTransient(of.getTipoOficina());
                pm.makeTransient(of);
                rta2.add(of);
            }

            //pm.makeTransientAll(rta);
        } catch (DAOException e) {
            throw e;
        } finally {
            pm.close();
        }

        rta2 = TransferUtils.makeTransferAll(rta2);

        return rta2;
    } // end-method: getOficinasOrigenByMunicipio

    /**
     * @see
     * gov.sir.forseti.interfaz.ForsetiServiceInterface#eliminarDeltaSegunAnotacionDefinitiva(
     * gov.sir.core.negocio.modelo.Folio, gov.sir.core.negocio.modelo.Anotacion,
     * gov.sir.core.negocio.modelo.Usuario )
     */
    /**
     * @see gov.sir.forseti.interfaz.ForsetiServiceInterface#getAnotacionById(
     * gov.sir.core.negocio.modelo.Anotacion.AnotacionPk )
     */
    public Anotacion getAnotacionById(AnotacionPk oid)
            throws DAOException {

        PersistenceManager pm = AdministradorPM.getPM();
        AnotacionEnhanced anotacionEnhanced;
        Anotacion result;

        result = null;

        //TipoOficina tipo;
        try {
            anotacionEnhanced = this.getAnotacionByID(new AnotacionEnhancedPk(oid), pm);
            this.makeTransientAnotacion(anotacionEnhanced, pm, new ArrayList());

            //pm.makeTransientAll(rta);
        } catch (DAOException e) {
            throw e;
        } finally {
            pm.close();
        }

        if (null != anotacionEnhanced) {
            result = (Anotacion) TransferUtils.makeTransfer(anotacionEnhanced);
        }

        return result;

    } // end-method: getAnotacionById

    /*
     * Metodo que devuelve el id del workFlow de un turno que esta asociado a una anotacion Temporal
     * 
     */
    public String getIdWorkFlowByAnotacion(String idAnotacion, String idMatricula, PersistenceManager pm) throws DAOException {

        String rta = "";
        Connection connection = null;
        PreparedStatement ps = null;
        ResultSet rs = null;

        VersantPersistenceManager jdoPM = null;

        try {

            String consulta = "SELECT NTTM_ID_WORKFLOW FROM SIR_NE_ANOTACION_TMP "
                    + "WHERE ID_MATRICULA = ? AND ID_ANOTACION_TMP = ? ";

            jdoPM = (VersantPersistenceManager) pm;

            connection = jdoPM.getJdbcConnection(null);
            ps = connection.prepareStatement(consulta);

            ps.setString(1, idMatricula);
            ps.setString(2, idAnotacion);

            rs = ps.executeQuery();

            while (rs.next()) {
                rta = rs.getString(1);
            }
        } catch (SQLException e) {
            if (jdoPM.currentTransaction().isActive()) {
                jdoPM.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        } catch (JDOObjectNotFoundException e) {
            if (jdoPM.currentTransaction().isActive()) {
                jdoPM.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        } catch (JDOException e) {
            if (jdoPM.currentTransaction().isActive()) {
                jdoPM.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        } catch (Throwable e) {
            if (jdoPM.currentTransaction().isActive()) {
                jdoPM.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
            throw new DAOException(e.getMessage(), e);
        } finally {
            try {
                if (rs != null) {
                    rs.close();
                }
                if (ps != null) {
                    ps.close();
                }
                if (connection != null) {
                    connection.close();
                }
            } catch (SQLException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e);
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage(), e);
                throw new DAOException(e.getMessage(), e);
            }
        }
        return rta;
    }

    /**
     * Valida la información del folio antes de crearlo. Si existe por lo menos
     * un error lanza un DAOException Los errores son listados en DAOException
     *
     * @param datos
     * @throws DAOException
     */
    public void validarMatriculaCrearFolio(Folio datos) throws DAOException {
        DAOException exc = new DAOException(
                "Fallo en validación de creación de folio");
        PersistenceManager pm = AdministradorPM.getPM();
        JDOGenieZonaRegistralDAO zonaRegistralDAO = new JDOGenieZonaRegistralDAO();

        if (datos.getZonaRegistral() == null) {
            exc.addError("El folio no tiene zona registral");
        } else {
            if (datos.getZonaRegistral().getCirculo() == null) {
                exc.addError("La zona registral no tiene el círculo asociado");
            } else if (datos.getZonaRegistral().getVereda() == null) {
                exc.addError("La zona registral no tiene la vereda asociada");
            } else {

                CirculoEnhancedPk cid = new CirculoEnhancedPk();
                cid.idCirculo = datos.getZonaRegistral().getCirculo().getIdCirculo();
                CirculoEnhanced cir = zonaRegistralDAO.getCirculo(cid, pm);

                VeredaEnhancedPk vId = new VeredaEnhancedPk();
                vId.idDepartamento = datos.getZonaRegistral().getVereda().getIdDepartamento();
                vId.idMunicipio = datos.getZonaRegistral().getVereda().getIdMunicipio();
                vId.idVereda = datos.getZonaRegistral().getVereda().getIdVereda();

                VeredaEnhanced ver = zonaRegistralDAO.getVereda(vId, pm);

                ZonaRegistralEnhanced zrTMP = zonaRegistralDAO.getZonaRegistralByCirculoVereda(cir,
                        ver, pm);

                if (zrTMP == null) {
                    exc.addError(
                            "La zona registral del círculo y la vereda no existe");
                }

                if ((datos.getIdMatricula() != null)) {
                    StringTokenizer st = new StringTokenizer(datos.getIdMatricula(),
                            "-");
                    String cirID = st.nextToken();
                    String secuencial = st.nextToken();

                    long sec = Long.parseLong(secuencial);

                    if (!cirID.equals(datos.getZonaRegistral().getCirculo()
                            .getIdCirculo())) {
                        exc.addError(
                                "El identificador del círculo de la matrícula no coincide con el círculo especificado en la zona registral");
                    } else {
                        if ((zrTMP.getCirculo().getLastNoMatricula()) < sec) {
                            exc.addError(
                                    "El número de matrícula especificado supera la secuencia del círculo");
                        }

                        FolioEnhanced val = this.getFolioByMatriculaIncluyendoObsoletos(datos.getIdMatricula(),
                                pm);

                        if (val != null) {
                            if (val.getEstado().getIdEstado().equals(CEstadoFolio.OBSOLETO)) {
                                exc.addError(
                                        "El número de matrícula especificado ya fue utilizado para un folio");
                            } else if (!val.isDefinitivo()) {
                                exc.addError(
                                        "El número de matrícula ya fue utilizado para un folio temporal");
                            } else {
                                exc.addError(
                                        "El folio con el número de matrícula especificado ya existe");
                            }
                        }
                    }
                }
            }
        }

        if (datos.getEstado() != null) {
            EstadoFolio ef = datos.getEstado();
            EstadoFolioEnhancedPk efId = new EstadoFolioEnhancedPk();
            efId.idEstado = ef.getIdEstado();
            EstadoFolioEnhanced efEnh = this.getEstadoFolio(efId, pm);

            if (efEnh == null) {
                exc.addError("No encontró el estado de folio con el ID: "
                        + efId.idEstado);
            }
        }

        if (datos.getTipoPredio() == null) {
            exc.addError("El folio debe tener tipo de predio");
        } else {
            TipoPredioEnhancedPk tpId = new TipoPredioEnhancedPk();
            tpId.idPredio = datos.getTipoPredio().getIdPredio();
            TipoPredioEnhanced tp = this.getTipoPredio(tpId, pm);

            if (tp == null) {
                exc.addError("No encontró el tipo de predio con el ID: "
                        + tpId.idPredio);
            }
        }

        if (datos.getDocumento() != null) {
            Documento doc = datos.getDocumento();

            if (doc.getIdDocumento() != null) {
                DocumentoEnhancedPk docId = new DocumentoEnhancedPk();
                docId.idDocumento = doc.getIdDocumento();
                DocumentoEnhanced docEnh = this.getDocumento(docId, pm);

                if (docEnh == null) {
                    exc.addError("No encontró el documento con el ID: "
                            + docId.idDocumento);
                }
            }
        }
        List direcciones = datos.getDirecciones();
        DireccionEnhanced dir = null;
        int indice = 1;

        // TODO: se esta recibiendo un
        // Direccion; debe convertirse a un enhanced
        if (null != direcciones) {

            for (Iterator itr = direcciones.iterator(); itr.hasNext(); indice++) {

                // corregido:
                dir = DireccionEnhanced.enhance((Direccion) itr.next());

                // dir = (DireccionEnhanced) itr.next();
                try {
                    this.validarDireccion(dir, indice, pm);
                } catch (DAOException e) {
                    exc.appendErrores(e.getErrores());
                } // try

            } // for

        } // if

        if (exc.getErrores().size() > 0) {
            throw exc;
        }
    }

    /**
     * @param folio
     * @param usuario
     * @return
     * @throws DAOException
     */
    public boolean updateFolioCreacionDirecta(Folio datos, Usuario usuario)
            throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        boolean rta = false;

        FolioEnhanced folio;
        UsuarioEnhanced us;

        try {
            pm.currentTransaction().setOptimistic(false);
            pm.currentTransaction().begin();

            //Obtenemos el folio persistente
            FolioEnhancedPk fid = new FolioEnhancedPk();
            fid.idMatricula = datos.getIdMatricula();

            folio = this.getFolioByID(fid, pm);

            if (folio == null) {
                throw new DAOException("El folio no existe");
            }

            //Validar bloqueo del folio
            this.validarBloqueoFolio(folio, usuario, pm);

            //Se llama al método protegido que actualiza el folio
            //dados los datos
            UsuarioEnhancedPk uid = new UsuarioEnhancedPk();
            uid.idUsuario = usuario.getIdUsuario();

            us = this.getUsuarioByID(uid, pm);

            if (us == null) {
                throw new DAOException("El usuario especificado no existe: "
                        + uid.idUsuario);
            }

            this.updateFolioCreacionDirecta(folio, datos, us, pm);

            pm.currentTransaction().commit();
            rta = true;
        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (DAOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            throw e;
        } catch (Throwable e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        return rta;
    }

    /**
     * Método que actualiza los datos del folio persistente dados los datos
     * enviados en el objeto enhanced (Folio)
     *
     * @param folio
     * @param datos
     * @param pm
     * @return
     * @throws DAOException
     */
    protected boolean updateFolioCreacionDirecta(FolioEnhanced folio, Folio datos,
            UsuarioEnhanced usuario, PersistenceManager pm)
            throws DAOException {
        boolean rta = false;

        try {
            //Se busca en datos los valores a actualizar o añadir en Folio:
            if ((datos.getLindero() != null)
                    || (datos.getNupre() != null)
                    || (datos.getDeterminaInm() != null)
                    || (datos.getPrivMetros() != null)
                    || (datos.getPrivCentimetros() != null)
                    || (datos.getConsMetros() != null)
                    || (datos.getConsCentimetros() != null)
                    || (datos.getCoeficiente() != null)
                    || (datos.getHectareas() != null)
                    || (datos.getMetros() != null)
                    || (datos.getCentimetros() != null)
                    || (datos.getCodCatastral() != null)
                    || (datos.getCodCatastralAnterior() != null)
                    || (datos.getTipoPredio() != null)
                    || (datos.getRadicacion() != null)
                    || // bug 03580
                    (datos.getFechaApertura() != null)
                    || // bug 03580
                    (datos.getZonaRegistral() != null)
                    || // bug 03930
                    (datos.getEstado() != null)) {
                this.updateFolioDatos(folio, datos, null, false, pm);
            }

            //Se busca si se debe actualizar la complementación
            if (datos.getComplementacion() != null) {
                this.updateFolioComplementacion(folio, datos, pm);
            }

            //Se busca si se debe actualizar el documento
            if (datos.getDocumento() != null) {
                if (datos.getDocumento().getCirculo() == null) {
                    datos.getDocumento().setCirculo(folio.getCirculo());
                }
                this.updateFolioDocumento(folio, datos, pm);
            }

            //Se buscan las direcciones a añadir
            if (datos.getDirecciones().size() > 0) {
                this.updateFolioDirecciones(folio, datos, usuario, pm);
            }

            //Se buscan las salvedades a añadir
            if (datos.getSalvedades().size() > 0) {
                this.updateFolioSalvedadesCreacionDirecta(folio, datos, usuario, pm);
            }

            //Se buscan las anotaciones a añadir o actualizar
            if (datos.getAnotaciones().size() > 0) {
                this.updateFolioAnotacionesCreacionDirecta(folio, datos, usuario, pm);
            }

            rta = true;
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }

        return rta;
    }

    /**
     * Metodo para actualizar una anotacion en Creacion Directa
     *
     * @param anotacion
     * @param usuario
     * @return
     * @throws DAOException
     */
    public boolean updateAnotacionesCreacionDirecta(Anotacion anotacion, Usuario usuario) throws DAOException {
        AnotacionTMP toUpdate;
        AnotacionTMP datos;
        boolean soloEliminarContraparteTemporal;
        TurnoEnhanced turno;
        PersistenceManager pm = AdministradorPM.getPM();
        boolean rta = false;

        FolioEnhanced folio;
        UsuarioEnhanced us;

        try {
            pm.currentTransaction().setOptimistic(false);
            pm.currentTransaction().begin();

            //Obtenemos el folio persistente
            FolioEnhancedPk fid = new FolioEnhancedPk();
            fid.idMatricula = anotacion.getIdMatricula();

            folio = this.getFolioByID(fid, pm);

            if (folio == null) {
                throw new DAOException("El folio no existe");
            }

            //Validar bloqueo del folio
            this.validarBloqueoFolio(folio, usuario, pm);

            //Se llama al método protegido que actualiza el folio
            //dados los datos
            UsuarioEnhancedPk uid = new UsuarioEnhancedPk();
            uid.idUsuario = usuario.getIdUsuario();

            us = this.getUsuarioByID(uid, pm);

            if (us == null) {
                throw new DAOException("El usuario especificado no existe: "
                        + uid.idUsuario);
            }

            datos = new AnotacionTMP(anotacion);

            //Se revisa si la anotacion tiene llave y en ese caso si existe
            if (datos.getIdAnotacionTmp() != null) {
                //no debe existir definitiva se actualiza la temporal

                // Se revisa si la anotación que se quiere actualizar es temporal
                AnotacionTMPPk tid = new AnotacionTMPPk();
                tid.idAnotacionTmp = datos.getIdAnotacionTmp();
                tid.idMatricula = folio.getIdMatricula();

                AnotacionTMP auxTMP = this.getAnotacionTMPByID(tid, pm);

                if (auxTMP != null) {
                    //Se debe actualizar la anotación temporal
                    this.actualizarAnotacionTMPCreacionDirecta(folio, auxTMP, datos, us, false, null, pm);
                } else {
                    throw new DAOException(
                            "No se encontró una anotación dentro del folio con el ID: " + tid.idAnotacionTmp);
                }
            }
            pm.currentTransaction().commit();
            rta = true;
        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }

            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (DAOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            throw e;
        } catch (Throwable e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }

        return rta;

        //perro
        //return actualizarAnotacionCreacionDirectaTMP();
    }

    /**
     *
     * @param folio
     * @param datos
     * @param pm
     * @return
     * @throws DAOException
     */
    protected boolean updateFolioAnotacionesCreacionDirecta(FolioEnhanced folio, Folio datos,
            UsuarioEnhanced usuario, PersistenceManager pm)
            throws DAOException {
        boolean rta = false;

        try {
            List anotaciones = datos.getAnotaciones();
            AnotacionTMP anotacion;

            for (Iterator itr = anotaciones.iterator(); itr.hasNext();) {
                anotacion = new AnotacionTMP((Anotacion) itr.next());

                //Se revisa si la anotacion tiene llave y en ese caso si existe
                if (anotacion.getIdAnotacionTmp() != null) {
                    //Se desea actualizar o borrar una anotación temporal o definitiva
                    //Se revisa si la anotación que se quiere actualizar es definitiva
                    AnotacionEnhancedPk vid = new AnotacionEnhancedPk();
                    vid.idAnotacion = anotacion.getIdAnotacionTmp();
                    vid.idMatricula = folio.getIdMatricula();

                    AnotacionEnhanced auxAn = this.getAnotacionByID(vid, pm);

                    if (auxAn != null) {
                        //Se debe actualizar la anotación definitiva
                        // this.actualizarAnotacion(folio, auxAn, anotacion, usuario, true, pm);

                        // :: Bug XXXX: no reordenar
                        this.actualizarAnotacion(folio, auxAn, anotacion, usuario, false, null, pm);
                    } else {
                        //Se revisa si la anotación que se quiere actualizar es temporal
                        AnotacionTMPPk tid = new AnotacionTMPPk();
                        tid.idAnotacionTmp = anotacion.getIdAnotacionTmp();
                        tid.idMatricula = folio.getIdMatricula();

                        AnotacionTMP auxTMP = this.getAnotacionTMPByID(tid, pm);

                        if (auxTMP != null) {
                            //Se debe actualizar la anotación temporal
                            this.actualizarAnotacionTMP(folio, auxTMP,
                                    anotacion, usuario, false, null, pm);
                        } else {
                            throw new DAOException(
                                    "No se encontró una anotación dentro del folio con el ID: "
                                    + vid.idAnotacion);
                        }
                    }
                } else {
                    //Se le quita el ID para que se asigne un ID automático
                    anotacion.setIdAnotacionTmp(null);
                    anotacion.setFecha(new Date());

                    //Si es una anotación nueva se asigna el orden:
                    anotacion.setOrden(String.valueOf(
                            this.getNextOrdenAnotacion(folio, pm)));

                    this.addAnotacionTMPToFolioCreacionDirecta(folio, anotacion, usuario, null, pm);
                    pm.makePersistent(anotacion);
                }
            }

            rta = true;
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }

        return rta;
    }

    /**
     *
     * @param folio
     * @param datos
     * @param pm
     * @return
     * @throws DAOException
     */
    protected boolean addAnotacionTMPToFolioCreacionDirecta(FolioEnhanced folio,
            AnotacionTMP datos, UsuarioEnhanced usuario, TurnoEnhanced turno, PersistenceManager pm)
            throws DAOException {
        JDOGenieZonaRegistralDAO zonaRegistralDAO = new JDOGenieZonaRegistralDAO();
        boolean rta = false;

        try {
            //Se revisa primero se se debe crear anotaciones canceladas, con
            //el fin de hacerlas persistentes antes de las canceladoras
            for (Iterator itr = datos.getAnotacionesCancelacionTMPs().iterator(); itr.hasNext();) {
                CancelacionTMP cancelacion = (CancelacionTMP) itr.next();
                this.checkCreacionCanceladaAnotacionTMP(folio, datos, cancelacion, usuario, turno,
                        pm);
            }

            //Se valida el estado de la anotacion, si no tiene
            //se pone por defecto Activa
            EstadoAnotacionEnhanced estado;

            if (datos.getEstado() != null) {
                EstadoAnotacionEnhancedPk eId = new EstadoAnotacionEnhancedPk();
                eId.idEstadoAn = datos.getEstado().getIdEstadoAn();

                estado = this.getEstadoAnotacion(eId, pm);

                if (estado == null) {
                    throw new DAOException(
                            "No encontró el estado de la anotación con el ID: "
                            + eId.idEstadoAn);
                }
            } else {
                EstadoAnotacionEnhancedPk eId = new EstadoAnotacionEnhancedPk();
                eId.idEstadoAn = CEstadoAnotacion.ACTIVO;

                estado = this.getEstadoAnotacion(eId, pm);

                if (estado == null) {
                    throw new DAOException(
                            "No encontró el estado de la anotación con el ID: "
                            + eId.idEstadoAn);
                }
            }
            //Se valida que no exista una anotación temporal ya insertada
            //con la misma naturaleza jurídica y con el mismo documento

            //SEGUN REQUERIMIENTO DE SNR SE QUITA ESTA VALIDACION
            /*
             if (!estado.getIdEstadoAn().equals(CEstadoAnotacion.OBSOLETA)) {

                 if (!this.validarNaturalezaJuridicaAnotacion(folio, datos, pm)) {
                     throw new DAOException(
                         "No puede inscribir 2 veces una anotación con la misma naturaleza jurídica y el mismo documento");
                 }

             }*/
            //Se valida la naturaleza jurídica de la anotacion
            if (datos.getNaturalezaJuridica() == null) {
                throw new DAOException(
                        "La anotación debe tener naturaleza jurídica");
            }

            if (datos.getTipoAnotacion() == null) {
                throw new DAOException(
                        "La anotación debe tener tipo de anotación");
            }

            NaturalezaJuridicaEnhancedPk njId = new NaturalezaJuridicaEnhancedPk();
            njId.idNaturalezaJuridica = datos.getNaturalezaJuridica()
                    .getIdNaturalezaJuridica();
            /*
                *  @author Carlos Torres
                *  @chage   se asigna valor a la propiedad version
                *  @mantis 12705: Acta - Requerimiento No 056_453_Modificiación_de_Naturaleza_Jurídica
             */
            njId.version = datos.getNaturalezaJuridica().getVersion();
            NaturalezaJuridicaEnhanced naturaleza = this.getNaturalezaJuridica(njId,
                    pm);

            if (naturaleza == null) {
                throw new DAOException(
                        "No encontró la naturaleza jurídica de la anotación con el ID: "
                        + njId.idNaturalezaJuridica);
            }

            //Se valida el tipo de anotación
            TipoAnotacionEnhancedPk taId = new TipoAnotacionEnhancedPk();

            taId.idTipoAnotacion = datos.getTipoAnotacion().getIdTipoAnotacion();

            //taId.idTipoAnotacion = CTipoAnotacion.ESTANDAR;
            TipoAnotacionEnhanced tipoAnota = this.getTipoAnotacion(taId, pm);

            if (tipoAnota == null) {
                throw new DAOException(
                        "No encontró el tipo de la anotación con el ID: "
                        + taId.idTipoAnotacion);
            }

            datos.setEstado(estado);
            datos.setNaturalezaJuridica(naturaleza);
            datos.setTipoAnotacion(tipoAnota);
            datos.setFecha(new Date());

            //Se setea el usuario de creación, si es null se busca si en la anotación
            //se tiene seteado el usuario
            if (usuario != null) {
                datos.setUsuario(usuario);
            } else {
                if (datos.getUsuario() != null) {
                    UsuarioEnhancedPk uid = new UsuarioEnhancedPk();
                    uid.idUsuario = datos.getUsuario().getIdUsuario();

                    UsuarioEnhanced usAux = this.getUsuarioByID(uid, pm);
                    datos.setUsuario(usAux);
                }
            }

            //Se asocia el documento asociado si tiene
            DocumentoEnhanced auxDoc = datos.getDocumento();

            if (auxDoc != null) {
                if (auxDoc.getCirculo() == null) {
                    auxDoc.setCirculo(folio.getCirculo());
                }
                this.setDocumentoToAnotacionTMP(datos, datos.getDocumento(), pm);
            }

            //Se setea el ID de la anotacion, si es nula se asigna un secuencial, sino
            //se deja el ID que viene.
            if (datos.getIdAnotacionTmp() == null) {
                datos.setIdAnotacionTmp(String.valueOf(folio.getLastIdAnotacionTMP()
                        + 1));
                folio.setLastIdAnotacionTMP(folio.getLastIdAnotacionTMP() + 1);
            }

            datos.setFolio(folio);
            /*
             if (datos.getOrden() == null) {
                 datos.setOrden(datos.getIdAnotacionTmp());
             }
             */

            //Se asocia la información de antiguo sistema
            if (datos.getDatosAntiguoSistema() != null) {
                DatosAntiguoSistemaEnhanced datosAS = datos.getDatosAntiguoSistema();
                datosAS.setIdDatosAntiguoSistema(datos.getIdMatricula() + "-"
                        + datos.getIdAnotacionTmp());
            }

            //Se buscan y asocian las salvedades
            List salvedades = datos.getSalvedadesTMPs();
            SalvedadAnotacionTMP salvedad = null;

            for (Iterator itr = salvedades.iterator(); itr.hasNext();) {
                salvedad = (SalvedadAnotacionTMP) itr.next();
                this.addSalvedadToAnotacionTMP(datos, salvedad, usuario, pm);
            }

            //Se buscan y asocian las anotacionesCiudadano
            List anotacionesCiudadano = datos.getAnotacionesCiudadanoTMPs();
            AnotacionCiudadanoTMP anotaCiud = null;

            for (Iterator itr = anotacionesCiudadano.iterator(); itr.hasNext();) {
                anotaCiud = (AnotacionCiudadanoTMP) itr.next();
                this.addAnotacionCiudadanoToAnotacionTMP(datos, anotaCiud, turno, pm);
            }

            //pm.setIgnoreCache( true );
            //Se buscan y asocian las anotaciones de cancelación
            List cancelaciones = datos.getAnotacionesCancelacionTMPs();
            CancelacionTMP cancelacion = null;

            // la cancelacion debe tener registro del id del folio en
            // "canceladaDef"
            for (Iterator itr = cancelaciones.iterator(); itr.hasNext();) {
                cancelacion = (CancelacionTMP) itr.next();
                Log.getInstance().debug(JDOGenieFolioDAO.class, new Boolean(javax.jdo.JDOHelper.isPersistent(cancelacion)).toString());
                this.addCancelacionToAnotacionTMPCreacionDirecta(datos, cancelacion, usuario,
                        pm);
            }

            rta = true;
        } catch (DAOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw e;
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }

        return rta;
    }

    /**
     *
     * @param anota
     * @param datos
     * @param pm
     * @return
     * @throws DAOException
     */
    protected boolean addCancelacionToAnotacionTMPCreacionDirecta(AnotacionTMP anota,
            CancelacionTMP datos, UsuarioEnhanced usuario, PersistenceManager pm)
            throws DAOException {
        boolean rta = false;

        try {
            AnotacionEnhanced cancelada;

            //Se valida que no exista la misma cancelación para la anotación:
            CancelacionTMP cal = this.getCancelacionTMP(datos, anota, pm);

            if (cal != null) {
                if (!cal.isToDelete()) {
                    throw new DAOException("Ya está cancelando la misma anotación");
                }
            }
            /*
            //SE IGNORA ESTE CODIGO PORQUE LA CREACION DE LA CANCELADA SE PASO
            //A OTRO Metodo
            //Se mira si la anotación cancelada se debe crear o se debe
            //asociar
            if (anota.isCrearCancelada()) {
                cancelada = datos.getCanceladaDef();
                canceladaTMP = new AnotacionTMP(cancelada, new ArrayList());

                //Se le quita el ID para que se asigne un ID automático
                canceladaTMP.setIdAnotacionTmp(null);
                canceladaTMP.setOrden(null);

                this.addAnotacionTMPToFolio(anota.getFolio(), canceladaTMP,
                    usuario, pm);

                datos.setCanceladaTmp(canceladaTMP);
                datos.setAnotacionTemporal(true);
                datos.setCanceladaDef(null);
            } else {*/
            //SE IGNORA ESTE CODIGO PORQUE YA NO SE PUEDEN CANCELAR ANOTACIONES TEMPORALES
            //Se define si la anotacion cancelada es temporal o es
            //definitiva (La anotación cancelada es guardada por defecto en canceladaDef)
            cancelada = datos.getCanceladaDef();
            /*
                AnotacionTMP.ID aIdTMP = new AnotacionTMP.ID();
                aIdTMP.idMatricula = cancelada.getIdMatricula();
                aIdTMP.idAnotacionTmp = cancelada.getIdAnotacion();

                canceladaTMP = this.getAnotacionTMPByID(aIdTMP, pm);

                //Si encontró la anotación entre las temporales:
                if (canceladaTMP != null) {
                    datos.setCanceladaTmp(canceladaTMP);
                    datos.setAnotacionTemporal(true);
                    datos.setCanceladaDef(null);
                }
                //Si no encontró la anotación entre las temporales
                //se revisan las definitivas
                else {
             */

            AnotacionTMPPk aId = new AnotacionTMPPk();

            // bug 05165 ---------------------------------------------------
            // la cancelada llega sin identificador de matricula;
            // incluir el mismo del folio modificado
            // y que esta en la anotacion que cancela
            // -------------------------------------------------------------
            aId.idMatricula = anota.getIdMatricula();
            aId.idAnotacionTmp = cancelada.getIdAnotacion();

            AnotacionTMP canceladaTmp = this.getAnotacionTMPByID(aId, pm);

            if (canceladaTmp == null) {
                throw new DAOException(
                        "No se encontró la anotación cancelada");
            }

            datos.setCanceladaDef(null);
            datos.setCanceladaTmp(canceladaTmp);
            datos.setAnotacionTemporal(true);
            //}
            //}

            datos.setIdCancelacionTmp(String.valueOf(anota.getLastIdCancelacion()
                    + 1));
            anota.setLastIdCancelacion(anota.getLastIdCancelacion() + 1);
            datos.setCanceladora(anota);

            // debug:
            boolean isPersistent;
            isPersistent = javax.jdo.JDOHelper.isPersistent(datos);
            isPersistent = javax.jdo.JDOHelper.isPersistent(anota);

            rta = true;
        } catch (DAOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw e;
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }

        return rta;
    }

    /**
     * Retorna las anotaciones temporales de un folio con el criterio dado.
     *
     * @param oid
     * @param criterio
     * @param valor
     * @param usuario
     * @return
     * @throws DAOException
     */
    public List getFoliosAnotaActNomenclaturaSinActualizarBySolicitud(SolicitudPk oid,
            Usuario usuario) throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        List rta = new ArrayList();
        List res = new ArrayList();

        try {
            SolicitudEnhanced sol = this.getSolicitudByID(new SolicitudEnhancedPk(oid), pm);

            if (sol == null) {
                throw new DAOException(
                        "Ola solicitud especificada no existe. Solicitud: "
                        + oid.idSolicitud);
            }

            //Se debe buscar por algún criterio las anotaciones
            pm.currentTransaction().begin();
            Query query = pm.newQuery(AnotacionTMP.class);
            query.declareVariables("AnotacionEnhanced anota; SolicitudEnhanced sol; SolicitudFolioEnhanced solFol");
            query.declareParameters("String parametro, String idSol");
            query.setFilter("this.naturalezaJuridica != null && "
                    + "this.naturalezaJuridica.idNaturalezaJuridica==parametro && "
                    + "this.idMatricula == solFol.idMatricula && "
                    + "solFol.idSolicitud == sol.idSolicitud && "
                    + "sol.idSolicitud == idSol");

            res = (List) query.execute(CNaturalezaJuridica.ACTUALIZACION_DE_NOMENCLATURA, sol.getIdSolicitud());

            AnotacionTMP anotaTMP;
            FolioDatosTMP folioDatosTMP;
            for (Iterator it = res.iterator(); it.hasNext();) {
                anotaTMP = (AnotacionTMP) it.next();
                try {
                    folioDatosTMP = anotaTMP.getFolio().getDatosTMP();
                } catch (JDOObjectNotFoundException e) {
                    // TODO Auto-generated catch block
                    folioDatosTMP = null;
                }

                boolean noActualizado = false;

                if (!(anotaTMP.getFolio().getLastIdDireccion() == anotaTMP.getFolio().getLastIdDireccionTMP())) {
                    noActualizado = true;
                } else {
                    if (anotaTMP.getFolio().getLindero() != null && folioDatosTMP != null && !(anotaTMP.getFolio().getLindero().equals(folioDatosTMP.getLindero()))) {
                        noActualizado = true;
                    }
                }

                if (!noActualizado) {
                    rta.add(anotaTMP.getIdMatricula());
                }
                /*if(anotaTMP.getFolio().getLastIdDireccion() == 0 || 
                		(anotaTMP.getFolio().getLastIdDireccion() == anotaTMP.getFolio().getLastIdDireccionTMP() ||
                		(anotaTMP.getFolio().getLindero() != null && folioDatosTMP != null && (anotaTMP.getFolio().getLindero().equals(folioDatosTMP.getLindero())))))
                {
                	
                }*/
            }
        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (Exception e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().commit();
            }
            pm.close();
        }
        return rta;
    }

    /**
     * Obtiene un objeto Folio dado su identificador, el folio retornado es
     * transaccional, se debe dar el persistencemanager de la transacción activa
     *
     * @param oid identificador del Folio conformado por Nro matricula y
     * ZonaRegistral
     * @param pm PersistenceManager de la transaccion
     * @return Objeto Folio transaccional null si no encuentra un folio que
     * coincida con el identificador dado
     * @throws DAOException
     */
    protected SolicitudEnhanced getSolicitudByID(SolicitudEnhancedPk oid,
            PersistenceManager pm) throws DAOException {
        SolicitudEnhanced rta = null;

        if ((oid.idSolicitud != null)) {
            try {
                rta = (SolicitudEnhanced) pm.getObjectById(oid, true);
            } catch (JDOObjectNotFoundException e) {
                rta = null;
            } catch (JDOException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                throw new DAOException(e.getMessage(), e);
            }
        }
        return rta;
    }

    /**
     * Obtiene un objeto Anotacion, si la anotacion es temporal, trael la
     * temporal si es definitiva trae la definitiva
     *
     * @throws DAOException
     */
    public Anotacion getAnotacion(AnotacionPk oid) throws DAOException {
        Anotacion rta = null;

        PersistenceManager pm = AdministradorPM.getPM();
        AnotacionEnhanced rtaEn = null;

        try {
            AnotacionEnhancedPk anId = new AnotacionEnhancedPk();
            anId.idMatricula = oid.idMatricula;
            anId.idAnotacion = oid.idAnotacion;

            AnotacionTMPPk antTmpId = new AnotacionTMPPk();
            antTmpId.idMatricula = oid.idMatricula;
            antTmpId.idAnotacionTmp = oid.idAnotacion;

            AnotacionEnhanced anotacionDefinitiva = this.getAnotacionByID(anId, pm);
            AnotacionTMP anotacionTemporal = this.getAnotacionTMPByID(antTmpId, pm);

            if (anotacionDefinitiva != null) {
                if (anotacionTemporal != null) {
                    this.makeTransientAnotacion(anotacionDefinitiva, pm, new ArrayList());
                    this.makeTransientAnotacionTMP(anotacionTemporal, pm, new ArrayList());
                    rtaEn = this.getAnotacionDefinitivaConDeltasAplicados(anotacionDefinitiva, anotacionTemporal);
                } else {
                    rtaEn = anotacionDefinitiva;
                }
            } else {
                if (anotacionTemporal != null) {
                    anotacionDefinitiva = new AnotacionEnhanced();
                    anotacionDefinitiva.setIdMatricula(oid.idMatricula);
                    anotacionDefinitiva.setIdAnotacion(oid.idAnotacion);
                    this.makeTransientAnotacion(anotacionDefinitiva, pm, new ArrayList());
                    this.makeTransientAnotacionTMP(anotacionTemporal, pm, new ArrayList());
                    rtaEn = this.getAnotacionDefinitivaConDeltasAplicados(anotacionDefinitiva, anotacionTemporal);
                }
            }
            if (rtaEn != null) {
                this.makeTransientAnotacion(rtaEn, pm, new ArrayList());
                rta = (Anotacion) TransferUtils.makeTransfer(rtaEn);
            }
        } catch (DAOException e) {
            throw e;
        } finally {
            pm.close();
        }
        return rta;
    }

    public boolean isUltimoPropietario(AnotacionCiudadano anota) throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        AnotacionCiudadanoEnhanced anotaCiud = AnotacionCiudadanoEnhanced.enhance(anota);
        boolean ultimoPropietario = false;

        AnotacionCiudadanoEnhancedPk aCid = new AnotacionCiudadanoEnhancedPk();
        aCid.idAnotacion = anotaCiud.getIdAnotacion();
        aCid.idCiudadano = anotaCiud.getIdCiudadano();
        aCid.idMatricula = anotaCiud.getIdMatricula();
        aCid.rolPersona = anotaCiud.getRolPersona();

        pm.currentTransaction().setOptimistic(true);
        pm.currentTransaction().begin();
        try {
            AnotacionCiudadanoEnhanced anotaCiudadanoEnhanced = this.getAnotacionCiudadano(aCid, pm);
            ultimoPropietario = this.isUltimoPropietario(anotaCiudadanoEnhanced, pm);
        } catch (DAOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }

        return ultimoPropietario;
    }

    public FolioDerivadoTMP getFoliosDerivadosTMPByMatriculaPadre(String matriculaPadre, String matriculaHijo,
            PersistenceManager pm) throws DAOException {
        FolioDerivadoTMP fd = null;
        try {
            Query query = pm.newQuery(FolioDerivadoTMP.class);
            query.setOrdering("this.hijoTmp.folio.ordenLPAD ascending");
            query.declareParameters("String matriculaPadre,String matriculaHijo");
            query.setFilter("this.idMatricula == matriculaPadre && this.toDelete==0 "
                    + "&& this.idMatricula1 == matriculaHijo");
            Collection col = (Collection) query.execute(matriculaPadre, matriculaHijo);
            for (Iterator iter = col.iterator(); iter.hasNext();) {
                fd = (FolioDerivadoTMP) iter.next();
            }
            query.closeAll();
        } catch (JDOObjectNotFoundException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }
        return fd;
    }

    public void updateFolioDerivado(List foliosDerivadosModificados, Folio folioPadre, Usuario usuario) throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        try {
            pm.currentTransaction().setOptimistic(true);
            pm.currentTransaction().begin();
            Object[] folios;
            List anotacionesTmpDerivadas = new ArrayList();
            boolean existeDerivadoTmp;
            for (int i = 0; i < foliosDerivadosModificados.size(); i++) {
                existeDerivadoTmp = false;
                folios = (Object[]) foliosDerivadosModificados.get(i);
                FolioDerivado folioDerivado = (FolioDerivado) folios[0];
                FolioDerivado folioDerivadoDelete = (FolioDerivado) folios[1];
                FolioDerivadoTMPPk folioDerPk = new FolioDerivadoTMPPk();
                folioDerPk.idAnotacionTmp = folioDerivado.getIdAnotacion();
                folioDerPk.idAnotacion1Tmp = folioDerivado.getIdAnotacion1();
                folioDerPk.idMatricula = folioDerivado.getIdMatricula();
                folioDerPk.idMatricula1 = folioDerivado.getIdMatricula1();
                FolioDerivadoTMP folioDerivadoTmp;
                FolioDerivadoTMP folioDerivadoTmpDelete = null;
                AnotacionTMP anotahija;
                AnotacionTMP anotapadre;
                try {
                    folioDerivadoTmp = (FolioDerivadoTMP) pm.getObjectById(folioDerPk, true);
                } catch (JDOObjectNotFoundException e) {
                    folioDerivadoTmp = null;
                } catch (JDOException e) {
                    if (pm.currentTransaction().isActive()) {
                        pm.currentTransaction().rollback();
                    }
                    Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                    throw new DAOException(e.getMessage(), e);
                }
                if (folioDerivadoTmp == null) {
                    folioDerivadoTmp = new FolioDerivadoTMP();
                    folioDerivadoTmp = new FolioDerivadoTMP(folioDerivado);
                } else {
                    existeDerivadoTmp = true;
                    pm.deletePersistent(folioDerivadoTmp);
                    FolioDerivadoTMP folDer = getFoliosDerivadosTMPByMatriculaPadre(folioDerivado.getIdMatricula(), folioDerivado.getIdMatricula1(),
                            pm);
                    //Anotacion derivada
                    AnotacionTMP anotaTmp = null;
                    if (folDer != null && folDer.getHijoTmp() != null) {
                        AnotacionTMPPk anotaDerTmpPk = new AnotacionTMPPk();
                        anotaDerTmpPk.idAnotacionTmp = folDer.getHijoTmp().getIdAnotacionTmp();
                        anotaDerTmpPk.idMatricula = folDer.getHijoTmp().getIdMatricula();
                        anotaTmp = (AnotacionTMP) pm.getObjectById(anotaDerTmpPk, true);
                        if (anotaTmp != null && !anotacionesTmpDerivadas.contains(anotaTmp)) {
                            anotacionesTmpDerivadas.add(anotaTmp);
                        }
                    }
                    pm.deletePersistent(folDer);
                }

                if (!existeDerivadoTmp) {
                    anotahija = creaAnotacionTmpToDefinitiva(folioDerivado.getIdAnotacion1(), folioDerivado.getIdMatricula1(), pm);
                    folioDerivadoTmp.setHijoTmp(anotahija);
                    anotapadre = creaAnotacionTmpToDefinitiva(folioDerivado.getIdAnotacion(), folioDerivado.getIdMatricula(), pm);
                    folioDerivadoTmp.setPadreTmp(anotapadre);
                    pm.makePersistent(folioDerivadoTmp);
                }

                //folio derivado to delete
                if (!existeDerivadoTmp) {
                    folioDerPk = new FolioDerivadoTMPPk();
                    folioDerPk.idAnotacionTmp = folioDerivadoDelete.getIdAnotacion();
                    folioDerPk.idAnotacion1Tmp = folioDerivadoDelete.getIdAnotacion1();
                    folioDerPk.idMatricula = folioDerivadoDelete.getIdMatricula();
                    folioDerPk.idMatricula1 = folioDerivadoDelete.getIdMatricula1();
                    try {
                        folioDerivadoTmpDelete = (FolioDerivadoTMP) pm.getObjectById(folioDerPk, true);
                    } catch (JDOObjectNotFoundException e) {
                        folioDerivadoTmpDelete = null;
                    } catch (JDOException e) {
                        if (pm.currentTransaction().isActive()) {
                            pm.currentTransaction().rollback();
                        }
                        Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                        throw new DAOException(e.getMessage(), e);
                    }
                    if (folioDerivadoTmpDelete == null) {
                        folioDerivadoTmpDelete = new FolioDerivadoTMP(folioDerivadoDelete);
                    }
                    folioDerivadoTmpDelete.setToDelete(true);
                    AnotacionTMP anotahijaDel;
                    AnotacionTMP anotapadreDel;
                    anotahijaDel = creaAnotacionTmpToDefinitiva(folioDerivadoDelete.getIdAnotacion1(), folioDerivadoDelete.getIdMatricula1(), pm);
                    folioDerivadoTmpDelete.setHijoTmp(anotahijaDel);
                    anotapadreDel = creaAnotacionTmpToDefinitiva(folioDerivadoDelete.getIdAnotacion(), folioDerivadoDelete.getIdMatricula(), pm);
                    folioDerivadoTmpDelete.setPadreTmp(anotapadreDel);
                    pm.makePersistent(folioDerivadoTmpDelete);
                }

            }

            for (int i = 0; i < anotacionesTmpDerivadas.size(); i++) {
                AnotacionTMP anotaTmp = (AnotacionTMP) anotacionesTmpDerivadas.get(i);
                if (anotaTmp != null) {
                    pm.deletePersistent(anotaTmp);
                }
            }

            //actualizar salvedad
            if (folioPadre.getIdMatricula() != null) {
                FolioEnhancedPk oid = new FolioEnhancedPk();
                oid.idMatricula = folioPadre.getIdMatricula();
                FolioEnhanced folioEn = this.getFolioByID(oid, pm);
                UsuarioEnhanced us;
                UsuarioEnhancedPk uid = new UsuarioEnhancedPk();
                uid.idUsuario = usuario.getIdUsuario();
                uid.idUsuario = usuario.getIdUsuario();
                us = this.getUsuarioByID(uid, pm);
                this.updateFolioSalvedades(folioEn, folioPadre, us, pm);
            }
            pm.currentTransaction().commit();
        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (Throwable e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }
    }

    public AnotacionTMP creaAnotacionTmpToDefinitiva(String idAnotacion, String idMatricula,
            PersistenceManager pm) throws DAOException {
        AnotacionTMPPk anotaPk = new AnotacionTMPPk();
        anotaPk.idAnotacionTmp = idAnotacion;
        anotaPk.idMatricula = idMatricula;
        AnotacionTMP anotaTmp;
        try {
            anotaTmp = (AnotacionTMP) pm.getObjectById(anotaPk, true);
        } catch (JDOObjectNotFoundException e) {
            anotaTmp = null;
        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }
        //si es nula se crea temporal a partir de la definitiva
        if (anotaTmp == null) {
            AnotacionEnhancedPk anotaEnhPk = new AnotacionEnhancedPk();
            anotaEnhPk.idAnotacion = idAnotacion;
            anotaEnhPk.idMatricula = idMatricula;
            AnotacionEnhanced anotaEnh;
            try {
                anotaEnh = (AnotacionEnhanced) pm.getObjectById(anotaEnhPk, true);
                if (anotaEnh != null) {
                    anotaTmp = new AnotacionTMP();
                    anotaTmp.setIdAnotacionTmp(anotaEnh.getIdAnotacion());
                    anotaTmp.setIdMatricula(anotaEnh.getIdMatricula());
                    anotaTmp.setNaturalezaJuridica(anotaEnh.getNaturalezaJuridica());
                    anotaTmp.setTipoAnotacion(anotaEnh.getTipoAnotacion());
                    anotaTmp.setEstado(anotaEnh.getEstado());
                    pm.makePersistent(anotaTmp);
                }
            } catch (JDOObjectNotFoundException e) {
                anotaEnh = null;
            } catch (JDOException e) {
                if (pm.currentTransaction().isActive()) {
                    pm.currentTransaction().rollback();
                }
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                throw new DAOException(e.getMessage(), e);
            }
        }
        return anotaTmp;
    }

    /*Adiciona Funcionalidad Boton de Pago Author: Ingeniero Diego Hernadez Modificacion en: 23/02/2010 by jvenegas */
    public List getAlertasMatriculas(String idMatricula) throws DAOException {
        List alertas = new ArrayList();
        try {
            String[] consultas = consultaBD(idMatricula);
            if (consultas != null && consultas.length == 8) {
                if (!consultas[0].equals("")) {
                    alertas.add(armarMensaje(consultas[0], "DEMANDA VIGENTE"));
                }
                if (!consultas[1].equals("")) {
                    alertas.add(armarMensaje(consultas[1], "EMBARGO VIGENTE"));
                }
                if (!consultas[2].equals("")) {
                    alertas.add(armarMensaje(consultas[2], "PATRIMONIO VIGENTE"));
                }
                if (!consultas[3].equals("")) {
                    alertas.add(armarMensaje(consultas[3], "AFECTACION VIGENTE"));
                }
                if (!consultas[4].equals("")) {
                    alertas.add(armarMensaje(consultas[4], "VALORIZACION VIGENTE"));
                }
                if (!consultas[5].equals("")) {
                    alertas.add(armarMensaje(consultas[5], "HIPOTECA VIGENTE"));
                }
                if (!consultas[6].equals("")) {
                    alertas.add(armarMensaje(consultas[6], "OFERTA VIGENTE"));
                }
                if (!consultas[7].equals("")) {
                    alertas.add(armarMensaje(consultas[7], "FALSA TRADICION"));
                }

                String anotacionesInvalidas = consultaAnotacionesInvalidas(idMatricula);

                if (anotacionesInvalidas != null && !anotacionesInvalidas.trim().equals("")) {
                    alertas.add(anotacionesInvalidas);
                }
            }
        } catch (DAOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw e;
        } catch (Exception e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        }
        return alertas;
    }

    /*Adiciona Funcionalidad Boton de Pago Author: Ingeniero Diego Hernadez Modificacion en: 23/02/2010 by jvenegas */
    private String armarMensaje(String datos, String complemento) {
        String mensaje = null;
        if (datos != null && !datos.trim().equals("")) {
            if ((datos.split(",")).length > 2) {
                int posicion = datos.lastIndexOf(',');
                mensaje = "LAS ANOTACIONES " + datos.substring(1, posicion)
                        + " y" + datos.substring(posicion + 1) + " TIENEN " + complemento;
            } else {
                mensaje = "LA ANOTACION " + datos.substring(1) + " TIENE " + complemento;
            }
        }
        return mensaje;
    }

    /*Adiciona Funcionalidad Boton de Pago Author: Ingeniero Diego Hernadez Modificacion en: 23/02/2010 by jvenegas */
    private String[] consultaBD(String idMatricula) throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        pm.currentTransaction().begin();
        String[] lstConsulta = null;
        VersantPersistenceManager jdoPM = (VersantPersistenceManager) pm;
        Connection connection = null;
        connection = jdoPM.getJdbcConnection(null);

        //SELECT realizado a las tablas SIR_NE_ANOTACION y SIR_NE_NATURALEZA_JURIDICA para cargar las consultas
        //de alertas para una matricula.
        String sql = "SELECT N.ID_GRUPO_NAT_JURIDICA,A.NTCN_ORDEN,N.ID_DOMINIO_NAT_JUR "
                + "FROM SIR_NE_ANOTACION A,SIR_NE_NATURALEZA_JURIDICA N "
                + "WHERE A.ID_MATRICULA = ? "
                + "AND A.ID_NATURALEZA_JURIDICA = N.ID_NATURALEZA_JURIDICA "
                + "AND (N.ID_NATURALEZA_JURIDICA IN (SELECT ID_NATURALEZA_JURIDICA "
                + "FROM SIR_NE_NATURALEZA_JURIDICA WHERE ID_DOMINIO_NAT_JUR IN "
                + "('H','A','P','D','E','V','O')) "
                + "OR N.ID_NATURALEZA_JURIDICA IN ('600','601','610','611','612') "
                + "OR N.ID_NATURALEZA_JURIDICA LIKE '06%') "
                + "AND A.ID_ANOTACION NOT IN (SELECT ID_ANOTACION1 "
                + "FROM SIR_NE_REL_CANCELACION "
                + "WHERE ID_MATRICULA = ?) "
                + "AND A.ID_ESTADO_AN='V' "
                + "ORDER BY 2";

        try {
            List demanda = new ArrayList();
            List embargo = new ArrayList();
            List patrimonio = new ArrayList();
            List afectacion = new ArrayList();
            List valorizacion = new ArrayList();
            List hipoteca = new ArrayList();
            List oferta = new ArrayList();
            List falsaTradicion = new ArrayList();
            PreparedStatement pst = connection.prepareStatement(sql);
            pst.setString(1, idMatricula);
            pst.setString(2, idMatricula);

            ResultSet rs = pst.executeQuery();

            //List en el que se cargaran los resultados de la consulta.
            //Este será un List<String[]> en el que el String[] tendrá
            //4 posiciones [0] = id_naturaleza_juridica, [1] = id_anotacion
            //[2] = ntcn_orden, [3] = id_dominio_nat_jur
            while (rs.next()) {
                String idGrupoNatJuridica = rs.getString(1);
                String ntcnOrden = rs.getString(2);
                String idDominioNatJur = rs.getString(3);

                while (ntcnOrden.startsWith("0")) {
                    ntcnOrden = ntcnOrden.substring(1);
                }

                if (idDominioNatJur.trim().equals("D")) {
                    demanda.add(new Integer(ntcnOrden));
                } else if (idDominioNatJur.trim().equals("E")) {
                    embargo.add(new Integer(ntcnOrden));
                } else if (idDominioNatJur.trim().equals("P")) {
                    patrimonio.add(new Integer(ntcnOrden));
                } else if (idDominioNatJur.trim().equals("A")) {
                    afectacion.add(new Integer(ntcnOrden));
                } else if (idDominioNatJur.trim().equals("V")) {
                    valorizacion.add(new Integer(ntcnOrden));
                } else if (idDominioNatJur.trim().equals("H")) {
                    hipoteca.add(new Integer(ntcnOrden));
                } else if (idDominioNatJur.trim().equals("O")) {
                    oferta.add(new Integer(ntcnOrden));
                } else if (idGrupoNatJuridica.equals(CGrupoNaturalezaJuridica.FALSA_TRADICION)) {
                    falsaTradicion.add(new Integer(ntcnOrden));
                }
            }

            String[] aux = {list2Str(demanda), list2Str(embargo), list2Str(patrimonio),
                list2Str(afectacion), list2Str(valorizacion), list2Str(hipoteca),
                list2Str(oferta), list2Str(falsaTradicion)};
            lstConsulta = aux;

            rs.close();
            pst.close();

            pm.currentTransaction().commit();
        } catch (SQLException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException("Error SQL: " + e.getMessage(), e);
        } catch (Exception e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException("Error SQL: " + e.getMessage(), e);
        } finally {
            if (connection != null) {
                try {
                    connection.close();
                } catch (SQLException e1) {
                    Log.getInstance().error(JDOGenieFolioDAO.class, e1.getMessage());
                }
            }
            pm.close();
        }
        return lstConsulta;
    }

    /*Adiciona Funcionalidad Boton de Pago Author: Ingeniero Diego Hernadez Modificacion en: 23/02/2010 by jvenegas */
    private String list2Str(List list) {
        if (list != null && list.size() > 0) {
            Collections.sort(list);
            return "," + list.toString().substring(1, list.toString().length() - 1);
        }
        return "";
    }

    /*Adiciona Funcionalidad Boton de Pago Author: Ingeniero Diego Hernadez Modificacion en: 23/02/2010 by jvenegas */
    private String consultaAnotacionesInvalidas(String idMatricula) throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        String rta = null;
        List res = new ArrayList();
        AnotacionEnhanced anota;

        try {
            //Se debe buscar por algún criterio las anotaciones
            pm.currentTransaction().begin();

            VersantQuery query = (VersantQuery) pm.newQuery(AnotacionEnhanced.class);
            query.declareParameters("String idMatricula");
            query.setRandomAccess(true);
            query.setOrdering("ordenLPAD ascending");
            query.setFilter("this.idMatricula == idMatricula && this.estado.idEstadoAn == 'A'");

            res = (List) query.execute(idMatricula);

            if (res != null && res.size() > 0) {
                String aux = "";
                int tamanio = res.size();
                for (int i = 0; i < tamanio; i++) {
                    anota = (AnotacionEnhanced) res.get(i);
                    String orden = anota.getOrden();
                    while (orden.startsWith("0")) {
                        orden = orden.substring(1);
                    }
                    if (i == 0) {
                        aux += orden;
                    } else if (i == tamanio - 1) {
                        aux += " y " + orden;
                    } else {
                        aux += ", " + orden;
                    }
                }
                if (tamanio > 1) {
                    rta = "LAS ANOTACIONES " + aux + " SON INVALIDAS";
                } else {
                    rta = "LA ANOTACION " + aux + " ES INVALIDA";
                }
            }
        } catch (JDOException e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } catch (Throwable e) {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().rollback();
            }
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            if (pm.currentTransaction().isActive()) {
                pm.currentTransaction().commit();
            }
            pm.close();
        }
        return rta;
    }

    /**
     * @author : Carlos Mario Torres Urina
     * @casoMantis : 11767.
     * @actaReq : Requerimiento No
     * 089_151_Proceso_correcciones_permitir_varias_correcciones.
     * @change : Retorna la anotacion temporal
     * @param : oid.
     * @param : idanotacion.
     * @throws : DAOException.
     */
    public Anotacion getAnotacionTMP(FolioPk oid, String idanotacion) throws DAOException {
        AnotacionTMP anotacionTmps = null;
        PersistenceManager pm = AdministradorPM.getPM();
        Anotacion ant = new Anotacion();
        try {
            AnotacionTMPPk pk = new AnotacionTMPPk();
            pk.idAnotacionTmp = idanotacion;
            pk.idMatricula = oid.idMatricula;
            anotacionTmps = this.getAnotacionTMPByID(pk, pm);
            ant.setIdAnotacion(anotacionTmps.getIdAnotacionTmp());
            ant.setIdMatricula(anotacionTmps.getIdMatricula());
            ant.setEstado((EstadoAnotacion) anotacionTmps.getEstado().toTransferObject());
            ant.setTipoAnotacion((TipoAnotacion) anotacionTmps.getTipoAnotacion().toTransferObject());
            ant.setLastIdSalvedad(anotacionTmps.getLastIdSalvedad());
            ant.setEspecificacion(anotacionTmps.getEspecificacion());
            ant.setOrden(anotacionTmps.getOrden());
            ant.setNaturalezaJuridica((NaturalezaJuridica) anotacionTmps.getNaturalezaJuridica().toTransferObject());
            ant.setDocumento((Documento) anotacionTmps.getDocumento().toTransferObject());
            ant.setValor(anotacionTmps.getValor());
        } catch (JDOObjectNotFoundException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            return null;
        } catch (JDOException e) {
            Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
            throw new DAOException(e.getMessage(), e);
        } finally {
            pm.close();
        }
        return ant;
    }

    /**
     * @Autor: Edgar Lora
     * @Mantis: 13176
     */
    public NaturalezaJuridicaEnhanced getNaturalezaJuridicaById(NaturalezaJuridicaEnhancedPk pk) throws DAOException {
        PersistenceManager pm = AdministradorPM.getPM();
        return (NaturalezaJuridicaEnhanced) pm.getObjectById(pk, true);
    }

    /*
        *  @author Carlos Torres
        *  @chage   Nuevo metodo 
        *  @mantis 12705: Acta - Requerimiento No 056_453_Modificiación_de_Naturaleza_Jurídica
     */
    protected static GrupoNaturalezaJuridicaEnhanced copy(GrupoNaturalezaJuridicaEnhanced orig) {
        GrupoNaturalezaJuridicaEnhanced obj = new GrupoNaturalezaJuridicaEnhanced();
        obj.setIdGrupoNatJuridica(orig.getIdGrupoNatJuridica());
        obj.setNombre(orig.getNombre());
        return obj;
    }

    /**
     * @author Carlos Torres
     * @mantis 0013414: Acta - Requerimiento No 069_453_Código_Notaria_NC
     * Obtiene una oficina origen por ID
     * @param oid
     * @return
     * @throws DAOException
     */
    public OficinaOrigen getOficinaOrigen(String idOficina) throws DAOException {
        OficinaOrigenEnhanced ef = null;
        PersistenceManager pm = AdministradorPM.getPM();
        OficinaOrigen aux = null;

        try {
            ef = this.getOficinaOrigen(idOficina, pm);
            this.makeTransientOficinaOrigen(ef, pm);
        } catch (DAOException e) {
            throw e;
        } finally {
            pm.close();
        }

        if (ef != null) {
            aux = (OficinaOrigen) ef.toTransferObject();
        }

        return aux;
    }

    /**
     * @author Carlos Torres
     * @mantis 0013414: Acta - Requerimiento No 069_453_Código_Notaria_NC
     * Obtiene un TipoPredio dado su identificador, usado para transacciones se
     * debe dar el PersistenceManager
     * @param oid identificador del tipoPredio
     * @return objeto TipoPredio
     * @throws DAOException
     */
    protected OficinaOrigenEnhanced getOficinaOrigen(String idOficina, PersistenceManager pm)
            throws DAOException {
        OficinaOrigenEnhanced rta = null;
        OficinaOrigenEnhancedPk oid = null;
        oid = new OficinaOrigenEnhancedPk();
        oid.idOficinaOrigen = idOficina;
        OficinaOrigen of = new OficinaOrigen();
        of.setIdOficinaOrigen(idOficina);
        oid.version = this.getMaxOficinaOrigen(of);
        if (oid.idOficinaOrigen != null) {
            try {
                rta = (OficinaOrigenEnhanced) pm.getObjectById(oid, true);
            } catch (JDOObjectNotFoundException e) {
                rta = null;
            } catch (JDOException e) {
                Log.getInstance().error(JDOGenieFolioDAO.class, e.getMessage());
                throw new DAOException(e.getMessage(), e);
            }
        }

        return rta;
    }
}
